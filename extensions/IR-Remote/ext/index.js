(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["exports"], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports);
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports);
    global.unknown = mod.exports;
  }
})(this, function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = void 0;
  !function (global) {
    "use strict";

    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    var undefined;
    var $Symbol = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
    var inModule = typeof module === "object";
    var runtime = global.regeneratorRuntime;

    if (runtime) {
      if (inModule) {
        module.exports = runtime;
      }

      return;
    }

    runtime = global.regeneratorRuntime = inModule ? module.exports || {} : {};

    function wrap(innerFn, outerFn, self, tryLocsList) {
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
      var generator = Object.create(protoGenerator.prototype);
      var context = new Context(tryLocsList || []);
      generator._invoke = makeInvokeMethod(innerFn, self, context);
      return generator;
    }

    runtime.wrap = wrap;

    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg)
        };
      } catch (err) {
        return {
          type: "throw",
          arg: err
        };
      }
    }

    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed";
    var ContinueSentinel = {};

    function Generator() {}

    function GeneratorFunction() {}

    function GeneratorFunctionPrototype() {}

    var IteratorPrototype = {};

    IteratorPrototype[iteratorSymbol] = function () {
      return this;
    };

    var getProto = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
      IteratorPrototype = NativeIteratorPrototype;
    }

    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
    GeneratorFunctionPrototype.constructor = GeneratorFunction;
    GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";

    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function (method) {
        prototype[method] = function (arg) {
          return this._invoke(method, arg);
        };
      });
    }

    runtime.isGeneratorFunction = function (genFun) {
      var ctor = typeof genFun === "function" && genFun.constructor;
      return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
    };

    runtime.mark = function (genFun) {
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
      } else {
        genFun.__proto__ = GeneratorFunctionPrototype;

        if (!(toStringTagSymbol in genFun)) {
          genFun[toStringTagSymbol] = "GeneratorFunction";
        }
      }

      genFun.prototype = Object.create(Gp);
      return genFun;
    };

    runtime.awrap = function (arg) {
      return {
        __await: arg
      };
    };

    function AsyncIterator(generator) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);

        if (record.type === "throw") {
          reject(record.arg);
        } else {
          var result = record.arg;
          var value = result.value;

          if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
            return Promise.resolve(value.__await).then(function (value) {
              invoke("next", value, resolve, reject);
            }, function (err) {
              invoke("throw", err, resolve, reject);
            });
          }

          return Promise.resolve(value).then(function (unwrapped) {
            result.value = unwrapped;
            resolve(result);
          }, function (error) {
            return invoke("throw", error, resolve, reject);
          });
        }
      }

      var previousPromise;

      function enqueue(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new Promise(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }

        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }

      this._invoke = enqueue;
    }

    defineIteratorMethods(AsyncIterator.prototype);

    AsyncIterator.prototype[asyncIteratorSymbol] = function () {
      return this;
    };

    runtime.AsyncIterator = AsyncIterator;

    runtime.async = function (innerFn, outerFn, self, tryLocsList) {
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));
      return runtime.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
        return result.done ? result.value : iter.next();
      });
    };

    function makeInvokeMethod(innerFn, self, context) {
      var state = GenStateSuspendedStart;
      return function invoke(method, arg) {
        if (state === GenStateExecuting) {
          throw new Error("Generator is already running");
        }

        if (state === GenStateCompleted) {
          if (method === "throw") {
            throw arg;
          }

          return doneResult();
        }

        context.method = method;
        context.arg = arg;

        while (true) {
          var delegate = context.delegate;

          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);

            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if (context.method === "next") {
            context.sent = context._sent = context.arg;
          } else if (context.method === "throw") {
            if (state === GenStateSuspendedStart) {
              state = GenStateCompleted;
              throw context.arg;
            }

            context.dispatchException(context.arg);
          } else if (context.method === "return") {
            context.abrupt("return", context.arg);
          }

          state = GenStateExecuting;
          var record = tryCatch(innerFn, self, context);

          if (record.type === "normal") {
            state = context.done ? GenStateCompleted : GenStateSuspendedYield;

            if (record.arg === ContinueSentinel) {
              continue;
            }

            return {
              value: record.arg,
              done: context.done
            };
          } else if (record.type === "throw") {
            state = GenStateCompleted;
            context.method = "throw";
            context.arg = record.arg;
          }
        }
      };
    }

    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];

      if (method === undefined) {
        context.delegate = null;

        if (context.method === "throw") {
          if (delegate.iterator.return) {
            context.method = "return";
            context.arg = undefined;
            maybeInvokeDelegate(delegate, context);

            if (context.method === "throw") {
              return ContinueSentinel;
            }
          }

          context.method = "throw";
          context.arg = new TypeError("The iterator does not provide a 'throw' method");
        }

        return ContinueSentinel;
      }

      var record = tryCatch(method, delegate.iterator, context.arg);

      if (record.type === "throw") {
        context.method = "throw";
        context.arg = record.arg;
        context.delegate = null;
        return ContinueSentinel;
      }

      var info = record.arg;

      if (!info) {
        context.method = "throw";
        context.arg = new TypeError("iterator result is not an object");
        context.delegate = null;
        return ContinueSentinel;
      }

      if (info.done) {
        context[delegate.resultName] = info.value;
        context.next = delegate.nextLoc;

        if (context.method !== "return") {
          context.method = "next";
          context.arg = undefined;
        }
      } else {
        return info;
      }

      context.delegate = null;
      return ContinueSentinel;
    }

    defineIteratorMethods(Gp);
    Gp[toStringTagSymbol] = "Generator";

    Gp[iteratorSymbol] = function () {
      return this;
    };

    Gp.toString = function () {
      return "[object Generator]";
    };

    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };

      if (1 in locs) {
        entry.catchLoc = locs[1];
      }

      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }

      this.tryEntries.push(entry);
    }

    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }

    function Context(tryLocsList) {
      this.tryEntries = [{
        tryLoc: "root"
      }];
      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }

    runtime.keys = function (object) {
      var keys = [];

      for (var key in object) {
        keys.push(key);
      }

      keys.reverse();
      return function next() {
        while (keys.length) {
          var key = keys.pop();

          if (key in object) {
            next.value = key;
            next.done = false;
            return next;
          }
        }

        next.done = true;
        return next;
      };
    };

    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];

        if (iteratorMethod) {
          return iteratorMethod.call(iterable);
        }

        if (typeof iterable.next === "function") {
          return iterable;
        }

        if (!isNaN(iterable.length)) {
          var i = -1,
              next = function next() {
            while (++i < iterable.length) {
              if (hasOwn.call(iterable, i)) {
                next.value = iterable[i];
                next.done = false;
                return next;
              }
            }

            next.value = undefined;
            next.done = true;
            return next;
          };

          return next.next = next;
        }
      }

      return {
        next: doneResult
      };
    }

    runtime.values = values;

    function doneResult() {
      return {
        value: undefined,
        done: true
      };
    }

    Context.prototype = {
      constructor: Context,
      reset: function (skipTempReset) {
        this.prev = 0;
        this.next = 0;
        this.sent = this._sent = undefined;
        this.done = false;
        this.delegate = null;
        this.method = "next";
        this.arg = undefined;
        this.tryEntries.forEach(resetTryEntry);

        if (!skipTempReset) {
          for (var name in this) {
            if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
              this[name] = undefined;
            }
          }
        }
      },
      stop: function () {
        this.done = true;
        var rootEntry = this.tryEntries[0];
        var rootRecord = rootEntry.completion;

        if (rootRecord.type === "throw") {
          throw rootRecord.arg;
        }

        return this.rval;
      },
      dispatchException: function (exception) {
        if (this.done) {
          throw exception;
        }

        var context = this;

        function handle(loc, caught) {
          record.type = "throw";
          record.arg = exception;
          context.next = loc;

          if (caught) {
            context.method = "next";
            context.arg = undefined;
          }

          return !!caught;
        }

        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          var record = entry.completion;

          if (entry.tryLoc === "root") {
            return handle("end");
          }

          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc");
            var hasFinally = hasOwn.call(entry, "finallyLoc");

            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              } else if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              }
            } else if (hasFinally) {
              if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else {
              throw new Error("try statement without catch or finally");
            }
          }
        }
      },
      abrupt: function (type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }

        if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
          finallyEntry = null;
        }

        var record = finallyEntry ? finallyEntry.completion : {};
        record.type = type;
        record.arg = arg;

        if (finallyEntry) {
          this.method = "next";
          this.next = finallyEntry.finallyLoc;
          return ContinueSentinel;
        }

        return this.complete(record);
      },
      complete: function (record, afterLoc) {
        if (record.type === "throw") {
          throw record.arg;
        }

        if (record.type === "break" || record.type === "continue") {
          this.next = record.arg;
        } else if (record.type === "return") {
          this.rval = this.arg = record.arg;
          this.method = "return";
          this.next = "end";
        } else if (record.type === "normal" && afterLoc) {
          this.next = afterLoc;
        }

        return ContinueSentinel;
      },
      finish: function (finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.finallyLoc === finallyLoc) {
            this.complete(entry.completion, entry.afterLoc);
            resetTryEntry(entry);
            return ContinueSentinel;
          }
        }
      },
      "catch": function (tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;

            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }

            return thrown;
          }
        }

        throw new Error("illegal catch attempt");
      },
      delegateYield: function (iterable, resultName, nextLoc) {
        this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        };

        if (this.method === "next") {
          this.arg = undefined;
        }

        return ContinueSentinel;
      }
    };
  }(function () {
    return this || typeof self === "object" && self;
  }() || Function("return this")());
  undefined;
  const disableBlocks = {
    debug: [],
    upload: []
  };
  const mustLoginBlocks = [];

  const triggerBlocksStatus = async (mode, app) => {};

  class ExtImpl {}

  const extTranslationMap = {
    "zh": {
      "lepton_ir_remote": "Lepton IR Remote",
      "extensionName": "Lepton IR Remote",
      "extensionDescription": "Receives infrared signals from a remote control.\n",
      "BLOCK_1713216604395": "üöÄ Initialize pin [pin] ",
      "BLOCK_1713216604631": "üìñ Data received",
      "BLOCK_1713216604820": "‚úçÔ∏è Resume receiving data",
      "BLOCK_1713216605004": "command",
      "BLOCK_1713216605193": "protocol",
      "BLOCK_1713216605384": "raw data",
      "cate_fa32e659": "üí´ IR"
    },
    "de": {
      "lepton_ir_remote": "Lepton IR Remote",
      "extensionName": "Lepton IR Remote",
      "extensionDescription": "Receives infrared signals from a remote control.\n",
      "BLOCK_1713216604395": "üöÄ Initialize pin [pin] ",
      "BLOCK_1713216604631": "üìñ Data received",
      "BLOCK_1713216604820": "‚úçÔ∏è Resume receiving data",
      "BLOCK_1713216605004": "command",
      "BLOCK_1713216605193": "protocol",
      "BLOCK_1713216605384": "raw data",
      "cate_fa32e659": "üí´ IR"
    },
    "es": {
      "lepton_ir_remote": "Lepton IR Remote",
      "extensionName": "Lepton IR Remote",
      "extensionDescription": "Receives infrared signals from a remote control.\n",
      "BLOCK_1713216604395": "üöÄ Initialize pin [pin] ",
      "BLOCK_1713216604631": "üìñ Data received",
      "BLOCK_1713216604820": "‚úçÔ∏è Resume receiving data",
      "BLOCK_1713216605004": "command",
      "BLOCK_1713216605193": "protocol",
      "BLOCK_1713216605384": "raw data",
      "cate_fa32e659": "üí´ IR"
    },
    "fr": {
      "lepton_ir_remote": "Lepton IR Remote",
      "extensionName": "Lepton IR Remote",
      "extensionDescription": "Receives infrared signals from a remote control.\n",
      "BLOCK_1713216604395": "üöÄ Initialize pin [pin] ",
      "BLOCK_1713216604631": "üìñ Data received",
      "BLOCK_1713216604820": "‚úçÔ∏è Resume receiving data",
      "BLOCK_1713216605004": "command",
      "BLOCK_1713216605193": "protocol",
      "BLOCK_1713216605384": "raw data",
      "cate_fa32e659": "üí´ IR"
    },
    "id": {
      "lepton_ir_remote": "Lepton IR Remote",
      "extensionName": "Lepton IR Remote",
      "extensionDescription": "Receives infrared signals from a remote control.\n",
      "BLOCK_1713216604395": "üöÄ Initialize pin [pin] ",
      "BLOCK_1713216604631": "üìñ Data received",
      "BLOCK_1713216604820": "‚úçÔ∏è Resume receiving data",
      "BLOCK_1713216605004": "command",
      "BLOCK_1713216605193": "protocol",
      "BLOCK_1713216605384": "raw data",
      "cate_fa32e659": "üí´ IR"
    },
    "ja": {
      "lepton_ir_remote": "Lepton IR Remote",
      "extensionName": "Lepton IR Remote",
      "extensionDescription": "Receives infrared signals from a remote control.\n",
      "BLOCK_1713216604395": "üöÄ Initialize pin [pin] ",
      "BLOCK_1713216604631": "üìñ Data received",
      "BLOCK_1713216604820": "‚úçÔ∏è Resume receiving data",
      "BLOCK_1713216605004": "command",
      "BLOCK_1713216605193": "protocol",
      "BLOCK_1713216605384": "raw data",
      "cate_fa32e659": "üí´ IR"
    },
    "ja-jph": {
      "lepton_ir_remote": "Lepton IR Remote",
      "extensionName": "Lepton IR Remote",
      "extensionDescription": "Receives infrared signals from a remote control.\n",
      "BLOCK_1713216604395": "üöÄ Initialize pin [pin] ",
      "BLOCK_1713216604631": "üìñ Data received",
      "BLOCK_1713216604820": "‚úçÔ∏è Resume receiving data",
      "BLOCK_1713216605004": "command",
      "BLOCK_1713216605193": "protocol",
      "BLOCK_1713216605384": "raw data",
      "cate_fa32e659": "üí´ IR"
    },
    "ko": {
      "lepton_ir_remote": "Lepton IR Remote",
      "extensionName": "Lepton IR Remote",
      "extensionDescription": "Receives infrared signals from a remote control.\n",
      "BLOCK_1713216604395": "üöÄ Initialize pin [pin] ",
      "BLOCK_1713216604631": "üìñ Data received",
      "BLOCK_1713216604820": "‚úçÔ∏è Resume receiving data",
      "BLOCK_1713216605004": "command",
      "BLOCK_1713216605193": "protocol",
      "BLOCK_1713216605384": "raw data",
      "cate_fa32e659": "üí´ IR"
    },
    "pl": {
      "lepton_ir_remote": "Lepton IR Remote",
      "extensionName": "Lepton IR Remote",
      "extensionDescription": "Receives infrared signals from a remote control.\n",
      "BLOCK_1713216604395": "üöÄ Initialize pin [pin] ",
      "BLOCK_1713216604631": "üìñ Data received",
      "BLOCK_1713216604820": "‚úçÔ∏è Resume receiving data",
      "BLOCK_1713216605004": "command",
      "BLOCK_1713216605193": "protocol",
      "BLOCK_1713216605384": "raw data",
      "cate_fa32e659": "üí´ IR"
    },
    "uk": {
      "lepton_ir_remote": "Lepton IR Remote",
      "extensionName": "Lepton IR Remote",
      "extensionDescription": "Receives infrared signals from a remote control.\n",
      "BLOCK_1713216604395": "üöÄ Initialize pin [pin] ",
      "BLOCK_1713216604631": "üìñ Data received",
      "BLOCK_1713216604820": "‚úçÔ∏è Resume receiving data",
      "BLOCK_1713216605004": "command",
      "BLOCK_1713216605193": "protocol",
      "BLOCK_1713216605384": "raw data",
      "cate_fa32e659": "üí´ IR"
    },
    "zh-hant": {
      "lepton_ir_remote": "Lepton IR Remote",
      "extensionName": "Lepton IR Remote",
      "extensionDescription": "Receives infrared signals from a remote control.\n",
      "BLOCK_1713216604395": "üöÄ Initialize pin [pin] ",
      "BLOCK_1713216604631": "üìñ Data received",
      "BLOCK_1713216604820": "‚úçÔ∏è Resume receiving data",
      "BLOCK_1713216605004": "command",
      "BLOCK_1713216605193": "protocol",
      "BLOCK_1713216605384": "raw data",
      "cate_fa32e659": "üí´ IR"
    },
    "nl": {
      "lepton_ir_remote": "Lepton IR Remote",
      "extensionName": "Lepton IR Remote",
      "extensionDescription": "Receives infrared signals from a remote control.\n",
      "BLOCK_1713216604395": "üöÄ Initialize pin [pin] ",
      "BLOCK_1713216604631": "üìñ Data received",
      "BLOCK_1713216604820": "‚úçÔ∏è Resume receiving data",
      "BLOCK_1713216605004": "command",
      "BLOCK_1713216605193": "protocol",
      "BLOCK_1713216605384": "raw data",
      "cate_fa32e659": "üí´ IR"
    },
    "it": {
      "lepton_ir_remote": "Lepton IR Remote",
      "extensionName": "Lepton IR Remote",
      "extensionDescription": "Receives infrared signals from a remote control.\n",
      "BLOCK_1713216604395": "üöÄ Initialize pin [pin] ",
      "BLOCK_1713216604631": "üìñ Data received",
      "BLOCK_1713216604820": "‚úçÔ∏è Resume receiving data",
      "BLOCK_1713216605004": "command",
      "BLOCK_1713216605193": "protocol",
      "BLOCK_1713216605384": "raw data",
      "cate_fa32e659": "üí´ IR"
    },
    "hr": {
      "lepton_ir_remote": "Lepton IR Remote",
      "extensionName": "Lepton IR Remote",
      "extensionDescription": "Receives infrared signals from a remote control.\n",
      "BLOCK_1713216604395": "üöÄ Initialize pin [pin] ",
      "BLOCK_1713216604631": "üìñ Data received",
      "BLOCK_1713216604820": "‚úçÔ∏è Resume receiving data",
      "BLOCK_1713216605004": "command",
      "BLOCK_1713216605193": "protocol",
      "BLOCK_1713216605384": "raw data",
      "cate_fa32e659": "üí´ IR"
    },
    "ru": {
      "lepton_ir_remote": "Lepton IR Remote",
      "extensionName": "Lepton IR Remote",
      "extensionDescription": "Receives infrared signals from a remote control.\n",
      "BLOCK_1713216604395": "üöÄ Initialize pin [pin] ",
      "BLOCK_1713216604631": "üìñ Data received",
      "BLOCK_1713216604820": "‚úçÔ∏è Resume receiving data",
      "BLOCK_1713216605004": "command",
      "BLOCK_1713216605193": "protocol",
      "BLOCK_1713216605384": "raw data",
      "cate_fa32e659": "üí´ IR"
    },
    "pt": {
      "lepton_ir_remote": "Lepton IR Remote",
      "extensionName": "Lepton IR Remote",
      "extensionDescription": "Receives infrared signals from a remote control.\n",
      "BLOCK_1713216604395": "üöÄ Initialize pin [pin] ",
      "BLOCK_1713216604631": "üìñ Data received",
      "BLOCK_1713216604820": "‚úçÔ∏è Resume receiving data",
      "BLOCK_1713216605004": "command",
      "BLOCK_1713216605193": "protocol",
      "BLOCK_1713216605384": "raw data",
      "cate_fa32e659": "üí´ IR"
    },
    "fi": {
      "lepton_ir_remote": "Lepton IR Remote",
      "extensionName": "Lepton IR Remote",
      "extensionDescription": "Receives infrared signals from a remote control.\n",
      "BLOCK_1713216604395": "üöÄ Initialize pin [pin] ",
      "BLOCK_1713216604631": "üìñ Data received",
      "BLOCK_1713216604820": "‚úçÔ∏è Resume receiving data",
      "BLOCK_1713216605004": "command",
      "BLOCK_1713216605193": "protocol",
      "BLOCK_1713216605384": "raw data",
      "cate_fa32e659": "üí´ IR"
    },
    "tr": {
      "lepton_ir_remote": "Lepton IR Remote",
      "extensionName": "Lepton IR Remote",
      "extensionDescription": "Receives infrared signals from a remote control.\n",
      "BLOCK_1713216604395": "üöÄ Initialize pin [pin] ",
      "BLOCK_1713216604631": "üìñ Data received",
      "BLOCK_1713216604820": "‚úçÔ∏è Resume receiving data",
      "BLOCK_1713216605004": "command",
      "BLOCK_1713216605193": "protocol",
      "BLOCK_1713216605384": "raw data",
      "cate_fa32e659": "üí´ IR"
    },
    "tk": {
      "lepton_ir_remote": "Lepton IR Remote",
      "extensionName": "Lepton IR Remote",
      "extensionDescription": "Receives infrared signals from a remote control.\n",
      "BLOCK_1713216604395": "üöÄ Initialize pin [pin] ",
      "BLOCK_1713216604631": "üìñ Data received",
      "BLOCK_1713216604820": "‚úçÔ∏è Resume receiving data",
      "BLOCK_1713216605004": "command",
      "BLOCK_1713216605193": "protocol",
      "BLOCK_1713216605384": "raw data",
      "cate_fa32e659": "üí´ IR"
    },
    "en": {
      "lepton_ir_remote": "Lepton IR Remote",
      "extensionName": "Lepton IR Remote",
      "extensionDescription": "Receives infrared signals from a remote control.\n",
      "BLOCK_1713216604395": "üöÄ Initialize pin [pin] ",
      "BLOCK_1713216604631": "üìñ Data received",
      "BLOCK_1713216604820": "‚úçÔ∏è Resume receiving data",
      "BLOCK_1713216605004": "command",
      "BLOCK_1713216605193": "protocol",
      "BLOCK_1713216605384": "raw data",
      "cate_fa32e659": "üí´ IR"
    }
  };
  const codeSnippets = {
    arduinoc: {}
  };
  const extGenerators = [{
    lang: 'arduinoc',
    template: `// generated by mBlock5 for <your product>
// codes make you happy

//( include //)
#include <Arduino.h>
//( lib //)

//({
    this.$ALL_VARIABLES.length==0?'':this.$ALL_VARIABLES.map(v=>"float "+v+" = 0;").join('\\n')
}//)

//( declare //)


void _delay(float seconds) {
  long endTime = millis() + seconds * 1000;
  while(millis() < endTime) _loop();
}

//(
void setup() {
  //( setup //)
  //( code //)
}
//)

void _loop() {
  //( _loop //)
}

void loop() {
  _loop();
}`,
    splitor: {
      frame: {
        left: "//(",
        right: "//)"
      },
      expression: {
        left: "/*{",
        right: "}*/"
      }
    },
    reducers: [{
      name: 'include',
      reduce: codes => {
        let codes1 = [];

        for (let code of codes) {
          let codeStr = '';

          if (typeof code === 'string') {
            codeStr = code;
          } else if (typeof code === 'function') {
            codeStr = code();
          }

          if (codes1.indexOf(codeStr) === -1) {
            codes1.push(codeStr);
          }
        }

        if (codes1.length === 0) {
          return undefined;
        }

        return codes1.map(code => {
          return '#include ' + code;
        }).join('\n') + '\n';
      }
    }]
  }];
  const extSources = {
    arduino: [{
      filename: "src/ir_Kaseikyo.hpp",
      code: "/*\n * ir_Kaseikyo.hpp\n *\n *  Contains functions for receiving and sending Kaseikyo/Panasonic IR Protocol in \"raw\" and standard format with 16 bit address + 8 bit command\n *\n *  This file is part of Arduino-IRremote https://github.com/Arduino-IRremote/Arduino-IRremote.\n *\n ************************************************************************************\n * MIT License\n *\n * Copyright (c) 2020-2023 Armin Joachimsmeyer\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is furnished\n * to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n ************************************************************************************\n */\n#ifndef _IR_KASEIKYO_HPP\n#define _IR_KASEIKYO_HPP\n\n#if defined(DEBUG) && !defined(LOCAL_DEBUG)\n#define LOCAL_DEBUG\n#else\n//#define LOCAL_DEBUG // This enables debug output only for this file\n#endif\n\n/** \\addtogroup Decoder Decoders and encoders for different protocols\n * @{\n */\n//==============================================================================\n//       K  K   AA    SSS   EEEE  III  K  K  Y   Y   OOO\n//       K K   A  A  S      E      I   K K    Y Y   O   O\n//       KK    AAAA   SSS   EEE    I   KK      Y    O   O\n//       K K   A  A      S  E      I   K K     Y    O   O\n//       K  K  A  A  SSSS   EEEE  III  K  K    Y     OOO\n//==============================================================================\n//==============================================================================\n//       PPPP    AAA   N   N   AAA    SSSS   OOO   N   N  IIIII   CCCC\n//       P   P  A   A  NN  N  A   A  S      O   O  NN  N    I    C\n//       PPPP   AAAAA  N N N  AAAAA   SSS   O   O  N N N    I    C\n//       P      A   A  N  NN  A   A      S  O   O  N  NN    I    C\n//       P      A   A  N   N  A   A  SSSS    OOO   N   N  IIIII   CCCC\n//==============================================================================\n/*\n Protocol=Panasonic Address=0xFF1 Command=0x76 Raw-Data=0x9976FF10 48 bits LSB first\n +3450,-1700\n + 450,- 400 + 500,-1250 + 450,- 400 + 500,- 400\n + 450,- 400 + 400,- 450 + 500,- 350 + 450,- 450\n + 450,- 400 + 450,- 400 + 500,- 400 + 450,- 400\n + 450,- 400 + 500,-1250 + 450,- 400 + 500,- 350\n + 500,- 400 + 450,- 400 + 450,- 450 + 450,- 400\n + 450,-1250 + 500,- 400 + 450,- 400 + 450,- 400\n + 450,-1300 + 450,-1250 + 450,-1300 + 400,-1300\n + 450,-1300 + 450,-1250 + 450,-1250 + 500,-1250\n + 450,- 450 + 450,-1250 + 450,-1250 + 500,- 400\n + 450,-1250 + 450,-1300 + 450,-1250 + 450,- 450\n + 450,-1250 + 450,- 400 + 450,- 400 + 500,-1250\n + 450,-1250 + 450,- 400 + 500,- 400 + 450,-1250\n + 450\n Sum: 64300\n */\n// http://www.hifi-remote.com/johnsfine/DecodeIR.html#Panasonic\n// http://www.hifi-remote.com/johnsfine/DecodeIR.html#Kaseikyo\n// LSB first\n// The first two (8-bit) bytes contains the vendor code.\n// The next 4 bit is VendorID parity.\n// The last byte is parity (XOR) of the 3 bytes before.\n// There are multiple interpretations of the next fields:\n// IRP: {37k,432}<1,-1|1,-3>(8,-4,M:8,N:8,X:4,D:4,S:8,F:8,G:8,1,-173)+ {X=M:4:0^M:4:4^N:4:0^N:4:4}\n// 1. interpretation: 4 bit Device, 8 bitSubdevice and 8 bit function.\n//    0_______ 1_______  2______  3_______ 4_______ 5_______\n//    01234567 89ABCDEF  01234567 01234567 01234567 01234567\n//    01000000 00100100  0110Dev_ Sub_Dev_ Fun____  XOR( B2, B3, B4) - Byte 0,1 and vendor parity showing Panasonic vendor code 0x2002.\n// 1. interpretation: <start bit><VendorID:16><VendorID parity:4><Device:4><Subdevice:8><Function:8><Parity:8><stop bit>\n// see: http://www.remotecentral.com/cgi-bin/mboard/rc-pronto/thread.cgi?26152\n// 2. interpretation (Flipper Zero style): <start bit><VendorID:16><VendorID parity:4><Genre1:4><Genre2:4><Command:10><ID:2><Parity:8><stop bit>\n// see: https://www.mikrocontroller.net/articles/IRMP_-_english#KASEIKYO\n// Implemented is Samsung style:  <start bit><VendorID:16><VendorID parity:4><Address:12><Command:8><Parity of VendorID parity, Address and Command:8><stop bit>\n//                  which is derived from Samsung remotes and may not be optimal for Denon kind of Kaseikyo protokol usage.\n//\n#define KASEIKYO_VENDOR_ID_BITS     16\n#define KASEIKYO_VENDOR_ID_PARITY_BITS   4\n#define KASEIKYO_ADDRESS_BITS       12\n#define KASEIKYO_COMMAND_BITS       8\n#define KASEIKYO_PARITY_BITS        8\n#define KASEIKYO_BITS               (KASEIKYO_VENDOR_ID_BITS + KASEIKYO_VENDOR_ID_PARITY_BITS + KASEIKYO_ADDRESS_BITS + KASEIKYO_COMMAND_BITS + KASEIKYO_PARITY_BITS) // 48\n#define KASEIKYO_UNIT               432 // 16 pulses of 37 kHz (432,432432)  - Pronto 0x70 | 0x10\n\n#define KASEIKYO_HEADER_MARK        (8 * KASEIKYO_UNIT) // 3456\n#define KASEIKYO_HEADER_SPACE       (4 * KASEIKYO_UNIT) // 1728\n\n#define KASEIKYO_BIT_MARK           KASEIKYO_UNIT\n#define KASEIKYO_ONE_SPACE          (3 * KASEIKYO_UNIT) // 1296\n#define KASEIKYO_ZERO_SPACE         KASEIKYO_UNIT\n\n#define KASEIKYO_AVERAGE_DURATION   56000\n#define KASEIKYO_REPEAT_PERIOD      130000\n#define KASEIKYO_REPEAT_DISTANCE    (KASEIKYO_REPEAT_PERIOD - KASEIKYO_AVERAGE_DURATION) // 74 ms\n#define KASEIKYO_MAXIMUM_REPEAT_DISTANCE    (KASEIKYO_REPEAT_DISTANCE + (KASEIKYO_REPEAT_DISTANCE / 4)) // Just a guess\n\n#define PANASONIC_VENDOR_ID_CODE    0x2002\n#define DENON_VENDOR_ID_CODE        0x3254\n#define MITSUBISHI_VENDOR_ID_CODE   0xCB23\n#define SHARP_VENDOR_ID_CODE        0x5AAA\n#define JVC_VENDOR_ID_CODE          0x0103\n\nstruct PulseDistanceWidthProtocolConstants KaseikyoProtocolConstants = { KASEIKYO, KASEIKYO_KHZ, KASEIKYO_HEADER_MARK,\nKASEIKYO_HEADER_SPACE, KASEIKYO_BIT_MARK, KASEIKYO_ONE_SPACE, KASEIKYO_BIT_MARK, KASEIKYO_ZERO_SPACE, PROTOCOL_IS_LSB_FIRST\n       , (KASEIKYO_REPEAT_PERIOD / MICROS_IN_ONE_MILLI), NULL };\n\n/************************************\n * Start of send and decode functions\n ************************************/\n\n/**\n * Address can be interpreted as sub-device << 4 + 4 bit device\n */\nvoid IRsend::sendKaseikyo(uint16_t aAddress, uint8_t aCommand, int_fast8_t aNumberOfRepeats, uint16_t aVendorCode) {\n    // Set IR carrier frequency\n    enableIROut (KASEIKYO_KHZ); // 37 kHz\n\n    // Vendor Parity\n    uint8_t tVendorParity = aVendorCode ^ (aVendorCode >> 8);\n    tVendorParity = (tVendorParity ^ (tVendorParity >> 4)) & 0xF;\n\n#if __INT_WIDTH__ < 32\n    LongUnion tSendValue;\n    // Compute parity\n    tSendValue.UWord.LowWord = (aAddress << KASEIKYO_VENDOR_ID_PARITY_BITS) | tVendorParity; // set low nibble with vendor parity\n    tSendValue.UBytes[2] = aCommand;\n    tSendValue.UBytes[3] = aCommand ^ tSendValue.UBytes[0] ^ tSendValue.UBytes[1]; // 8 bit parity of 3 bytes command, address and vendor parity\n    IRRawDataType tRawKaseikyoData[2];\n    tRawKaseikyoData[0] = (uint32_t) tSendValue.UWord.LowWord << 16 | aVendorCode; // LSB of tRawKaseikyoData[0] is sent first\n    tRawKaseikyoData[1] = tSendValue.UWord.HighWord;\n    sendPulseDistanceWidthFromArray(&KaseikyoProtocolConstants, &tRawKaseikyoData[0], KASEIKYO_BITS, aNumberOfRepeats);\n#else\n    LongLongUnion tSendValue;\n    tSendValue.UWords[0] = aVendorCode;\n    // Compute parity\n    tSendValue.UWords[1] = (aAddress << KASEIKYO_VENDOR_ID_PARITY_BITS) | tVendorParity; // set low nibble to parity\n    tSendValue.UBytes[4] = aCommand;\n    tSendValue.UBytes[5] = aCommand ^ tSendValue.UBytes[2] ^ tSendValue.UBytes[3]; // Parity\n    sendPulseDistanceWidth(&KaseikyoProtocolConstants, tSendValue.ULongLong, KASEIKYO_BITS, aNumberOfRepeats);\n#endif\n}\n\n/**\n * Stub using Kaseikyo with PANASONIC_VENDOR_ID_CODE\n */\nvoid IRsend::sendPanasonic(uint16_t aAddress, uint8_t aCommand, int_fast8_t aNumberOfRepeats) {\n    sendKaseikyo(aAddress, aCommand, aNumberOfRepeats, PANASONIC_VENDOR_ID_CODE);\n}\n\n/**\n * Stub using Kaseikyo with DENON_VENDOR_ID_CODE\n */\nvoid IRsend::sendKaseikyo_Denon(uint16_t aAddress, uint8_t aCommand, int_fast8_t aNumberOfRepeats) {\n    sendKaseikyo(aAddress, aCommand, aNumberOfRepeats, DENON_VENDOR_ID_CODE);\n}\n\n/**\n * Stub using Kaseikyo with MITSUBISHI_VENDOR_ID_CODE\n */\nvoid IRsend::sendKaseikyo_Mitsubishi(uint16_t aAddress, uint8_t aCommand, int_fast8_t aNumberOfRepeats) {\n    sendKaseikyo(aAddress, aCommand, aNumberOfRepeats, MITSUBISHI_VENDOR_ID_CODE);\n}\n\n/**\n * Stub using Kaseikyo with SHARP_VENDOR_ID_CODE\n */\nvoid IRsend::sendKaseikyo_Sharp(uint16_t aAddress, uint8_t aCommand, int_fast8_t aNumberOfRepeats) {\n    sendKaseikyo(aAddress, aCommand, aNumberOfRepeats, SHARP_VENDOR_ID_CODE);\n}\n\n/**\n * Stub using Kaseikyo with JVC_VENDOR_ID_CODE\n */\nvoid IRsend::sendKaseikyo_JVC(uint16_t aAddress, uint8_t aCommand, int_fast8_t aNumberOfRepeats) {\n    sendKaseikyo(aAddress, aCommand, aNumberOfRepeats, JVC_VENDOR_ID_CODE);\n}\n\n/*\n * Tested with my Panasonic DVD/TV remote\n */\nbool IRrecv::decodeKaseikyo() {\n\n    decode_type_t tProtocol;\n    // Check we have enough data (96 + 4) 4 for initial gap, start bit mark and space + stop bit mark\n    if (decodedIRData.rawlen != ((2 * KASEIKYO_BITS) + 4)) {\n        IR_DEBUG_PRINT(F(\"Kaseikyo: \"));\n        IR_DEBUG_PRINT(F(\"Data length=\"));\n        IR_DEBUG_PRINT(decodedIRData.rawlen);\n        IR_DEBUG_PRINTLN(F(\" is not 100\"));\n        return false;\n    }\n\n    if (!checkHeader(&KaseikyoProtocolConstants)) {\n        return false;\n    }\n\n    // decode first 16 Vendor ID bits\n    if (!decodePulseDistanceWidthData(&KaseikyoProtocolConstants, KASEIKYO_VENDOR_ID_BITS)) {\n#if defined(LOCAL_DEBUG)\n        Serial.print(F(\"Kaseikyo: \"));\n        Serial.println(F(\"Vendor ID decode failed\"));\n#endif\n        return false;\n    }\n\n    uint16_t tVendorId = decodedIRData.decodedRawData;\n    if (tVendorId == PANASONIC_VENDOR_ID_CODE) {\n        tProtocol = PANASONIC;\n    } else if (tVendorId == SHARP_VENDOR_ID_CODE) {\n        tProtocol = KASEIKYO_SHARP;\n    } else if (tVendorId == DENON_VENDOR_ID_CODE) {\n        tProtocol = KASEIKYO_DENON;\n    } else if (tVendorId == JVC_VENDOR_ID_CODE) {\n        tProtocol = KASEIKYO_JVC;\n    } else if (tVendorId == MITSUBISHI_VENDOR_ID_CODE) {\n        tProtocol = KASEIKYO_MITSUBISHI;\n    } else {\n        tProtocol = KASEIKYO;\n    }\n\n    // Vendor Parity\n    uint8_t tVendorParity = tVendorId ^ (tVendorId >> 8);\n    tVendorParity = (tVendorParity ^ (tVendorParity >> 4)) & 0xF;\n\n    /*\n     * Decode next 32 bits, 8 VendorID parity parity + 12 address (device and subdevice) + 8 command + 8 parity\n     */\n    if (!decodePulseDistanceWidthData(&KaseikyoProtocolConstants,\n    KASEIKYO_VENDOR_ID_PARITY_BITS + KASEIKYO_ADDRESS_BITS + KASEIKYO_COMMAND_BITS + KASEIKYO_PARITY_BITS,\n            3 + (2 * KASEIKYO_VENDOR_ID_BITS))) {\n#if defined(LOCAL_DEBUG)\n        Serial.print(F(\"Kaseikyo: \"));\n        Serial.println(F(\"VendorID parity, address, command + parity decode failed\"));\n#endif\n        return false;\n    }\n\n    // Success\n//    decodedIRData.flags = IRDATA_FLAGS_IS_LSB_FIRST; // Not required, since this is the start value\n    LongUnion tValue;\n    tValue.ULong = decodedIRData.decodedRawData;\n#if __INT_WIDTH__ >= 32\n    // workaround until complete refactoring for 64 bit\n    decodedIRData.decodedRawData = (decodedIRData.decodedRawData << 16) | tVendorId; // store all 48 bits in decodedRawData\n#endif\n    decodedIRData.address = (tValue.UWord.LowWord >> KASEIKYO_VENDOR_ID_PARITY_BITS); // remove 4 bit vendor parity\n    decodedIRData.command = tValue.UByte.MidHighByte;\n    uint8_t tParity = tValue.UByte.LowByte ^ tValue.UByte.MidLowByte ^ tValue.UByte.MidHighByte;\n\n    if (tVendorParity != (tValue.UByte.LowByte & 0xF)) {\n        decodedIRData.flags = IRDATA_FLAGS_PARITY_FAILED | IRDATA_FLAGS_IS_LSB_FIRST;\n\n#if defined(LOCAL_DEBUG)\n        Serial.print(F(\"Kaseikyo: \"));\n        Serial.print(F(\"4 bit VendorID parity is not correct. Expected=0x\"));\n        Serial.print(tVendorParity, HEX);\n        Serial.print(F(\" received=0x\"));\n        Serial.print(decodedIRData.decodedRawData, HEX);\n        Serial.print(F(\" VendorID=0x\"));\n        Serial.println(tVendorId, HEX);\n#endif\n    }\n\n    if (tProtocol == KASEIKYO) {\n        decodedIRData.flags |= IRDATA_FLAGS_EXTRA_INFO;\n        decodedIRData.extra = tVendorId; // Store (unknown) vendor ID\n    }\n\n    if (tValue.UByte.HighByte != tParity) {\n        decodedIRData.flags |= IRDATA_FLAGS_PARITY_FAILED;\n\n#if defined(LOCAL_DEBUG)\n        Serial.print(F(\"Kaseikyo: \"));\n        Serial.print(F(\"8 bit parity is not correct. Expected=0x\"));\n        Serial.print(tParity, HEX);\n        Serial.print(F(\" received=0x\"));\n        Serial.print(decodedIRData.decodedRawData >> KASEIKYO_COMMAND_BITS, HEX);\n        Serial.print(F(\" address=0x\"));\n        Serial.print(decodedIRData.address, HEX);\n        Serial.print(F(\" command=0x\"));\n        Serial.println(decodedIRData.command, HEX);\n#endif\n    }\n\n    decodedIRData.numberOfBits = KASEIKYO_BITS;\n    decodedIRData.protocol = tProtocol;\n\n    // check for repeat\n    checkForRepeatSpaceTicksAndSetFlag(KASEIKYO_MAXIMUM_REPEAT_DISTANCE / MICROS_PER_TICK);\n\n    return true;\n}\n\n/*\n * Removed void IRsend::sendPanasonic(uint16_t aAddress, uint32_t aData)\n * and bool IRrecv::decodePanasonicMSB(decode_results *aResults)\n * since their implementations were wrong (wrong length), and nobody recognized it\n */\n\n/** @}*/\n#if defined(LOCAL_DEBUG)\n#undef LOCAL_DEBUG\n#endif\n#endif // _IR_KASEIKYO_HPP\n"
    }, {
      filename: "src/TinyIR.h",
      code: "/*\n *  TinyIR.h\n *\n *\n *  Copyright (C) 2021-2023  Armin Joachimsmeyer\n *  armin.joachimsmeyer@gmail.com\n *\n *  This file is part of IRMP https://github.com/IRMP-org/IRMP.\n *  This file is part of Arduino-IRremote https://github.com/Arduino-IRremote/Arduino-IRremote.\n *\n *  TinyIRReceiver is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n *  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program. If not, see <http://www.gnu.org/licenses/gpl.html>.\n *\n */\n\n#ifndef _TINY_IR_H\n#define _TINY_IR_H\n\n#include <Arduino.h>\n\n#include \"LongUnion.h\"\n\n/** \\addtogroup TinyReceiver Minimal receiver for NEC and FAST protocol\n * @{\n */\n\n#define VERSION_TINYIR \"2.1.0\"\n#define VERSION_TINYIR_MAJOR 2\n#define VERSION_TINYIR_MINOR 1\n#define VERSION_TINYIR_PATCH 0\n// The change log is at the bottom of the file\n\n/**\n * Timing for NEC protocol\n *\n * see: https://www.sbprojects.net/knowledge/ir/nec.php\n * LSB first, 1 start bit + 16 bit address + 8 bit data + 8 bit inverted data + 1 stop bit.\n */\n#if !defined(NEC_ADDRESS_BITS)\n#define NEC_ADDRESS_BITS        16 // 16 bit address or 8 bit address and 8 bit inverted address\n#define NEC_COMMAND_BITS        16 // Command and inverted command\n#define NEC_BITS                (NEC_ADDRESS_BITS + NEC_COMMAND_BITS)\n\n#define NEC_UNIT                560\n\n#define NEC_HEADER_MARK         (16 * NEC_UNIT) // 9000\n#define NEC_HEADER_SPACE        (8 * NEC_UNIT)  // 4500\n\n#define NEC_BIT_MARK            NEC_UNIT\n#define NEC_ONE_SPACE           (3 * NEC_UNIT)  // 1690\n#define NEC_ZERO_SPACE          NEC_UNIT\n\n#define NEC_REPEAT_HEADER_SPACE (4 * NEC_UNIT)  // 2250\n\n#define NEC_REPEAT_PERIOD       110000 // Commands are repeated every 110 ms (measured from start to start) for as long as the key on the remote control is held down.\n#define NEC_MINIMAL_DURATION     49900 // NEC_HEADER_MARK + NEC_HEADER_SPACE + 32 * 2 * NEC_UNIT + NEC_UNIT // 2.5 because we assume more zeros than ones\n#define NEC_MAXIMUM_REPEAT_DISTANCE (NEC_REPEAT_PERIOD - NEC_MINIMAL_DURATION + 10000) // 70 ms\n#endif\n\n/**\n * The FAST protocol is a proprietary modified JVC protocol without address, with parity and with a shorter header.\n * FAST protocol characteristics:\n * - Bit timing is like NEC or JVC\n * - The header is shorter, 3156 vs. 12500\n * - No address and 16 bit data, interpreted as 8 bit command and 8 bit inverted command,\n *     leading to a fixed protocol length of (6 + (16 * 3) + 1) * 526 = 55 * 526 = 28930 microseconds or 29 ms.\n * - Repeats are sent as complete frames but in a 50 ms period / with a 21 ms distance.\n */\n/*\n Protocol=FAST Address=0x0 Command=0x76 Raw-Data=0x8976 16 bits LSB first\n +2100,-1050\n + 550,- 500 + 550,-1550 + 550,-1550 + 550,- 500\n + 550,-1550 + 550,-1550 + 550,-1550 + 550,- 500\n + 550,-1550 + 550,- 500 + 550,- 500 + 550,-1550\n + 550,- 500 + 550,- 500 + 550,- 500 + 550,-1550\n + 550\n Sum: 28900\n */\n#define FAST_KHZ                  38\n#define FAST_ADDRESS_BITS          0 // No address\n#define FAST_COMMAND_BITS         16 // Command and inverted command (parity)\n#define FAST_BITS                 (FAST_ADDRESS_BITS + FAST_COMMAND_BITS)\n\n#define FAST_UNIT                 526 // 20 periods of 38 kHz (526.315789)\n\n#define FAST_BIT_MARK             FAST_UNIT\n#define FAST_ONE_SPACE            (3 * FAST_UNIT)     // 1578 -> bit period = 2104\n#define FAST_ZERO_SPACE           FAST_UNIT           //  526 -> bit period = 1052\n\n#define FAST_HEADER_MARK          (4 * FAST_UNIT)     // 2104\n#define FAST_HEADER_SPACE         (2 * FAST_UNIT)     // 1052\n\n#define FAST_REPEAT_PERIOD        50000 // Commands are repeated every 50 ms (measured from start to start) for as long as the key on the remote control is held down.\n#define FAST_REPEAT_DISTANCE      (FAST_REPEAT_PERIOD - (55 * FAST_UNIT)) // 19 ms\n#define FAST_MAXIMUM_REPEAT_DISTANCE (FAST_REPEAT_DISTANCE + 10000) // 29 ms\n\n/*\n * Definitions to switch between FAST and NEC/ONKYO timing with the same code.\n */\n#if defined(USE_FAST_PROTOCOL)\n#define ENABLE_NEC2_REPEATS    // Disables detection of special short frame NEC repeats. Saves 40 bytes program memory.\n\n#define TINY_RECEIVER_ADDRESS_BITS          FAST_ADDRESS_BITS\n#define TINY_RECEIVER_COMMAND_BITS          FAST_COMMAND_BITS\n#if !defined(TINY_RECEIVER_COMMAND_HAS_8_BIT_PARITY)\n#define TINY_RECEIVER_COMMAND_HAS_8_BIT_PARITY  true     // 8 bit and 8 bit parity\n//#define TINY_RECEIVER_COMMAND_HAS_8_BIT_PARITY  false    //  16 bit command without parity - not tested\n#endif\n\n#define TINY_RECEIVER_BITS                  FAST_BITS\n#define TINY_RECEIVER_UNIT                  FAST_UNIT\n\n#define TINY_RECEIVER_HEADER_MARK           FAST_HEADER_MARK\n#define TINY_RECEIVER_HEADER_SPACE          FAST_HEADER_SPACE\n\n#define TINY_RECEIVER_BIT_MARK              FAST_BIT_MARK\n#define TINY_RECEIVER_ONE_SPACE             FAST_ONE_SPACE\n#define TINY_RECEIVER_ZERO_SPACE            FAST_ZERO_SPACE\n\n#define TINY_RECEIVER_MAXIMUM_REPEAT_DISTANCE  FAST_MAXIMUM_REPEAT_DISTANCE // for repeat detection\n\n#else\n\n#define TINY_RECEIVER_ADDRESS_BITS          NEC_ADDRESS_BITS // the address bits + parity\n#  if defined(USE_ONKYO_PROTOCOL)\n#define TINY_RECEIVER_ADDRESS_HAS_8_BIT_PARITY  false     // 16 bit address without parity\n#  elif defined(USE_EXTENDED_NEC_PROTOCOL)\n#define TINY_RECEIVER_ADDRESS_HAS_8_BIT_PARITY  false     // 16 bit address without parity\n#  else\n#define TINY_RECEIVER_ADDRESS_HAS_8_BIT_PARITY  true     // 8 bit and 8 bit parity\n#  endif\n\n#define TINY_RECEIVER_COMMAND_BITS          NEC_COMMAND_BITS // the command bits + parity\n#  if defined(USE_ONKYO_PROTOCOL)\n#define TINY_RECEIVER_COMMAND_HAS_8_BIT_PARITY  false    // 16 bit command without parity\n#  else\n#define TINY_RECEIVER_COMMAND_HAS_8_BIT_PARITY  true     // 8 bit and 8 bit parity\n#  endif\n\n#define TINY_RECEIVER_BITS                  NEC_BITS\n#define TINY_RECEIVER_UNIT                  NEC_UNIT\n\n#define TINY_RECEIVER_HEADER_MARK           NEC_HEADER_MARK\n#define TINY_RECEIVER_HEADER_SPACE          NEC_HEADER_SPACE\n\n#define TINY_RECEIVER_BIT_MARK              NEC_BIT_MARK\n#define TINY_RECEIVER_ONE_SPACE             NEC_ONE_SPACE\n#define TINY_RECEIVER_ZERO_SPACE            NEC_ZERO_SPACE\n\n#define TINY_RECEIVER_MAXIMUM_REPEAT_DISTANCE  NEC_MAXIMUM_REPEAT_DISTANCE\n#endif\n\n#if defined(USE_CALLBACK_FOR_TINY_RECEIVER)\n/*\n * This function is called, if a complete command was received and must be implemented in the file (user code)\n * which includes this library if USE_CALLBACK_FOR_TINY_RECEIVER is activated.\n */\nextern void handleReceivedTinyIRData();\n#endif\n\n#if !defined(MICROS_IN_ONE_SECOND)\n#define MICROS_IN_ONE_SECOND 1000000L\n#endif\n\n#if !defined(MICROS_IN_ONE_MILLI)\n#define MICROS_IN_ONE_MILLI 1000L\n#endif\n\n/*\n * Macros for comparing timing values\n */\n#define lowerValue25Percent(aDuration)   (aDuration - (aDuration / 4))\n#define upperValue25Percent(aDuration)   (aDuration + (aDuration / 4))\n#define lowerValue50Percent(aDuration)   (aDuration / 2) // (aDuration - (aDuration / 2))\n#define upperValue50Percent(aDuration)   (aDuration + (aDuration / 2))\n\n/*\n * The states for the state machine\n */\n#define IR_RECEIVER_STATE_WAITING_FOR_START_MARK        0\n#define IR_RECEIVER_STATE_WAITING_FOR_START_SPACE       1\n#define IR_RECEIVER_STATE_WAITING_FOR_FIRST_DATA_MARK   2\n#define IR_RECEIVER_STATE_WAITING_FOR_DATA_SPACE        3\n#define IR_RECEIVER_STATE_WAITING_FOR_DATA_MARK         4\n#define IR_RECEIVER_STATE_WAITING_FOR_STOP_MARK         5\n/**\n * Control and data variables of the state machine for TinyReceiver\n */\nstruct TinyIRReceiverStruct {\n    /*\n     * State machine\n     */\n    uint32_t LastChangeMicros;      ///< Microseconds of last Pin Change Interrupt.\n    uint8_t IRReceiverState;        ///< The state of the state machine.\n    uint8_t IRRawDataBitCounter;    ///< How many bits are currently contained in raw data.\n    /*\n     * Data\n     */\n#if (TINY_RECEIVER_BITS > 16)\n    uint32_t IRRawDataMask;         ///< The corresponding bit mask for IRRawDataBitCounter.\n    LongUnion IRRawData;            ///< The current raw data. LongUnion helps with decoding of address and command.\n#else\n    uint16_t IRRawDataMask;         ///< The corresponding bit mask for IRRawDataBitCounter.\n    WordUnion IRRawData;            ///< The current raw data. WordUnion helps with decoding of command.\n#endif\n    uint8_t Flags;  ///< One of IRDATA_FLAGS_EMPTY, IRDATA_FLAGS_IS_REPEAT, and IRDATA_FLAGS_PARITY_FAILED\n};\n\n/*\n * Definitions for member TinyIRReceiverCallbackDataStruct.Flags\n * From IRremoteInt.h\n */\n#define IRDATA_FLAGS_EMPTY              0x00\n#define IRDATA_FLAGS_IS_REPEAT          0x01\n#define IRDATA_FLAGS_IS_AUTO_REPEAT     0x02 // not used here, overwritten with _IRDATA_FLAGS_IS_SHORT_REPEAT\n#define IRDATA_FLAGS_PARITY_FAILED      0x04 ///< the current (autorepeat) frame violated parity check\n\n/**\n * Is filled before calling the user callback to transfer received data to main loop for further processing.\n */\nstruct TinyIRReceiverCallbackDataStruct {\n#if (TINY_RECEIVER_ADDRESS_BITS > 0)\n#  if (TINY_RECEIVER_ADDRESS_BITS == 16) && !TINY_RECEIVER_ADDRESS_HAS_8_BIT_PARITY\n    uint16_t Address;\n#  else\n    uint8_t Address;\n#  endif\n#endif\n\n#  if (TINY_RECEIVER_COMMAND_BITS == 16) && !TINY_RECEIVER_COMMAND_HAS_8_BIT_PARITY\n    uint16_t Command;\n#else\n    uint8_t Command;\n#endif\n    uint8_t Flags; // Bit coded flags. Can contain one of the bits: IRDATA_FLAGS_IS_REPEAT and IRDATA_FLAGS_PARITY_FAILED\n    bool justWritten; ///< Is set true if new data is available. Used by the main loop, to avoid multiple evaluations of the same IR frame.\n};\nextern volatile TinyIRReceiverCallbackDataStruct TinyIRReceiverData;\n\nbool isIRReceiverAttachedForTinyReceiver();\nbool initPCIInterruptForTinyReceiver();\nbool enablePCIInterruptForTinyReceiver();\nvoid disablePCIInterruptForTinyReceiver();\nbool isTinyReceiverIdle();\nvoid printTinyReceiverResultMinimal(Print *aSerial);\n\nvoid sendFAST(uint8_t aSendPin, uint16_t aCommand, uint_fast8_t aNumberOfRepeats = 0);\nvoid sendFast8BitAndParity(uint8_t aSendPin, uint8_t aCommand, uint_fast8_t aNumberOfRepeats = 0);\nvoid sendONKYO(uint8_t aSendPin, uint16_t aAddress, uint16_t aCommand, uint_fast8_t aNumberOfRepeats = 0, bool aSendNEC2Repeats = false); // Send NEC with 16 bit command, even if aCommand < 0x100\nvoid sendNECMinimal(uint8_t aSendPin, uint16_t aAddress, uint16_t aCommand, uint_fast8_t aNumberOfRepeats = 0)\n        __attribute__ ((deprecated (\"Renamed to sendNEC().\")));\nvoid sendNEC(uint8_t aSendPin, uint16_t aAddress, uint16_t aCommand, uint_fast8_t aNumberOfRepeats = 0, bool aSendNEC2Repeats = false);\nvoid sendExtendedNEC(uint8_t aSendPin, uint16_t aAddress, uint16_t aCommand, uint_fast8_t aNumberOfRepeats = 0, bool aSendNEC2Repeats = false);\n\n/*\n *  Version 2.1.0 - 2/2024\n *  - New sendExtendedNEC() function and new parameter aSendNEC2Repeats.\n *\n *  Version 2.0.0 - 10/2023\n *  - New TinyIRReceiverData which is filled with address, command and flags.\n *  - Removed parameters address, command and flags from callback handleReceivedTinyIRData() and printTinyReceiverResultMinimal().\n *  - Callback function now only enabled if USE_CALLBACK_FOR_TINY_RECEIVER is activated.\n *\n *  Version 1.2.0 - 01/2023\n * - Added ONKYO protocol, NEC with 16 bit address and command, instead of 8 bit + 8 bit parity address and command.\n * - Renamed functions and macros.\n *\n * Version 1.1.0 - 01/2023\n * - FAST protocol added.\n */\n/** @}*/\n\n#endif // _TINY_IR_H\n"
    }, {
      filename: "src/IRProtocol.hpp",
      code: "/*\n * IRReceive.hpp\n * This file is exclusively included by IRremote.h to enable easy configuration of library switches\n *\n *  Contains all protocol functions used by receiver and sender.\n *\n *  This file is part of Arduino-IRremote https://github.com/Arduino-IRremote/Arduino-IRremote.\n *\n ************************************************************************************\n * MIT License\n *\n * Copyright (c) 2009-2023 Ken Shirriff, Rafi Khan, Armin Joachimsmeyer\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is furnished\n * to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n ************************************************************************************\n */\n#ifndef _IR_PROTOCOL_HPP\n#define _IR_PROTOCOL_HPP\n\n#if defined(DEBUG) && !defined(LOCAL_DEBUG)\n#define LOCAL_DEBUG\n#else\n//#define LOCAL_DEBUG // This enables debug output only for this file\n#endif\n\n/** \\addtogroup Receiving Receiving IR data for multiple protocols\n * @{\n */\n\nconst char string_Unknown[] PROGMEM = \"UNKNOWN\";\nconst char string_PulseWidth[] PROGMEM = \"PulseWidth\";\nconst char string_PulseDistance[] PROGMEM = \"PulseDistance\";\nconst char string_Apple[] PROGMEM = \"Apple\";\nconst char string_Denon[] PROGMEM = \"Denon\";\nconst char string_JVC[] PROGMEM = \"JVC\";\nconst char string_LG[] PROGMEM = \"LG\";\nconst char string_LG2[] PROGMEM = \"LG2\";\nconst char string_NEC[] PROGMEM = \"NEC\";\nconst char string_NEC2[] PROGMEM = \"NEC2\";\nconst char string_Onkyo[] PROGMEM = \"Onkyo\";\nconst char string_Panasonic[] PROGMEM = \"Panasonic\";\nconst char string_Kaseikyo[] PROGMEM = \"Kaseikyo\";\nconst char string_Kaseikyo_Denon[] PROGMEM = \"Kaseikyo_Denon\";\nconst char string_Kaseikyo_Sharp[] PROGMEM = \"Kaseikyo_Sharp\";\nconst char string_Kaseikyo_JVC[] PROGMEM = \"Kaseikyo_JVC\";\nconst char string_Kaseikyo_Mitsubishi[] PROGMEM = \"Kaseikyo_Mitsubishi\";\nconst char string_RC5[] PROGMEM = \"RC5\";\nconst char string_RC6[] PROGMEM = \"RC6\";\nconst char string_Samsung[] PROGMEM = \"Samsung\";\nconst char string_SamsungLG[] PROGMEM = \"SamsungLG\";\nconst char string_Samsung48[] PROGMEM = \"Samsung48\";\nconst char string_Sharp[] PROGMEM = \"Sharp\";\nconst char string_Sony[] PROGMEM = \"Sony\";\nconst char string_BangOlufsen[] PROGMEM = \"Bang&Olufsen\";\nconst char string_BoseWave[] PROGMEM = \"BoseWave\";\nconst char string_Lego[] PROGMEM = \"Lego\";\nconst char string_MagiQuest[] PROGMEM = \"MagiQuest\";\nconst char string_Whynter[] PROGMEM = \"Whynter\";\nconst char string_FAST[] PROGMEM = \"FAST\";\n\n/*\n * !!Must be the same order as in decode_type_t in IRProtocol.h!!!\n */\nconst char *const ProtocolNames[]\nPROGMEM = { string_Unknown, string_PulseWidth, string_PulseDistance, string_Apple, string_Denon, string_JVC, string_LG, string_LG2,\n        string_NEC, string_NEC2, string_Onkyo, string_Panasonic, string_Kaseikyo, string_Kaseikyo_Denon, string_Kaseikyo_Sharp,\n        string_Kaseikyo_JVC, string_Kaseikyo_Mitsubishi, string_RC5, string_RC6, string_Samsung, string_SamsungLG, string_Samsung48,\n        string_Sharp, string_Sony\n#if !defined(EXCLUDE_EXOTIC_PROTOCOLS)\n        , string_BangOlufsen, string_BoseWave, string_Lego, string_MagiQuest, string_Whynter, string_FAST\n#endif\n        };\n\n#if defined(__AVR__)\nconst __FlashStringHelper* getProtocolString(decode_type_t aProtocol) {\n    const char *tProtocolStringPtr = (char*) pgm_read_word(&ProtocolNames[aProtocol]);\n    return ((__FlashStringHelper*) (tProtocolStringPtr));\n}\n#else\nconst char* getProtocolString(decode_type_t aProtocol) {\n    return ProtocolNames[aProtocol];\n}\n#endif\n\n#if (__INT_WIDTH__ >= 32)\n#  if __has_include(<type_traits>)\n/*\n * This code to handle the missing print(unsigned long long...) function of seeduino core was contributed by sklott\n * https://stackoverflow.com/questions/74622227/avoid-calling-of-function-size-t-printprintunsigned-long-long-n-int-base-if\n */\n#include <type_traits>\n\n// If you have C++17 you can just use std::void_t, or use this for all versions\n#if __cpp_lib_void_t >= 201411L\ntemplate<typename T>\nusing void_t = std::void_t<T>;\n#else\ntemplate<typename ... Ts> struct make_void {\n    typedef void type;\n};\ntemplate<typename ... Ts> using void_t = typename make_void<Ts...>::type;\n#endif\n\n// Detecting if we have print(unsigned long long value, int base) / print(0ull, 0) overload\ntemplate<typename T, typename = void>\nstruct has_ull_print: std::false_type {\n};\ntemplate<typename T>\nstruct has_ull_print<T, void_t<decltype(std::declval<T>().print(0ull, 0))>> : std::true_type {\n};\n\n// Must be namespace, to avoid public and static declarations for class\nnamespace PrintULL {\ntemplate<typename PrintImplType, typename std::enable_if<!has_ull_print<PrintImplType>::value, bool>::type = true>\nsize_t print(PrintImplType *p, unsigned long long value, int base) {\n    size_t tLength = p->print(static_cast<uint32_t>(value >> 32), base);\n    tLength += p->print(static_cast<uint32_t>(value), base);\n    return tLength;\n}\n\ntemplate<typename PrintImplType, typename std::enable_if<has_ull_print<PrintImplType>::value, bool>::type = true>\nsize_t print(PrintImplType *p, unsigned long long value, int base) {\n    return p->print(value, base);\n}\n}\n;\n#  else\nnamespace PrintULL {\n    size_t print(Print *aSerial, unsigned long long n, int base) {\n        return aSerial->print(n, base);\n    }\n};\n#  endif\n#endif\n\n/**\n * Function to print decoded result and flags in one line.\n * A static function to be able to print data to send or copied received data.\n * Ends with println().\n *\n * @param aSerial The Print object on which to write, for Arduino you can use &Serial.\n * @param aIRDataPtr        Pointer to the data to be printed.\n * @param aPrintRepeatGap   If true also print the gap before repeats.\n *\n */\nvoid printIRResultShort(Print *aSerial, IRData *aIRDataPtr, bool aPrintRepeatGap) {\n    if (aIRDataPtr->flags & IRDATA_FLAGS_WAS_OVERFLOW) {\n        aSerial->println(F(\"Overflow\"));\n        return;\n    }\n    aSerial->print(F(\"Protocol=\"));\n    aSerial->print(getProtocolString(aIRDataPtr->protocol));\n    if (aIRDataPtr->protocol == UNKNOWN) {\n#if defined(DECODE_HASH)\n        aSerial->print(F(\" Hash=0x\"));\n#if (__INT_WIDTH__ < 32)\n        aSerial->print(aIRDataPtr->decodedRawData, HEX);\n#else\n        PrintULL::print(aSerial,aIRDataPtr->decodedRawData, HEX);\n#endif\n\n#endif\n#if !defined(DISABLE_CODE_FOR_RECEIVER)\n        aSerial->print(' ');\n        aSerial->print((aIRDataPtr->rawlen + 1) / 2, DEC);\n        aSerial->println(F(\" bits (incl. gap and start) received\"));\n#endif\n    } else {\n#if defined(DECODE_DISTANCE_WIDTH)\n        if (aIRDataPtr->protocol != PULSE_DISTANCE && aIRDataPtr->protocol != PULSE_WIDTH) {\n#endif\n        /*\n         * New decoders have address and command\n         */\n        aSerial->print(F(\" Address=0x\"));\n        aSerial->print(aIRDataPtr->address, HEX);\n\n        aSerial->print(F(\" Command=0x\"));\n        aSerial->print(aIRDataPtr->command, HEX);\n\n        if (aIRDataPtr->flags & IRDATA_FLAGS_EXTRA_INFO) {\n            aSerial->print(F(\" Extra=0x\"));\n            aSerial->print(aIRDataPtr->extra, HEX);\n        }\n\n        if (aIRDataPtr->flags & IRDATA_FLAGS_PARITY_FAILED) {\n            aSerial->print(F(\" Parity fail\"));\n        }\n\n        if (aIRDataPtr->flags & IRDATA_FLAGS_TOGGLE_BIT) {\n            aSerial->print(F(\" Toggle=1\"));\n        }\n#if defined(DECODE_DISTANCE_WIDTH)\n        }\n#endif\n        if (aIRDataPtr->flags & (IRDATA_FLAGS_IS_AUTO_REPEAT | IRDATA_FLAGS_IS_REPEAT)) {\n            aSerial->print(' ');\n            if (aIRDataPtr->flags & IRDATA_FLAGS_IS_AUTO_REPEAT) {\n                aSerial->print(F(\"Auto-\"));\n            }\n            aSerial->print(F(\"Repeat\"));\n#if !defined(DISABLE_CODE_FOR_RECEIVER)\n            if (aPrintRepeatGap) {\n                aSerial->print(F(\" gap=\"));\n                aSerial->print((uint32_t) aIRDataPtr->initialGap * MICROS_PER_TICK);\n                aSerial->print(F(\"us\"));\n            }\n#else\n            (void)aPrintRepeatGap;\n#endif\n        }\n\n        /*\n         * Print raw data\n         */\n        if (!(aIRDataPtr->flags & IRDATA_FLAGS_IS_REPEAT) || aIRDataPtr->decodedRawData != 0) {\n            aSerial->print(F(\" Raw-Data=0x\"));\n#if (__INT_WIDTH__ < 32)\n            aSerial->print(aIRDataPtr->decodedRawData, HEX);\n#else\n            PrintULL::print(aSerial, aIRDataPtr->decodedRawData, HEX);\n#endif\n            /*\n             * Print number of bits processed\n             */\n            aSerial->print(' ');\n            aSerial->print(aIRDataPtr->numberOfBits, DEC);\n            aSerial->print(F(\" bits\"));\n\n            if (aIRDataPtr->flags & IRDATA_FLAGS_IS_MSB_FIRST) {\n                aSerial->println(F(\" MSB first\"));\n            } else {\n                aSerial->println(F(\" LSB first\"));\n            }\n\n        } else {\n            aSerial->println();\n        }\n    }\n}\n\n/**********************************************************************************************************************\n * Function to bit reverse OLD MSB values of e.g. NEC.\n **********************************************************************************************************************/\nuint8_t bitreverseOneByte(uint8_t aValue) {\n//    uint8_t tReversedValue;\n//    return __builtin_avr_insert_bits(0x01234567, aValue, tReversedValue);\n// 76543210\n    aValue = (aValue >> 4) | (aValue << 4); // Swap in groups of 4\n// 32107654\n    aValue = ((aValue & 0xcc) >> 2) | ((aValue & 0x33) << 2); // Swap in groups of 2\n// 10325476\n    aValue = ((aValue & 0xaa) >> 1) | ((aValue & 0x55) << 1); // Swap bit pairs\n// 01234567\n    return aValue;\n}\n\nuint32_t bitreverse32Bit(uint32_t aInput) {\n//    __builtin_avr_insert_bits();\n    LongUnion tValue;\n    tValue.UByte.HighByte = bitreverseOneByte(aInput);\n    tValue.UByte.MidHighByte = bitreverseOneByte(aInput >> 8);\n    tValue.UByte.MidLowByte = bitreverseOneByte(aInput >> 16);\n    tValue.UByte.LowByte = bitreverseOneByte(aInput >> 24);\n    return tValue.ULong;\n}\n\n/** @}*/\n\n#if defined(LOCAL_DEBUG)\n#undef LOCAL_DEBUG\n#endif\n#endif // _IR_PROTOCOL_HPP\n"
    }, {
      filename: "src/digitalWriteFast.h",
      code: "/*\n * digitalWriteFast.h\n *\n * Optimized digital functions for AVR microcontrollers\n * by Watterott electronic (www.watterott.com)\n * based on https://code.google.com/p/digitalwritefast\n *\n * License: BSD 3-Clause License (https://opensource.org/licenses/BSD-3-Clause)\n */\n\n#ifndef __digitalWriteFast_h_\n#define __digitalWriteFast_h_ 1\n\n//#define SANGUINO_PINOUT // define for Sanguino pinout\n\n// general macros/defines\n#if !defined(BIT_READ)\n# define BIT_READ(value, bit)            ((value) &   (1UL << (bit)))\n#endif\n#if !defined(BIT_SET)\n# define BIT_SET(value, bit)             ((value) |=  (1UL << (bit)))\n#endif\n#if !defined(BIT_CLEAR)\n# define BIT_CLEAR(value, bit)           ((value) &= ~(1UL << (bit)))\n#endif\n#if !defined(BIT_WRITE)\n# define BIT_WRITE(value, bit, bitvalue) (bitvalue ? BIT_SET(value, bit) : BIT_CLEAR(value, bit))\n#endif\n\n#include <Arduino.h> // declarations for the fallback to digitalWrite(), digitalRead() etc.\n\n// --- Arduino Mega and ATmega128x/256x based boards ---\n#if (defined(ARDUINO_AVR_MEGA) || \\\n       defined(ARDUINO_AVR_MEGA1280) || \\\n       defined(ARDUINO_AVR_MEGA2560) || \\\n       defined(__AVR_ATmega1280__) || \\\n       defined(__AVR_ATmega1281__) || \\\n       defined(__AVR_ATmega2560__) || \\\n       defined(__AVR_ATmega2561__))\n\n#define __digitalPinToPortReg(P) \\\n(((P) >= 22 && (P) <= 29) ? &PORTA : \\\n((((P) >= 10 && (P) <= 13) || ((P) >= 50 && (P) <= 53)) ? &PORTB : \\\n(((P) >= 30 && (P) <= 37) ? &PORTC : \\\n((((P) >= 18 && (P) <= 21) || (P) == 38) ? &PORTD : \\\n((((P) <= 3) || (P) == 5) ? &PORTE : \\\n(((P) >= 54 && (P) <= 61) ? &PORTF : \\\n((((P) >= 39 && (P) <= 41) || (P) == 4) ? &PORTG : \\\n((((P) >= 6 && (P) <= 9) || (P) == 16 || (P) == 17) ? &PORTH : \\\n(((P) == 14 || (P) == 15) ? &PORTJ : \\\n(((P) >= 62 && (P) <= 69) ? &PORTK : &PORTL))))))))))\n\n#define __digitalPinToDDRReg(P) \\\n(((P) >= 22 && (P) <= 29) ? &DDRA : \\\n((((P) >= 10 && (P) <= 13) || ((P) >= 50 && (P) <= 53)) ? &DDRB : \\\n(((P) >= 30 && (P) <= 37) ? &DDRC : \\\n((((P) >= 18 && (P) <= 21) || (P) == 38) ? &DDRD : \\\n((((P) <= 3) || (P) == 5) ? &DDRE : \\\n(((P) >= 54 && (P) <= 61) ? &DDRF : \\\n((((P) >= 39 && (P) <= 41) || (P) == 4) ? &DDRG : \\\n((((P) >= 6 && (P) <= 9) || (P) == 16 || (P) == 17) ? &DDRH : \\\n(((P) == 14 || (P) == 15) ? &DDRJ : \\\n(((P) >= 62 && (P) <= 69) ? &DDRK : &DDRL))))))))))\n\n#define __digitalPinToPINReg(P) \\\n(((P) >= 22 && (P) <= 29) ? &PINA : \\\n((((P) >= 10 && (P) <= 13) || ((P) >= 50 && (P) <= 53)) ? &PINB : \\\n(((P) >= 30 && (P) <= 37) ? &PINC : \\\n((((P) >= 18 && (P) <= 21) || (P) == 38) ? &PIND : \\\n((((P) <= 3) || (P) == 5) ? &PINE : \\\n(((P) >= 54 && (P) <= 61) ? &PINF : \\\n((((P) >= 39 && (P) <= 41) || (P) == 4) ? &PING : \\\n((((P) >= 6 && (P) <= 9) || (P) == 16 || (P) == 17) ? &PINH : \\\n(((P) == 14 || (P) == 15) ? &PINJ : \\\n(((P) >= 62 && (P) <= 69) ? &PINK : &PINL))))))))))\n\n#define __digitalPinToBit(P) \\\n(((P) >=  7 && (P) <=  9) ? (P) - 3 : \\\n(((P) >= 10 && (P) <= 13) ? (P) - 6 : \\\n(((P) >= 22 && (P) <= 29) ? (P) - 22 : \\\n(((P) >= 30 && (P) <= 37) ? 37 - (P) : \\\n(((P) >= 39 && (P) <= 41) ? 41 - (P) : \\\n(((P) >= 42 && (P) <= 49) ? 49 - (P) : \\\n(((P) >= 50 && (P) <= 53) ? 53 - (P) : \\\n(((P) >= 54 && (P) <= 61) ? (P) - 54 : \\\n(((P) >= 62 && (P) <= 69) ? (P) - 62 : \\\n(((P) == 0 || (P) == 15 || (P) == 17 || (P) == 21) ? 0 : \\\n(((P) == 1 || (P) == 14 || (P) == 16 || (P) == 20) ? 1 : \\\n(((P) == 19) ? 2 : \\\n(((P) == 5 || (P) == 6 || (P) == 18) ? 3 : \\\n(((P) == 2) ? 4 : \\\n(((P) == 3 || (P) == 4) ? 5 : 7)))))))))))))))\n\n\n// --- Arduino MightyCore standard pinout ---\n#elif (defined(__AVR_ATmega1284P__) || \\\n       defined(__AVR_ATmega1284__)  || \\\n       defined(__AVR_ATmega644P__)  || \\\n       defined(__AVR_ATmega644A__)  || \\\n       defined(__AVR_ATmega644__)   || \\\n       defined(__AVR_ATmega324PB__) || \\\n       defined(__AVR_ATmega324PA__) || \\\n       defined(__AVR_ATmega324P__)  || \\\n       defined(__AVR_ATmega324A__)  || \\\n       defined(__AVR_ATmega164P__)  || \\\n       defined(__AVR_ATmega164A__)  || \\\n       defined(__AVR_ATmega32__)    || \\\n       defined(__AVR_ATmega16__)    || \\\n       defined(__AVR_ATmega8535__))  && \\\n      !defined(BOBUINO_PINOUT)\n\n#if defined(__AVR_ATmega324PB__)\n#define __digitalPinToPortReg(P) \\\n(((P) <= 7) ? &PORTB : (((P) >= 8 && (P) <= 15) ? &PORTD : (((P) >= 16 && (P) <= 23) ? &PORTC : (((P) >= 24 && (P) <= 31) ? &PORTA : &PORTE))))\n#define __digitalPinToDDRReg(P) \\\n(((P) <= 7) ? &DDRB : (((P) >= 8 && (P) <= 15) ? &DDRD : (((P) >= 16 && (P) <= 23) ? &DDRC : (((P) >= 24 && (P) <= 31) ? &DDRA : &DDRE))))\n#define __digitalPinToPINReg(P) \\\n(((P) <= 7) ? &PINB : (((P) >= 8 && (P) <= 15) ? &PIND : (((P) >= 16 && (P) <= 23) ? &PINC : (((P) >= 24 && (P) <= 31) ? &PINA : &PINE))))\n# if defined(SANGUINO_PINOUT)\n#define __digitalPinToBit(P) \\\n(((P) <= 7) ? (P) : (((P) >= 8 && (P) <= 15) ? (P) - 8 : (((P) >= 16 && (P) <= 23) ? (P) - 16 : (((P) >= 16 && (P) <= 23) ? (7 - ((P) - 24)) : (P) - 32))))\n# else //MightyCore Pinout\n#define __digitalPinToBit(P) \\\n(((P) <= 7) ? (P) : (((P) >= 8 && (P) <= 15) ? (P) - 8 : (((P) >= 16 && (P) <= 23) ? (P) - 16 : (((P) >= 16 && (P) <= 23) ? (P) - 24 : (P) - 32))))\n# endif\n#elif defined(PORTA)\n#define __digitalPinToPortReg(P) \\\n(((P) <= 7) ? &PORTB : (((P) >= 8 && (P) <= 15) ? &PORTD : (((P) >= 16 && (P) <= 23) ? &PORTC : &PORTA)))\n#define __digitalPinToDDRReg(P) \\\n(((P) <= 7) ? &DDRB : (((P) >= 8 && (P) <= 15) ? &DDRD : (((P) >= 16 && (P) <= 23) ? &DDRC : &DDRA)))\n#define __digitalPinToPINReg(P) \\\n(((P) <= 7) ? &PINB : (((P) >= 8 && (P) <= 15) ? &PIND : (((P) >= 16 && (P) <= 23) ? &PINC : &PINA)))\n# if defined(SANGUINO_PINOUT)\n#define __digitalPinToBit(P) \\\n(((P) <= 7) ? (P) : (((P) >= 8 && (P) <= 15) ? (P) - 8 : (((P) >= 16 && (P) <= 23) ? (P) - 16 : (7 - ((P) - 24)))))\n# else //MightyCore Pinout\n#define __digitalPinToBit(P) \\\n(((P) <= 7) ? (P) : (((P) >= 8 && (P) <= 15) ? (P) - 8 : (((P) >= 16 && (P) <= 23) ? (P) - 16 : (P) - 24)))\n# endif\n#else\n#define __digitalPinToPortReg(P) \\\n(((P) <= 7) ? &PORTB : (((P) >= 8 && (P) <= 15) ? &PORTD : &PORTC))\n#define __digitalPinToDDRReg(P) \\\n(((P) <= 7) ? &DDRB : (((P) >= 8 && (P) <= 15) ? &DDRD : &DDRC))\n#define __digitalPinToPINReg(P) \\\n(((P) <= 7) ? &PINB : (((P) >= 8 && (P) <= 15) ? &PIND : &PINC))\n# if defined(SANGUINO_PINOUT)\n#define __digitalPinToBit(P) \\\n(((P) <= 7) ? (P) : (((P) >= 8 && (P) <= 15) ? (P) - 8 : (((P) >= 16 && (P) <= 23) ? (P) - 16 : (7 - ((P) - 24)))))\n# else //MightyCore Pinout\n#define __digitalPinToBit(P) \\\n(((P) <= 7) ? (P) : (((P) >= 8 && (P) <= 15) ? (P) - 8 : (((P) >= 16 && (P) <= 23) ? (P) - 16 : (P) - 24)))\n# endif\n#endif\n\n\n// --- Arduino Leonardo and ATmega16U4/32U4 based boards ---\n#elif (defined(ARDUINO_AVR_LEONARDO) || \\\n       defined(__AVR_ATmega16U4__) || \\\n       defined(__AVR_ATmega32U4__))\n#  if defined(TEENSYDUINO)\n\n#define __digitalPinToPortReg(P) \\\n((((P) <= 4) || ((P) >= 13 && (P) <= 15)) ? &PORTB : (((P) == 9 || (P) == 10) ? &PORTC : (((P) >= 16 && (P) <= 21)) ? &PORTF : &PORTD))\n#define __digitalPinToDDRReg(P) \\\n((((P) <= 4) || ((P) >= 13 && (P) <= 15)) ? &DDRB : (((P) == 9 || (P) == 10) ? &DDRC : (((P) >= 16 && (P) <= 21)) ? &DDRF : &DDRD))\n#define __digitalPinToPINReg(P) \\\n((((P) <= 4) || ((P) >= 13 && (P) <= 15)) ? &PINB : (((P) == 9 || (P) == 10) ? &PINC : (((P) >= 16 && (P) <= 21)) ? &PINF : &PIND))\n#define __digitalPinToBit(P) \\\n(((P) <= 3) ? (P) : \\\n(((P) == 4 || (P) == 12) ? 7 : \\\n(((P) <= 8) ? (P) - 5 : \\\n(((P) <= 10) ? (P) - 3 : \\\n(((P) == 11) ? 6 : \\\n(((P) <= 15) ? (P) - 9 : \\\n(((P) <= 19) ? 23 - (P) : \\\n(((P) <= 21) ? 21 - (P) : (P) - 18))))))))\n#  else\n\n#define __digitalPinToPortReg(P) \\\n((((P) <= 4) || (P) == 6 || (P) == 12 || (P) == 24 || (P) == 25 || (P) == 29) ? &PORTD : (((P) == 5 || (P) == 13) ? &PORTC : (((P) >= 18 && (P) <= 23)) ? &PORTF : (((P) == 7) ? &PORTE : &PORTB)))\n#define __digitalPinToDDRReg(P) \\\n((((P) <= 4) || (P) == 6 || (P) == 12 || (P) == 24 || (P) == 25 || (P) == 29) ? &DDRD : (((P) == 5 || (P) == 13) ? &DDRC : (((P) >= 18 && (P) <= 23)) ? &DDRF : (((P) == 7) ? &DDRE : &DDRB)))\n#define __digitalPinToPINReg(P) \\\n((((P) <= 4) || (P) == 6 || (P) == 12 || (P) == 24 || (P) == 25 || (P) == 29) ? &PIND : (((P) == 5 || (P) == 13) ? &PINC : (((P) >= 18 && (P) <= 23)) ? &PINF : (((P) == 7) ? &PINE : &PINB)))\n#define __digitalPinToBit(P) \\\n(((P) >= 8 && (P) <= 11) ? (P) - 4 : \\\n(((P) >= 18 && (P) <= 21) ? 25 - (P) : \\\n(((P) == 0) ? 2 : (((P) == 1) ? 3 : (((P) == 2) ? 1 : (((P) == 3) ? 0 : (((P) == 4) ? 4 : (((P) == 6) ? 7 : (((P) == 13) ? 7 : \\\n(((P) == 14) ? 3 : (((P) == 15) ? 1 : (((P) == 16) ? 2 : (((P) == 17) ? 0 : (((P) == 22) ? 1 : (((P) == 23) ? 0 : \\\n(((P) == 24) ? 4 : (((P) == 25) ? 7 : (((P) == 26) ? 4 : (((P) == 27) ? 5 : 6 )))))))))))))))))))\n#  endif\n\n// --- Arduino Uno and ATmega168/328 based boards ---\n#elif (defined(ARDUINO_AVR_UNO) || \\\n       defined(ARDUINO_AVR_DUEMILANOVE) || \\\n       defined(__AVR_ATmega8__) || \\\n       defined(__AVR_ATmega48__) || \\\n       defined(__AVR_ATmega48P__) || \\\n       defined(__AVR_ATmega48PB__) || \\\n       defined(__AVR_ATmega88P__) || \\\n       defined(__AVR_ATmega88PB__) || \\\n       defined(__AVR_ATmega168__) || \\\n       defined(__AVR_ATmega168PA__) || \\\n       defined(__AVR_ATmega168PB__) || \\\n       defined(__AVR_ATmega328__) || \\\n       defined(__AVR_ATmega328P__) || \\\n       defined(__AVR_ATmega328PB__))\n\n#if defined(__AVR_ATmega48PB__) || defined(__AVR_ATmega88PB__) || defined(__AVR_ATmega168PB__) || defined(__AVR_ATmega328PB__)\n#define __digitalPinToPortReg(P) \\\n(((P) <= 7) ? &PORTD : (((P) >= 8 && (P) <= 13) ? &PORTB : (((P) >= 14 && (P) <= 19) ? &PORTC : &PORTE)))\n#define __digitalPinToDDRReg(P) \\\n(((P) <= 7) ? &DDRD : (((P) >= 8 && (P) <= 13) ? &DDRB : (((P) >= 14 && (P) <= 19) ? &DDRC : &DDRE)))\n#define __digitalPinToPINReg(P) \\\n(((P) <= 7) ? &PIND : (((P) >= 8 && (P) <= 13) ? &PINB : (((P) >= 14 && (P) <= 19) ? &PINC : &PINE)))\n#define __digitalPinToBit(P) \\\n(((P) <= 7) ? (P) : (((P) >= 8 && (P) <= 13) ? (P) - 8 : (((P) >= 14 && (P) <= 19) ? (P) - 14 : (((P) >= 20 && (P) <= 21) ? (P) - 18 : (P) - 22))))\n#else\n#define __digitalPinToPortReg(P) \\\n(((P) <= 7) ? &PORTD : (((P) >= 8 && (P) <= 13) ? &PORTB : &PORTC))\n#define __digitalPinToDDRReg(P) \\\n(((P) <= 7) ? &DDRD : (((P) >= 8 && (P) <= 13) ? &DDRB : &DDRC))\n#define __digitalPinToPINReg(P) \\\n(((P) <= 7) ? &PIND : (((P) >= 8 && (P) <= 13) ? &PINB : &PINC))\n#define __digitalPinToBit(P) \\\n(((P) <= 7) ? (P) : (((P) >= 8 && (P) <= 13) ? (P) - 8 : (P) - 14))\n#endif\n\n// --- Arduino Uno WiFi Rev 2, Nano Every ---\n#elif defined(__AVR_ATmega4809__)\n\n#define __digitalPinToPortReg(P) \\\n(((P) == 2 || (P) == 7 ) ? &VPORTA.OUT : ((P) == 5 || (P) == 9 || (P) == 10) ? &VPORTB.OUT : ((P) == 4) ? &VPORTC.OUT : (((P) >= 14 && (P) <= 17) || (P) == 20 || (P) == 21) ? &VPORTD.OUT : ((P) == 8 || (P) == 11 || (P) == 12 || (P) == 13) ? &VPORTE.OUT : &VPORTF.OUT)\n#define __digitalPinToDDRReg(P) \\\n(((P) == 2 || (P) == 7 ) ? &VPORTA.DIR : ((P) == 5 || (P) == 9 || (P) == 10) ? &VPORTB.DIR : ((P) == 4) ? &VPORTC.DIR : (((P) >= 14 && (P) <= 17) || (P) == 20 || (P) == 21) ? &VPORTD.DIR : ((P) == 8 || (P) == 11 || (P) == 12 || (P) == 13) ? &VPORTE.DIR : &VPORTF.DIR)\n#define __digitalPinToPINReg(P) \\\n(((P) == 2 || (P) == 7 ) ? &VPORTA.IN : ((P) == 5 || (P) == 9 || (P) == 10) ? &VPORTB.IN : ((P) == 4) ? &VPORTC.IN : (((P) >= 14 && (P) <= 17) || (P) == 20 || (P) == 21) ? &VPORTD.IN : ((P) == 8 || (P) == 11 || (P) == 12 || (P) == 13) ? &VPORTE.IN : &VPORTF.IN)\n#define __digitalPinToBit(P) \\\n(((P) == 2 || (P) == 9 || (P) == 11 || (P) == 17) ? 0 : ((P) == 7 || (P) == 10 || (P) == 12 || (P) == 16) ? 1 : ((P) == 5 || (P) == 13 || (P) == 15 || (P) == 18) ? 2 : ((P) == 9 || (P) == 14 || (P) == 19) ? 3 : ((P) == 6 || (P) == 20) ? 4 : ((P) == 3 || (P) == 21) ? 5 :  6 )\n\n\n// TinyCore\n// https://raw.githubusercontent.com/xukangmin/TinyCore/master/avr/package/package_tinycore_index.json\n// https://docs.tinycore.dev/en/latest/\n#elif  defined(__AVR_ATtiny1616__) || defined(__AVR_ATtiny3216__) || defined(__AVR_ATtiny3217__)\n#define __digitalPinToPortReg(P) ((P) <= 5 ? &VPORTB.OUT : ((P) <= 9 ? &VPORTC.OUT : ((P) <= 16 ? &VPORTA.OUT : ((P) <= 18 ? &VPORTB.OUT : &VPORTC.OUT))))\n#define __digitalPinToDDRReg(P) ((P) <= 5 ? &VPORTB.DIR : ((P) <= 9 ? &VPORTC.DIR : ((P) <= 16 ? &VPORTA.DIR : ((P) <= 18 ? &VPORTB.DIR : &VPORTC.DIR))))\n#define __digitalPinToPINReg(P) ((P) <= 5 ? &VPORTB.IN : ((P) <= 9 ? &VPORTC.IN : ((P) <= 16 ? &VPORTA.IN : ((P) <= 18 ? &VPORTB.IN : &VPORTC.IN))))\n#define __digitalPinToBit(P) ( (P) <= 3 ? (3 - P) : ((P) <= 5 ? (P) : ((P) <= 9 ? (P - 6) : ((P) <= 16 ? ((P) - 9) : ((P) <= 18 ? ((P) - 11) : ((P) - 15))))) )\n\n#elif defined(__AVR_ATtiny1614__)\n#define __digitalPinToPortReg(P) ((P) <= 3 ? &VPORTA.OUT : ((P) <= 7 ? &VPORTB.OUT : &VPORTA.OUT))\n#define __digitalPinToDDRReg(P) ((P) <= 3 ? &VPORTA.DIR : ((P) <= 7 ? &VPORTB.DIR : &VPORTA.DIR))\n#define __digitalPinToPINReg(P) ((P) <= 3 ? &VPORTA.IN : ((P) <= 7 ? &VPORTB.IN : &VPORTA.IN))\n#define __digitalPinToBit(P) ( (P) <= 3 ? (P + 4) : ((P) <= 7 ? (7 - P) : ((P) <= 10 ? (P - 7) : (P) - 11)) )\n\n#elif  defined(__AVR_ATtiny816__)\n// https://github.com/Arduino-IRremote/Arduino-IRremote/discussions/1029\n#define __digitalPinToPortReg(P) ((P) <= 3 ? &VPORTA.OUT : ((P) <= 9 ? &VPORTB.OUT : ((P) <= 13 ? &VPORTC.OUT : ((P) <= 17 ? &VPORTA.OUT : &VPORTC.OUT))))\n#define __digitalPinToDDRReg(P) ((P) <= 3 ? &VPORTA.DIR : ((P) <= 9 ? &VPORTB.DIR : ((P) <= 13 ? &VPORTC.DIR : ((P) <= 17 ? &VPORTA.DIR : &VPORTC.DIR))))\n#define __digitalPinToPINReg(P) ((P) <= 3 ? &VPORTA.IN : ((P) <= 9 ? &VPORTB.IN : ((P) <= 13 ? &VPORTC.IN : ((P) <= 17 ? &VPORTA.IN : &VPORTC.IN))))\n#define __digitalPinToBit(P) ( (P) <= 3 ? (P + 4) : ((P) <= 9 ? (9 - P) : ((P) <= 13 ? (P - 10) : ((P) <= 16 ? (P - 13) : ((P) - 17)))) )\n\n// --- ATtinyX5 ---\n#elif defined(__AVR_ATtiny25__) || defined(__AVR_ATtiny45__) || defined(__AVR_ATtiny85__)\n// we have only PORTB\n#define __digitalPinToPortReg(P) (&PORTB)\n#define __digitalPinToDDRReg(P)  (&DDRB)\n#define __digitalPinToPINReg(P)  (&PINB)\n#define __digitalPinToBit(P)     (((P) <= 7) ? (P) : (((P) >= 8 && (P) <= 13) ? (P) - 8 : (P) - 14))\n\n\n// --- ATtiny88 ---\n#elif defined(__AVR_ATtiny88__)\n# if defined(ARDUINO_AVR_DIGISPARKPRO)\n#define __digitalPinToPortReg(P) ((P) <= 7 ? &PORTD : ((P) <= 14 ? &PORTB : ((P) <= 18 ? &PORTA : &PORTC)))\n#define __digitalPinToDDRReg(P)  ((P) <= 7 ? &DDRD : ((P) <= 14 ? &DDRB : ((P) <= 18 ? &DDRA : &DDRC)))\n#define __digitalPinToPINReg(P)  ((P) <= 7 ? &PIND : ((P) <= 14 ? &PINB : ((P) <= 18 ? &PINA : &PINC)))\n#define __digitalPinToBit(P) ( (P) <= 7 ? (P) : ((P) <= 13 ? ((P) - 8) : ((P) == 14 ? 7 : ((P) <= 16 ? ((P) - 14) : ((P) <= 18 ? ((P) - 17) : ((P) == 25 ? 7 : ((P) - 19)))))) )\n# else\n#define __digitalPinToPortReg(P) ((P) <= 7 ? &PORTD : ((P) <= 15 ? &PORTB : ((P) <= 22 ? &PORTC : ((P) <= 26 ? &PORTA : &PORTC))))\n#define __digitalPinToDDRReg(P) ((P) <= 7 ? &DDRD : ((P) <= 15 ? &DDRB : ((P) <= 22 ? &DDRC : ((P) <= 26 ? &DDRA : &DDRC))))\n#define __digitalPinToPINReg(P) ((P) <= 7 ? &PIND : ((P) <= 15 ? &PINB : ((P) <= 22 ? &PINC : ((P) <= 26 ? &PINA : &PINC))))\n#define __digitalPinToBit(P) ((P) <= 15 ? ((P) & 0x7) : ((P) == 16 ? (7) : ((P) <= 22 ? ((P) - 17) : ((P) == 27 ? (6) : ((P) - 23)))))\n# endif\n\n\n// --- ATtinyX4 + ATtinyX7 ---\n#elif  defined(__AVR_ATtiny24__) || defined(__AVR_ATtiny44__) || defined(__AVR_ATtiny84__) \\\n    || defined(__AVR_ATtiny441__) || defined(__AVR_ATtiny841__) || defined(__AVR_ATtiny87__) || defined(__AVR_ATtiny167__)\n# if defined(ARDUINO_AVR_DIGISPARKPRO) || PIN_PA7 == 5\n// Strange enumeration of pins on Digispark board and core library\n#define __digitalPinToPortReg(P) (((P) <= 4) ? &PORTB : &PORTA)\n#define __digitalPinToDDRReg(P)  (((P) <= 4) ? &DDRB : &DDRA)\n#define __digitalPinToPINReg(P)  (((P) <= 4) ? &PINB : &PINA)\n#define __digitalPinToBit(P)     (((P) <= 2) ? (P) : (((P) == 3) ? 6 : (((P) == 4) ? 3 : (((P) == 5) ? 7 : (P) - 6 ))))\n# else\n// ATtinyX4: PORTA for 0 to 7, PORTB for 8 to 11\n// ATtinyX7: PORTA for 0 to 7, PORTB for 8 to 15\n#define __digitalPinToPortReg(P) (((P) <= 7) ? &PORTA : &PORTB)\n#define __digitalPinToDDRReg(P)  (((P) <= 7) ? &DDRA : &DDRB)\n#define __digitalPinToPINReg(P)  (((P) <= 7) ? &PINA : &PINB)\n# endif\n# if  defined(__AVR_ATtiny24__) || defined(__AVR_ATtiny44__) || defined(__AVR_ATtiny84__) || defined(__AVR_ATtiny441__) || defined(__AVR_ATtiny841__)\n// https://github.com/SpenceKonde/ATTinyCore/blob/v2.0.0-devThis-is-the-head-submit-PRs-against-this/avr/variants/tinyx41_cw/pins_arduino.h#L334\n// Clockwise layout\n#define __digitalPinToBit(P)     (((P) <= 7) ? (P) : ((P) == 11 ? (3) : 10 - (P)))\n# else\n#define __digitalPinToBit(P)     (((P) <= 7) ? (P) : (P) - 8 )\n# endif\n\n#endif\n\n\nvoid NonConstantsUsedForPinModeFast( void )  __attribute__ (( error(\"Parameter for pinModeFast() function is not constant\") ));\nvoid NonConstantsUsedForDigitalWriteFast( void )  __attribute__ (( error(\"Parameter for digitalWriteFast() function is not constant\") ));\nvoid NonConstantsUsedForDigitalToggleFast( void )  __attribute__ (( error(\"Parameter for digitalToggleFast() function is not constant\") ));\nint NonConstantsUsedForDigitalReadFast( void )  __attribute__ (( error(\"Parameter for digitalReadFast() function is not constant\") ));\n\n#if !defined(digitalWriteFast)\n#  if (defined(__AVR__) || defined(ARDUINO_ARCH_AVR)) && defined(__digitalPinToPortReg)\n#    if defined(THROW_ERROR_IF_NOT_FAST)\n#define digitalWriteFast(P, V) \\\nif (__builtin_constant_p(P)) { \\\n  BIT_WRITE(*__digitalPinToPortReg(P), __digitalPinToBit(P), (V)); \\\n} else { \\\n    NonConstantsUsedForDigitalWriteFast(); \\\n}\n#    else\n#define digitalWriteFast(P, V) \\\nif (__builtin_constant_p(P)) { \\\n  BIT_WRITE(*__digitalPinToPortReg(P), __digitalPinToBit(P), (V)); \\\n} else { \\\n  digitalWrite((P), (V)); \\\n}\n#    endif // defined(THROW_ERROR_IF_NOT_FAST)\n#  else\n#define digitalWriteFast digitalWrite\n#  endif\n#endif\n\n#if !defined(pinModeFast)\n#  if (defined(__AVR__) || defined(ARDUINO_ARCH_AVR)) && defined(__digitalPinToPortReg)\n#    if defined(THROW_ERROR_IF_NOT_FAST)\n#define pinModeFast(P, V) \\\nif (__builtin_constant_p(P) && __builtin_constant_p(V)) { \\\n  if (V == INPUT_PULLUP) {\\\n    BIT_CLEAR(*__digitalPinToDDRReg(P), __digitalPinToBit(P)); \\\n    BIT_SET(*__digitalPinToPortReg(P), __digitalPinToBit(P)); \\\n  } else { \\\n    BIT_WRITE(*__digitalPinToDDRReg(P), __digitalPinToBit(P), (V)); \\\n  } \\\n} else { \\\n    NonConstantsUsedForPinModeFast(); \\\n}\n#    else\n#define pinModeFast(P, V) \\\nif (__builtin_constant_p(P) && __builtin_constant_p(V)) { \\\n  if (V == INPUT_PULLUP) {\\\n    BIT_CLEAR(*__digitalPinToDDRReg(P), __digitalPinToBit(P)); \\\n    BIT_SET(*__digitalPinToPortReg(P), __digitalPinToBit(P)); \\\n  } else { \\\n    BIT_WRITE(*__digitalPinToDDRReg(P), __digitalPinToBit(P), (V)); \\\n  } \\\n} else { \\\n  pinMode((P), (V)); \\\n}\n#    endif // defined(THROW_ERROR_IF_NOT_FAST)\n#  else\n#define pinModeFast pinMode\n#  endif\n#endif // !defined(pinModeFast)\n\n#if !defined(digitalReadFast)\n#  if (defined(__AVR__) || defined(ARDUINO_ARCH_AVR)) && defined(__digitalPinToPINReg)\n#    if defined(THROW_ERROR_IF_NOT_FAST)\n#define digitalReadFast(P) ( (int) __digitalReadFast((P)) )\n// since we have return values, it is easier to implement it by ?:\n#define __digitalReadFast(P ) \\\n  (__builtin_constant_p(P) ) ? \\\n  (( BIT_READ(*__digitalPinToPINReg(P), __digitalPinToBit(P))) ? HIGH:LOW ) : \\\n  NonConstantsUsedForDigitalReadFast()\n#    else\n#define digitalReadFast(P) ( (int) __digitalReadFast((P)) )\n// since we have return values, it is easier to implement it by ?:\n#define __digitalReadFast(P ) \\\n  (__builtin_constant_p(P) ) ? \\\n  (( BIT_READ(*__digitalPinToPINReg(P), __digitalPinToBit(P))) ? HIGH:LOW ) : \\\n  digitalRead((P))\n#    endif // defined(THROW_ERROR_IF_NOT_FAST)\n#  else\n#define digitalReadFast digitalRead\n#  endif\n#endif // !defined(digitalReadFast)\n\n#if !defined(digitalToggleFast)\n#  if (defined(__AVR__) || defined(ARDUINO_ARCH_AVR)) && defined(__digitalPinToPINReg)\n#    if defined(THROW_ERROR_IF_NOT_FAST)\n#define digitalToggleFast(P) \\\nif (__builtin_constant_p(P)) { \\\n  BIT_SET(*__digitalPinToPINReg(P), __digitalPinToBit(P)); \\\n} else { \\\n    NonConstantsUsedForDigitalToggleFast(); \\\n}\n#    else\n#define digitalToggleFast(P) \\\nif (__builtin_constant_p(P)) { \\\n  BIT_SET(*__digitalPinToPINReg(P), __digitalPinToBit(P)); \\\n} else { \\\n  digitalWrite(P, ! digitalRead(P)); \\\n}\n#    endif // defined(THROW_ERROR_IF_NOT_FAST)\n#  else\n#define digitalToggleFast(P) digitalWrite(P, ! digitalRead(P))\n#  endif\n#endif // !defined(digitalToggleFast)\n\n#endif //__digitalWriteFast_h_\n"
    }, {
      filename: "src/ir_LG.hpp",
      code: "/*\n * ir_LG.hpp\n *\n *  Contains functions for receiving and sending LG IR Protocol for air conditioner\n *\n *  This file is part of Arduino-IRremote https://github.com/Arduino-IRremote/Arduino-IRremote.\n *\n ************************************************************************************\n * MIT License\n *\n * Copyright (c) 2017-2024 Darryl Smith, Armin Joachimsmeyer\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is furnished\n * to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n ************************************************************************************\n */\n#ifndef _IR_LG_HPP\n#define _IR_LG_HPP\n\n#if defined(DEBUG) && !defined(LOCAL_DEBUG)\n#define LOCAL_DEBUG\n#else\n//#define LOCAL_DEBUG // This enables debug output only for this file\n#endif\n\n/** \\addtogroup Decoder Decoders and encoders for different protocols\n * @{\n */\n//==============================================================================\n//                               L       GGGG\n//                               L      G\n//                               L      G  GG\n//                               L      G   G\n//                               LLLLL   GGG\n//==============================================================================\n/*\n * Protocol=LG Address=0xF1 Command=0x7776 Raw-Data=0xF17776B 28 bits MSB first\n +8950,-4150\n + 500,-1550 + 550,-1550 + 500,-1550 + 500,-1600\n + 500,- 700 + 350,- 600 + 450,- 600 + 450,-1550\n + 500,- 550 + 500,-1550 + 500,-1600 + 500,-1550\n + 550,- 550 + 500,-1550 + 500,-1550 + 550,-1550\n + 500,- 550 + 500,-1550 + 500,-1600 + 500,-1550\n + 500,- 550 + 500,-1550 + 500,-1600 + 500,- 550\n + 500,-1550 + 500,- 600 + 450,-1600 + 500,-1550\n + 500\n Sum: 62400\n */\n\n// LG originally added by Darryl Smith (based on the JVC protocol)\n// see: https://github.com/Arduino-IRremote/Arduino-IRremote/tree/master/examples/LGAirConditionerSendDemo\n// see: https://www.mikrocontroller.net/articles/IRMP_-_english#LGAIR\n// MSB first, 1 start bit + 8 bit address + 16 bit command + 4 bit checksum + 1 stop bit (28 data bits).\n// Bit and repeat timing is like NEC\n// LG2 has different header timing and a shorter bit time\n/*\n * LG remote IR-LED measurements: Type AKB 73315611 for air conditioner, Ver1.1 from 2011.03.01\n * Protocol: LG2\n * Internal crystal: 4 MHz\n * Header:  8.9 ms mark 4.15 ms space\n * Data:    500 / 540 and 500 / 1580;\n * Clock is not synchronized with gate so you have 19 and sometimes 19 and a spike pulses for mark\n * Duty:    9 us on 17 us off => around 33 % duty\n * NO REPEAT: If value like temperature has changed during long press, the last value is send at button release.\n * If you do a double press, the next value can be sent after around 118 ms. Tested with the fan button.\n\n * LG remote IR-LED measurements: Type AKB 75095308 for LG TV\n * Protocol: NEC!!!\n * Frequency 37.88 kHz\n * Header:  9.0 ms mark 4.5 ms space\n * Data:    560 / 560 and 560 / 1680;\n * Clock is synchronized with gate, mark always starts with a full period\n * Duty:    13 us on 13 us off => 50 % duty\n * Repeat:  110 ms 9.0 ms mark, 2250 us space, 560 stop\n * LSB first!\n *\n * The codes of the LG air conditioner are documented in https://github.com/Arduino-IRremote/Arduino-IRremote/blob/master/ac_LG.cpp\n */\n#define LG_ADDRESS_BITS          8\n#define LG_COMMAND_BITS         16\n#define LG_CHECKSUM_BITS         4\n#define LG_BITS                 (LG_ADDRESS_BITS + LG_COMMAND_BITS + LG_CHECKSUM_BITS) // 28\n\n#define LG_UNIT                 500 // 19 periods of 38 kHz\n\n#define LG_HEADER_MARK          (18 * LG_UNIT) // 9000\n#define LG_HEADER_SPACE         4200           // 4200 | 84\n\n#define LG2_HEADER_MARK         (19 * LG_UNIT) // 9500\n#define LG2_HEADER_SPACE        (6 * LG_UNIT)  // 3000\n\n#define LG_BIT_MARK             LG_UNIT\n#define LG_ONE_SPACE            1580  // 60 periods of 38 kHz\n#define LG_ZERO_SPACE           550\n\n#define LG_REPEAT_HEADER_SPACE  (4 * LG_UNIT)  // 2250\n#define LG_REPEAT_PERIOD        110000 // Commands are repeated every 110 ms (measured from start to start) for as long as the key on the remote control is held down.\n//#define LG_AVERAGE_DURATION     58000 // LG_HEADER_MARK + LG_HEADER_SPACE  + 32 * 2,5 * LG_UNIT) + LG_UNIT // 2.5 because we assume more zeros than ones\n//#define LG_REPEAT_DURATION      (LG_HEADER_MARK  + LG_REPEAT_HEADER_SPACE + LG_BIT_MARK)\n//#define LG_REPEAT_DISTANCE      (LG_REPEAT_PERIOD - LG_AVERAGE_DURATION) // 52 ms\n\nstruct PulseDistanceWidthProtocolConstants LGProtocolConstants = { LG, LG_KHZ, LG_HEADER_MARK, LG_HEADER_SPACE, LG_BIT_MARK,\nLG_ONE_SPACE, LG_BIT_MARK, LG_ZERO_SPACE, PROTOCOL_IS_MSB_FIRST, (LG_REPEAT_PERIOD / MICROS_IN_ONE_MILLI), &sendNECSpecialRepeat };\n\nstruct PulseDistanceWidthProtocolConstants LG2ProtocolConstants = { LG2, LG_KHZ, LG2_HEADER_MARK, LG2_HEADER_SPACE, LG_BIT_MARK,\nLG_ONE_SPACE, LG_BIT_MARK, LG_ZERO_SPACE, PROTOCOL_IS_MSB_FIRST, (LG_REPEAT_PERIOD / MICROS_IN_ONE_MILLI), &sendLG2SpecialRepeat };\n\n/************************************\n * Start of send and decode functions\n ************************************/\n/*\n * Send special LG2 repeat - not used internally\n */\nvoid IRsend::sendLG2Repeat() {\n    enableIROut (LG_KHZ);            // 38 kHz\n    mark(LG2_HEADER_MARK);          // + 3000\n    space(LG_REPEAT_HEADER_SPACE);  // - 2250\n    mark(LG_BIT_MARK);              // + 500\n}\n\n/**\n * Static function for sending special repeat frame.\n * For use in ProtocolConstants. Saves up to 250 bytes compared to a member function.\n */\nvoid sendLG2SpecialRepeat() {\n    IrSender.enableIROut(LG_KHZ);            // 38 kHz\n    IrSender.mark(LG2_HEADER_MARK);          // + 3000\n    IrSender.space(LG_REPEAT_HEADER_SPACE);  // - 2250\n    IrSender.mark(LG_BIT_MARK);              // + 500\n}\n\nuint32_t IRsend::computeLGRawDataAndChecksum(uint8_t aAddress, uint16_t aCommand) {\n    uint32_t tRawData = ((uint32_t) aAddress << (LG_COMMAND_BITS + LG_CHECKSUM_BITS)) | ((uint32_t) aCommand << LG_CHECKSUM_BITS);\n    /*\n     * My guess of the 4 bit checksum\n     * Addition of all 4 nibbles of the 16 bit command\n     */\n    uint8_t tChecksum = 0;\n    uint16_t tTempForChecksum = aCommand;\n    for (int i = 0; i < 4; ++i) {\n        tChecksum += tTempForChecksum & 0xF; // add low nibble\n        tTempForChecksum >>= 4; // shift by a nibble\n    }\n    return (tRawData | (tChecksum & 0xF));\n}\n\n/**\n * LG uses the NEC repeat.\n */\nvoid IRsend::sendLG(uint8_t aAddress, uint16_t aCommand, int_fast8_t aNumberOfRepeats) {\n    sendPulseDistanceWidth(&LGProtocolConstants, computeLGRawDataAndChecksum(aAddress, aCommand), LG_BITS, aNumberOfRepeats);\n}\n\n/**\n * LG2 uses a special repeat.\n */\nvoid IRsend::sendLG2(uint8_t aAddress, uint16_t aCommand, int_fast8_t aNumberOfRepeats) {\n    sendPulseDistanceWidth(&LG2ProtocolConstants, computeLGRawDataAndChecksum(aAddress, aCommand), LG_BITS, aNumberOfRepeats);\n}\n\nbool IRrecv::decodeLG() {\n    decode_type_t tProtocol = LG;\n    uint16_t tHeaderSpace = LG_HEADER_SPACE;\n\n    /*\n     * First check for right data length\n     * Next check start bit\n     * Next try the decode\n     */\n\n// Check we have the right amount of data (60). The +4 is for initial gap, start bit mark and space + stop bit mark.\n    if (decodedIRData.rawlen != ((2 * LG_BITS) + 4) && (decodedIRData.rawlen != 4)) {\n        IR_DEBUG_PRINT(F(\"LG: \"));\n        IR_DEBUG_PRINT(F(\"Data length=\"));\n        IR_DEBUG_PRINT(decodedIRData.rawlen);\n        IR_DEBUG_PRINTLN(F(\" is not 60 or 4\"));\n        return false;\n    }\n\n// Check header \"mark\" this must be done for repeat and data\n    if (!matchMark(decodedIRData.rawDataPtr->rawbuf[1], LG_HEADER_MARK)) {\n        if (matchMark(decodedIRData.rawDataPtr->rawbuf[1], LG2_HEADER_MARK)) {\n            tProtocol = LG2;\n            tHeaderSpace = LG2_HEADER_SPACE;\n        } else {\n#if defined(LOCAL_DEBUG)\n            Serial.print(F(\"LG: \"));\n            Serial.println(F(\"Header mark is wrong\"));\n#endif\n            return false; // neither LG nor LG2 header\n        }\n    }\n\n// Check for repeat - here we have another header space length\n    if (decodedIRData.rawlen == 4) {\n        if (matchSpace(decodedIRData.rawDataPtr->rawbuf[2], LG_REPEAT_HEADER_SPACE)\n                && matchMark(decodedIRData.rawDataPtr->rawbuf[3], LG_BIT_MARK)) {\n            decodedIRData.flags = IRDATA_FLAGS_IS_REPEAT | IRDATA_FLAGS_IS_MSB_FIRST;\n            decodedIRData.address = lastDecodedAddress;\n            decodedIRData.command = lastDecodedCommand;\n            decodedIRData.protocol = lastDecodedProtocol;\n            return true;\n        }\n#if defined(LOCAL_DEBUG)\n        Serial.print(F(\"LG: \"));\n        Serial.print(F(\"Repeat header space is wrong\"));\n#endif\n        return false;\n    }\n\n// Check command header space\n    if (!matchSpace(decodedIRData.rawDataPtr->rawbuf[2], tHeaderSpace)) {\n#if defined(LOCAL_DEBUG)\n        Serial.print(F(\"LG: \"));\n        Serial.println(F(\"Header space length is wrong\"));\n#endif\n        return false;\n    }\n\n    if (!decodePulseDistanceWidthData(&LGProtocolConstants, LG_BITS)) {\n#if defined(LOCAL_DEBUG)\n        Serial.print(F(\"LG: \"));\n        Serial.println(F(\"Decode failed\"));\n#endif\n        return false;\n    }\n\n// Success\n    decodedIRData.flags = IRDATA_FLAGS_IS_MSB_FIRST;\n    decodedIRData.command = (decodedIRData.decodedRawData >> LG_CHECKSUM_BITS) & 0xFFFF;\n    decodedIRData.address = decodedIRData.decodedRawData >> (LG_COMMAND_BITS + LG_CHECKSUM_BITS); // first 8 bit\n\n    /*\n     * My guess of the checksum\n     */\n    uint8_t tChecksum = 0;\n    uint16_t tTempForChecksum = decodedIRData.command;\n    for (int i = 0; i < 4; ++i) {\n        tChecksum += tTempForChecksum & 0xF; // add low nibble\n        tTempForChecksum >>= 4; // shift by a nibble\n    }\n// Checksum check\n    if ((tChecksum & 0xF) != (decodedIRData.decodedRawData & 0xF)) {\n#if defined(LOCAL_DEBUG)\n        Serial.print(F(\"LG: \"));\n        Serial.print(F(\"4 bit checksum is not correct. expected=0x\"));\n        Serial.print(tChecksum, HEX);\n        Serial.print(F(\" received=0x\"));\n        Serial.print((decodedIRData.decodedRawData & 0xF), HEX);\n        Serial.print(F(\" data=0x\"));\n        Serial.println(decodedIRData.command, HEX);\n#endif\n        decodedIRData.flags |= IRDATA_FLAGS_PARITY_FAILED;\n    }\n\n    decodedIRData.protocol = tProtocol; // LG or LG2\n    decodedIRData.numberOfBits = LG_BITS;\n\n    return true;\n}\n\n/*********************************************************************************\n * Old deprecated functions, kept for backward compatibility to old 2.0 tutorials\n *********************************************************************************/\n\n/**\n * Here you can put your raw data, even one with \"wrong\" checksum.\n * @param aRawData  The lowest 28 (LG_BITS) bit of this value are sent MSB first.\n * @param aNumberOfRepeats If < 0 then only a special repeat frame will be sent.\n */\nvoid IRsend::sendLGRaw(uint32_t aRawData, int_fast8_t aNumberOfRepeats) {\n    sendPulseDistanceWidth(&LGProtocolConstants, aRawData, LG_BITS, aNumberOfRepeats);\n}\n\nbool IRrecv::decodeLGMSB(decode_results *aResults) {\n    unsigned int offset = 1; // Skip first space\n\n// Check we have enough data (60) - +4 for initial gap, start bit mark and space + stop bit mark\n    if (aResults->rawlen != (2 * LG_BITS) + 4) {\n        return false;\n    }\n\n// Initial mark/space\n    if (!matchMark(aResults->rawbuf[offset], LG_HEADER_MARK)) {\n        return false;\n    }\n    offset++;\n\n    if (!matchSpace(aResults->rawbuf[offset], LG_HEADER_SPACE)) {\n        return false;\n    }\n    offset++;\n\n    if (!decodePulseDistanceWidthData(LG_BITS, offset, LG_BIT_MARK, 0, LG_ONE_SPACE, LG_ZERO_SPACE, PROTOCOL_IS_MSB_FIRST)) {\n        return false;\n    }\n// Stop bit\n    if (!matchMark(aResults->rawbuf[offset + (2 * LG_BITS)], LG_BIT_MARK)) {\n#if defined(LOCAL_DEBUG)\n        Serial.println(F(\"Stop bit mark length is wrong\"));\n#endif\n        return false;\n    }\n\n// Success\n    aResults->value = decodedIRData.decodedRawData;\n    aResults->bits = LG_BITS;\n    aResults->decode_type = LG;\n    decodedIRData.protocol = LG;\n    return true;\n}\n\n//+=============================================================================\nvoid IRsend::sendLG(unsigned long data, int nbits) {\n// Set IR carrier frequency\n    enableIROut (LG_KHZ);\n#if !(defined(__AVR_ATtiny25__) || defined(__AVR_ATtiny45__) || defined(__AVR_ATtiny85__) || defined(__AVR_ATtiny87__) || defined(__AVR_ATtiny167__))\n//    Serial.println(F(\n//            \"The function sendLG(data, nbits) is deprecated and may not work as expected! Use sendLGRaw(data, NumberOfRepeats) or better sendLG(Address, Command, NumberOfRepeats).\"));\n#endif\n// Header\n    mark(LG_HEADER_MARK);\n    space(LG_HEADER_SPACE);\n//    mark(LG_BIT_MARK);\n\n// Data + stop bit\n    sendPulseDistanceWidthData(LG_BIT_MARK, LG_ONE_SPACE, LG_BIT_MARK, LG_ZERO_SPACE, data, nbits, PROTOCOL_IS_MSB_FIRST);\n}\n\n/** @}*/\n#if defined(LOCAL_DEBUG)\n#undef LOCAL_DEBUG\n#endif\n#endif // _IR_LG_HPP\n"
    }, {
      filename: "src/ir_NEC.hpp",
      code: "/*\n * ir_NEC.hpp\n *\n *  Contains functions for receiving and sending NEC IR Protocol in \"raw\" and standard format with 16 or 8 bit address and 8 bit command\n *\n *  This file is part of Arduino-IRremote https://github.com/Arduino-IRremote/Arduino-IRremote.\n *\n ************************************************************************************\n * MIT License\n *\n * Copyright (c) 2020-2023 Armin Joachimsmeyer\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is furnished\n * to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n ************************************************************************************\n */\n#ifndef _IR_NEC_HPP\n#define _IR_NEC_HPP\n\n#if defined(DEBUG) && !defined(LOCAL_DEBUG)\n#define LOCAL_DEBUG // IR_DEBUG_PRINT is a real print function here. Add local debug output.\n#else\n//#define LOCAL_DEBUG // This enables debug output only for this file. IR_DEBUG_PRINT is still a void function here.\n#endif\n\n/** \\addtogroup Decoder Decoders and encoders for different protocols\n * @{\n */\n//==============================================================================\n//                           N   N  EEEEE   CCCC\n//                           NN  N  E      C\n//                           N N N  EEE    C\n//                           N  NN  E      C\n//                           N   N  EEEEE   CCCC\n//==============================================================================\n/*\n Protocol=NEC Address=0x4 Command=0x8 Raw-Data=0xF708FB04 32 bits LSB first\n +8950,-4450\n + 600,- 500 + 650,- 500 + 600,-1650 + 600,- 550\n + 600,- 500 + 600,- 500 + 650,- 500 + 600,- 500\n + 650,-1650 + 600,-1600 + 650,- 500 + 600,-1650\n + 600,-1650 + 600,-1650 + 600,-1600 + 650,-1600\n + 650,- 500 + 600,- 550 + 600,- 500 + 600,-1650\n + 600,- 550 + 600,- 500 + 600,- 550 + 600,- 500\n + 600,-1650 + 600,-1650 + 600,-1650 + 600,- 550\n + 600,-1650 + 600,-1650 + 600,-1650 + 600,-1600\n + 650\n Sum: 68000\n\n Protocol=NEC Address=0x8 Command=0x7 Repeat gap=40900us\n rawData[4]:\n -40900\n +10450,-2250\n + 700\n Sum: 13400\n */\n// http://www.hifi-remote.com/wiki/index.php/NEC\n// https://www.sbprojects.net/knowledge/ir/nec.php\n// NEC: LSB first, <start bit><address:16> (or <address:8><inverted address:8>) <command:8><inverted command:8><stop bit>.\n// ONKYO like NEC but 16 independent address and command bits: <start bit><address:16><command:16><stop bit>\n// Standard NEC sends a special fixed repeat frame.\n// NEC2 sends the same full frame after the 110 ms. I have a DVD remote with NEC2.\n// NEC and NEC 2 only differ in the repeat frames, so the protocol can only be detected correctly after the first repeat.\n// PIONEER (not implemented) is NEC2 with 40 kHz\n//\n// For Apple see https://en.wikipedia.org/wiki/Apple_Remote - <start bit><0x87EE:16><device ID:8><command:7><parity><stop bit> - not implemented!\n// The parity is not implemented, so we get: <start bit><0x87EE:16><device ID:8><command:8><stop bit>\n//\n// IRP notation:\n// IRP: NEC  {38.0k,564}<1,-1|1,-3>(16,-8,D:8,S:8,F:8,~F:8,1,^108m,(16,-4,1,^108m)*)  ==> \"*\" means send special repeat frames o ore more times\n// IRP: NEC2 {38.0k,564}<1,-1|1,-3>(16,-8,D:8,S:8,F:8,~F:8,1,^108m)+   ==> \"+\" means send frame 1 or more times (special repeat is missing here!)\n// Interpretation of IRP notation:\n// {38.0k,564} ==> 38.0k -> Frequency , 564 -> unit in microseconds (we use 560), no \"msb\", so \"lsb\" is assumed\n// <1,-1|1,-3> ==> Zero is 1 unit mark and space | One is 1 unit mark and 3 units space\n// 16,-8 ==> Start bit durations\n// D:8,S:8,F:8,~F:8 ==> D:8 -> 8 bit bitfield for Device, S:8 -> 8 bit bitfield for Subdevice, F:8 -> 8 bit bitfield for Function, ~F:8 -> 8 bit inverted bitfield for Function\n// 1,^108m ==> 1 -> unit mark Stop bit, ^108m -> wait until 108 milliseconds after start of protocol (we use 110)\n//\n#define NEC_ADDRESS_BITS        16 // 16 bit address or 8 bit address and 8 bit inverted address\n#define NEC_COMMAND_BITS        16 // Command and inverted command\n\n#define NEC_BITS                (NEC_ADDRESS_BITS + NEC_COMMAND_BITS)\n#define NEC_UNIT                560             // 21.28 periods of 38 kHz, 11.2 ticks TICKS_LOW = 8.358 TICKS_HIGH = 15.0\n\n#define NEC_HEADER_MARK         (16 * NEC_UNIT) // 9000 | 180\n#define NEC_HEADER_SPACE        (8 * NEC_UNIT)  // 4500 | 90\n\n#define NEC_BIT_MARK            NEC_UNIT\n#define NEC_ONE_SPACE           (3 * NEC_UNIT)  // 1690 | 33.8  TICKS_LOW = 25.07 TICKS_HIGH = 45.0\n#define NEC_ZERO_SPACE          NEC_UNIT\n\n#define NEC_REPEAT_HEADER_SPACE (4 * NEC_UNIT)  // 2250\n\n#define NEC_AVERAGE_DURATION    62000 // NEC_HEADER_MARK + NEC_HEADER_SPACE + 32 * 2,5 * NEC_UNIT + NEC_UNIT // 2.5 because we assume more zeros than ones\n#define NEC_MINIMAL_DURATION    49900 // NEC_HEADER_MARK + NEC_HEADER_SPACE + 32 * 2 * NEC_UNIT + NEC_UNIT // 2.5 because we assume more zeros than ones\n#define NEC_REPEAT_DURATION     (NEC_HEADER_MARK  + NEC_REPEAT_HEADER_SPACE + NEC_BIT_MARK) // 12 ms\n#define NEC_REPEAT_PERIOD       110000 // Commands are repeated every 110 ms (measured from start to start) for as long as the key on the remote control is held down.\n#define NEC_REPEAT_DISTANCE         (NEC_REPEAT_PERIOD - NEC_AVERAGE_DURATION) // 48 ms\n#define NEC_MAXIMUM_REPEAT_DISTANCE (NEC_REPEAT_PERIOD - NEC_MINIMAL_DURATION + 10000) // 70 ms\n\n#define APPLE_ADDRESS           0x87EE\n\nstruct PulseDistanceWidthProtocolConstants NECProtocolConstants =\n        { NEC, NEC_KHZ, NEC_HEADER_MARK, NEC_HEADER_SPACE, NEC_BIT_MARK,\n        NEC_ONE_SPACE, NEC_BIT_MARK, NEC_ZERO_SPACE, PROTOCOL_IS_LSB_FIRST, (NEC_REPEAT_PERIOD / MICROS_IN_ONE_MILLI),\n                &sendNECSpecialRepeat };\n\n// Like NEC but repeats are full frames instead of special NEC repeats\nstruct PulseDistanceWidthProtocolConstants NEC2ProtocolConstants = { NEC2, NEC_KHZ, NEC_HEADER_MARK, NEC_HEADER_SPACE, NEC_BIT_MARK,\nNEC_ONE_SPACE, NEC_BIT_MARK, NEC_ZERO_SPACE, PROTOCOL_IS_LSB_FIRST, (NEC_REPEAT_PERIOD / MICROS_IN_ONE_MILLI), NULL };\n\n/************************************\n * Start of send and decode functions\n ************************************/\n\n/**\n * Send special NEC repeat frame\n * Repeat commands should be sent in a 110 ms raster.\n */\nvoid IRsend::sendNECRepeat() {\n    enableIROut (NEC_KHZ);           // 38 kHz\n    mark(NEC_HEADER_MARK);          // + 9000\n    space(NEC_REPEAT_HEADER_SPACE); // - 2250\n    mark(NEC_BIT_MARK);             // + 560\n}\n\n/**\n * Static function variant of IRsend::sendNECRepeat\n * For use in ProtocolConstants. Saves up to 250 bytes compared to a member function.\n */\nvoid sendNECSpecialRepeat() {\n    IrSender.enableIROut(NEC_KHZ);           // 38 kHz\n    IrSender.mark(NEC_HEADER_MARK);          // + 9000\n    IrSender.space(NEC_REPEAT_HEADER_SPACE); // - 2250\n    IrSender.mark(NEC_BIT_MARK);             // + 560\n}\n\nuint32_t IRsend::computeNECRawDataAndChecksum(uint16_t aAddress, uint16_t aCommand) {\n    LongUnion tRawData;\n\n    // Address 16 bit LSB first\n    if ((aAddress & 0xFF00) == 0) {\n        // assume 8 bit address -> send 8 address bits and then 8 inverted address bits LSB first\n        tRawData.UByte.LowByte = aAddress;\n        tRawData.UByte.MidLowByte = ~tRawData.UByte.LowByte;\n    } else {\n        tRawData.UWord.LowWord = aAddress;\n    }\n\n    // send 8 command bits and then 8 inverted command bits LSB first\n    tRawData.UByte.MidHighByte = aCommand;\n    tRawData.UByte.HighByte = ~aCommand;\n    return tRawData.ULong;\n}\n\n/**\n * NEC Send frame and special repeats\n * There is NO delay after the last sent repeat!\n * @param aNumberOfRepeats  If < 0 then only a special NEC repeat frame will be sent by calling NECProtocolConstants.SpecialSendRepeatFunction().\n */\nvoid IRsend::sendNEC(uint16_t aAddress, uint8_t aCommand, int_fast8_t aNumberOfRepeats) {\n    sendPulseDistanceWidth(&NECProtocolConstants, computeNECRawDataAndChecksum(aAddress, aCommand), NEC_BITS, aNumberOfRepeats);\n}\n\n/*\n * NEC2 Send frame and repeat the frame for each requested repeat\n * There is NO delay after the last sent repeat!\n * @param aNumberOfRepeats  If < 0 then nothing is sent.\n */\nvoid IRsend::sendNEC2(uint16_t aAddress, uint8_t aCommand, int_fast8_t aNumberOfRepeats) {\n    sendPulseDistanceWidth(&NEC2ProtocolConstants, computeNECRawDataAndChecksum(aAddress, aCommand), NEC_BITS, aNumberOfRepeats);\n}\n\n/*\n * Repeat commands should be sent in a 110 ms raster.\n * There is NO delay after the last sent repeat!\n * @param aNumberOfRepeats  If < 0 then only a special repeat frame without leading and trailing space\n *                          will be sent by calling NECProtocolConstants.SpecialSendRepeatFunction().\n */\nvoid IRsend::sendOnkyo(uint16_t aAddress, uint16_t aCommand, int_fast8_t aNumberOfRepeats) {\n    sendPulseDistanceWidth(&NECProtocolConstants, (uint32_t) aCommand << 16 | aAddress, NEC_BITS, aNumberOfRepeats);\n}\n\n/*\n * Repeat commands should be sent in a 110 ms raster.\n * There is NO delay after the last sent repeat!\n * https://en.wikipedia.org/wiki/Apple_Remote\n * https://gist.github.com/darconeous/4437f79a34e3b6441628\n * @param aNumberOfRepeats  If < 0 then only a special repeat frame without leading and trailing space\n *                          will be sent by calling NECProtocolConstants.SpecialSendRepeatFunction().\n */\nvoid IRsend::sendApple(uint8_t aDeviceId, uint8_t aCommand, int_fast8_t aNumberOfRepeats) {\n    LongUnion tRawData;\n\n    // Address 16 bit LSB first fixed value of 0x87EE\n    tRawData.UWord.LowWord = APPLE_ADDRESS;\n\n    // send Apple code and then 8 command bits LSB first\n    tRawData.UByte.MidHighByte = aCommand;\n    tRawData.UByte.HighByte = aDeviceId; // e.g. 0xD7\n\n    sendPulseDistanceWidth(&NECProtocolConstants, tRawData.ULong, NEC_BITS, aNumberOfRepeats);\n}\n\n/*\n * Sends NEC protocol\n * @param aNumberOfRepeats  If < 0 then only a special repeat frame without leading and trailing space\n *                          will be sent by calling NECProtocolConstants.SpecialSendRepeatFunction().\n */\nvoid IRsend::sendNECRaw(uint32_t aRawData, int_fast8_t aNumberOfRepeats) {\n    sendPulseDistanceWidth(&NECProtocolConstants, aRawData, NEC_BITS, aNumberOfRepeats);\n}\n\n/**\n * Decodes also Onkyo and Apple\n */\nbool IRrecv::decodeNEC() {\n    /*\n     * First check for right data length\n     * Next check start bit\n     * Next try the decode\n     */\n    // Check we have the right amount of data (68). The +4 is for initial gap, start bit mark and space + stop bit mark.\n    if (decodedIRData.rawlen != ((2 * NEC_BITS) + 4) && (decodedIRData.rawlen != 4)) {\n        IR_DEBUG_PRINT(F(\"NEC: \"));\n        IR_DEBUG_PRINT(F(\"Data length=\"));\n        IR_DEBUG_PRINT(decodedIRData.rawlen);\n        IR_DEBUG_PRINTLN(F(\" is not 68 or 4\"));\n        return false;\n    }\n\n    // Check header \"mark\" this must be done for repeat and data\n    if (!matchMark(decodedIRData.rawDataPtr->rawbuf[1], NEC_HEADER_MARK)) {\n        return false;\n    }\n\n    // Check for repeat - here we have another header space length\n    if (decodedIRData.rawlen == 4) {\n        if (matchSpace(decodedIRData.rawDataPtr->rawbuf[2], NEC_REPEAT_HEADER_SPACE)\n                && matchMark(decodedIRData.rawDataPtr->rawbuf[3], NEC_BIT_MARK)) {\n            decodedIRData.flags = IRDATA_FLAGS_IS_REPEAT | IRDATA_FLAGS_IS_LSB_FIRST;\n            decodedIRData.address = lastDecodedAddress;\n            decodedIRData.command = lastDecodedCommand;\n            decodedIRData.protocol = lastDecodedProtocol;\n            return true;\n        }\n        return false;\n    }\n\n    // Check command header space\n    if (!matchSpace(decodedIRData.rawDataPtr->rawbuf[2], NEC_HEADER_SPACE)) {\n#if defined(LOCAL_DEBUG)\n        Serial.print(F(\"NEC: \"));\n        Serial.println(F(\"Header space length is wrong\"));\n#endif\n        return false;\n    }\n\n    // Try to decode as NEC protocol\n    if (!decodePulseDistanceWidthData(&NECProtocolConstants, NEC_BITS)) {\n#if defined(LOCAL_DEBUG)\n        Serial.print(F(\"NEC: \"));\n        Serial.println(F(\"Decode failed\"));\n#endif\n        return false;\n    }\n\n    // Success\n//    decodedIRData.flags = IRDATA_FLAGS_IS_LSB_FIRST; // Not required, since this is the start value\n    LongUnion tValue;\n    tValue.ULong = decodedIRData.decodedRawData;\n    decodedIRData.command = tValue.UByte.MidHighByte; // 8 bit\n\n#if defined(DECODE_ONKYO)\n    // Here only Onkyo protocol is supported -> force 16 bit address and command decoding\n    decodedIRData.address = tValue.UWord.LowWord; // first 16 bit\n    decodedIRData.protocol = ONKYO;\n    decodedIRData.command = tValue.UWord.HighWord; // 16 bit command\n#else\n    // Address\n    if (tValue.UWord.LowWord == APPLE_ADDRESS) {\n        /*\n         * Apple\n         */\n        decodedIRData.protocol = APPLE;\n        decodedIRData.address = tValue.UByte.HighByte;\n\n    } else {\n        /*\n         * NEC LSB first, so first sent bit is also LSB of decodedIRData.decodedRawData\n         */\n        if (tValue.UByte.LowByte == (uint8_t)(~tValue.UByte.MidLowByte)) {\n            // standard 8 bit address NEC protocol\n            decodedIRData.address = tValue.UByte.LowByte; // first 8 bit\n        } else {\n            // extended NEC protocol\n            decodedIRData.address = tValue.UWord.LowWord; // first 16 bit\n        }\n        // Check for command if it is 8 bit NEC or 16 bit ONKYO\n        if (tValue.UByte.MidHighByte == (uint8_t)(~tValue.UByte.HighByte)) {\n            decodedIRData.protocol = NEC;\n        } else {\n            decodedIRData.protocol = ONKYO;\n            decodedIRData.command = tValue.UWord.HighWord; // 16 bit command\n        }\n    }\n#endif\n\n    decodedIRData.numberOfBits = NEC_BITS;\n\n    // check for NEC2 repeat, do not check for same content ;-)\n    checkForRepeatSpaceTicksAndSetFlag(NEC_MAXIMUM_REPEAT_DISTANCE / MICROS_PER_TICK);\n    if (decodedIRData.flags & IRDATA_FLAGS_IS_REPEAT) {\n        decodedIRData.protocol = NEC2;\n        decodedIRData.flags |= IRDATA_FLAGS_IS_PROTOCOL_WITH_DIFFERENT_REPEAT;\n    }\n    return true;\n}\n\n/*********************************************************************************\n * Old deprecated functions, kept for backward compatibility to old 2.0 tutorials\n *********************************************************************************/\n\nbool IRrecv::decodeNECMSB(decode_results *aResults) {\n    unsigned int offset = 1;  // Index in to results; Skip first space.\n\n// Check header \"mark\"\n    if (!matchMark(aResults->rawbuf[offset], NEC_HEADER_MARK)) {\n        return false;\n    }\n    offset++;\n\n// Check for repeat\n    if ((aResults->rawlen == 4) && matchSpace(aResults->rawbuf[offset], NEC_REPEAT_HEADER_SPACE)\n            && matchMark(aResults->rawbuf[offset + 1], NEC_BIT_MARK)) {\n        aResults->bits = 0;\n        aResults->value = 0xFFFFFFFF;\n        decodedIRData.flags |= IRDATA_FLAGS_IS_REPEAT;\n        decodedIRData.protocol = NEC;\n        return true;\n    }\n\n    // Check we have the right amount of data (32). +4 for initial gap, start bit mark and space + stop bit mark\n    if (aResults->rawlen != (2 * NEC_BITS) + 4) {\n        IR_DEBUG_PRINT(F(\"NEC MSB: \"));\n        IR_DEBUG_PRINT(F(\"Data length=\"));\n        IR_DEBUG_PRINT(aResults->rawlen);\n        IR_DEBUG_PRINTLN(F(\" is not 68\"));\n        return false;\n    }\n\n// Check header \"space\"\n    if (!matchSpace(aResults->rawbuf[offset], NEC_HEADER_SPACE)) {\n#if defined(LOCAL_DEBUG)\n        Serial.print(F(\"NEC MSB: \"));\n        Serial.println(F(\"Header space length is wrong\"));\n#endif\n        return false;\n    }\n    offset++;\n\n    if (!decodePulseDistanceWidthData(NEC_BITS, offset, NEC_BIT_MARK, 0, NEC_ONE_SPACE, NEC_ZERO_SPACE, PROTOCOL_IS_MSB_FIRST)) {\n#if defined(LOCAL_DEBUG)\n        Serial.print(F(\"NEC MSB: \"));\n        Serial.println(F(\"Decode failed\"));\n#endif\n        return false;\n    }\n\n    // Stop bit\n    if (!matchMark(aResults->rawbuf[offset + (2 * NEC_BITS)], NEC_BIT_MARK)) {\n#if defined(LOCAL_DEBUG)\n        Serial.print(F(\"NEC MSB: \"));\n        Serial.println(F(\"Stop bit mark length is wrong\"));\n#endif\n        return false;\n    }\n\n// Success\n    aResults->value = decodedIRData.decodedRawData;\n    aResults->bits = NEC_BITS;\n    aResults->decode_type = NEC;\n    decodedIRData.protocol = NEC;\n\n    return true;\n}\n\n/**\n * With Send sendNECMSB() you can send your old 32 bit codes.\n * To convert one into the other, you must reverse the byte positions and then reverse all bit positions of each byte.\n * Use bitreverse32Bit().\n * Or write it as one binary string and reverse/mirror it.\n * Example:\n * 0xCB340102 byte reverse -> 02 01 34 CB bit reverse-> 40 80 2C D3.\n * 0xCB340102 is binary 11001011001101000000000100000010.\n * 0x40802CD3 is binary 01000000100000000010110011010011.\n * If you read the first binary sequence backwards (right to left), you get the second sequence.\n */\nvoid IRsend::sendNECMSB(uint32_t data, uint8_t nbits, bool repeat) {\n    // Set IR carrier frequency\n    enableIROut (NEC_KHZ);\n\n    if (data == 0xFFFFFFFF || repeat) {\n        sendNECRepeat();\n        return;\n    }\n\n    // Header\n    mark(NEC_HEADER_MARK);\n    space(NEC_HEADER_SPACE);\n\n    // Old version with MSB first Data + stop bit\n    sendPulseDistanceWidthData(NEC_BIT_MARK, NEC_ONE_SPACE, NEC_BIT_MARK, NEC_ZERO_SPACE, data, nbits, PROTOCOL_IS_MSB_FIRST);\n}\n\n/** @}*/\n#if defined(LOCAL_DEBUG)\n#undef LOCAL_DEBUG\n#endif\n#endif // _IR_NEC_HPP\n"
    }, {
      filename: "src/ir_MagiQuest.hpp",
      code: "/*\n * ir_MagiQuest.hpp\n *\n *  Contains functions for receiving and sending MagiQuest Protocol\n *  Based off the Magiquest fork of Arduino-IRremote by mpflaga https://github.com/mpflaga/Arduino-IRremote/\n *\n *  RESULT:\n *  The 31 bit wand ID is available in decodedRawData.\n *  The lower 16 bit of the ID is available in address.\n *  The magnitude is available in command.\n *\n *  This file is part of Arduino-IRremote https://github.com/Arduino-IRremote/Arduino-IRremote.\n *\n ************************************************************************************\n * MIT License\n *\n * Copyright (c) 2017-2023 E. Stuart Hicks <ehicks@binarymagi.com>, Armin Joachimsmeyer\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is furnished\n * to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n ************************************************************************************\n */\n#ifndef _IR_MAGIQUEST_HPP\n#define _IR_MAGIQUEST_HPP\n\n#if defined(DEBUG) && !defined(LOCAL_DEBUG)\n#define LOCAL_DEBUG\n#else\n//#define LOCAL_DEBUG // This enables debug output only for this file\n#endif\n//\n//==============================================================================\n//\n//       M   M   AA    GGG   III   QQQ    U   U  EEEE   SSS  TTTTTT\n//       MM MM  A  A  G       I   Q   Q   U   U  E     S       TT\n//       M M M  AAAA  G  GG   I   Q   Q   U   U  EEE    SSS    TT\n//       M   M  A  A  G   G   I   Q  QQ   U   U  E         S   TT\n//       M   M  A  A   GGG   III   QQQQ    UUU   EEEE  SSSS    TT\n//                                     Q\n//==============================================================================\n/*\n * https://github.com/kitlaan/Arduino-IRremote/blob/master/ir_Magiquest.cpp\n * https://github.com/Arduino-IRremote/Arduino-IRremote/discussions/1027#discussioncomment-3636857\n * https://github.com/Arduino-IRremote/Arduino-IRremote/issues/1015#issuecomment-1222247231\n\n Protocol=MagiQuest Address=0xFF00 Command=0x176 Raw-Data=0x6BCDFF00 56 bits MSB first\n + 250,- 800 + 250,- 850 + 250,- 850 + 250,- 850 // 8 zero start bits\n + 250,- 850 + 300,- 800 + 250,- 850 + 250,- 850\n\n // 31 ID bits\n + 550,- 600 + 550,- 550 + 350,- 800 + 600,- 600 // 110 1 6\n + 200,- 950 + 550,- 600 + 550,- 600 + 550,- 600 // 011 1 B - 1(from above)011 => B\n + 550,- 600 + 250,- 900 + 300,- 850 + 550,- 600 // 100 1 C\n + 550,- 600 + 300,- 850 + 550,- 600 + 550,- 600\n + 550,- 600 + 550,- 600 + 550,- 600 + 550,- 600\n + 550,- 600 + 550,- 600 + 550,- 600 + 300,- 800\n + 350,- 850 + 300,- 850 + 300,- 850 + 300,- 850\n + 300,- 850 + 300,- 850 + 300,- 850 + 550,- 600 // 000 1 - 3 LSB ID bits 000 + 1 MSB magnitude bit 1\n\n // 8 bit magnitude\n + 300,- 850 + 550,- 600 + 550,- 600 + 550,- 600\n + 300,- 850 + 550,- 600 + 550,- 600 + 250,- 900\n\n // Checksum (+ sum of the 5 bytes before == 0)\n + 250,- 900 + 300,- 900 + 250,- 850 + 550,- 600\n + 600,- 550 + 300,- 900 + 250,- 850 + 550\n */\n// MSB first, 8 start bits (zero), 31 wand id bits, 9 magnitude bits 8 checksum bits and no stop bit => 56 bits\n#define MAGIQUEST_CHECKSUM_BITS     8   // magiquest_t.cmd.checksum\n#define MAGIQUEST_MAGNITUDE_BITS    9   // magiquest_t.cmd.magnitude\n#define MAGIQUEST_WAND_ID_BITS     31   // magiquest_t.cmd.wand_id -> wand-id is handled as 32 bit and always even\n#define MAGIQUEST_START_BITS        8    // magiquest_t.cmd.StartBits\n\n#define MAGIQUEST_PERIOD         1150   // Time for a full MagiQuest \"bit\" (1100 - 1200 usec)\n\n#define MAGIQUEST_DATA_BITS     (MAGIQUEST_CHECKSUM_BITS + MAGIQUEST_MAGNITUDE_BITS + MAGIQUEST_WAND_ID_BITS) // 48 Size of the command without the start bits\n#define MAGIQUEST_BITS          (MAGIQUEST_CHECKSUM_BITS + MAGIQUEST_MAGNITUDE_BITS + MAGIQUEST_WAND_ID_BITS + MAGIQUEST_START_BITS) // 56 Size of the command with the start bits\n\n/*\n * 0 = 25% mark & 75% space across 1 period\n *     1150 * 0.25 = 288 usec mark\n *     1150 - 288 = 862 usec space\n * 1 = 50% mark & 50% space across 1 period\n *     1150 * 0.5 = 575 usec mark\n *     1150 - 575 = 575 usec space\n */\n#define MAGIQUEST_UNIT          (MAGIQUEST_PERIOD / 4) // 287.5\n\n#define MAGIQUEST_ONE_MARK      (2 * MAGIQUEST_UNIT) // 576\n#define MAGIQUEST_ONE_SPACE     (2 * MAGIQUEST_UNIT) // 576\n#define MAGIQUEST_ZERO_MARK     MAGIQUEST_UNIT       // 287.5\n#define MAGIQUEST_ZERO_SPACE    (3 * MAGIQUEST_UNIT) // 864\n\n// assume 110 as repeat period\nstruct PulseDistanceWidthProtocolConstants MagiQuestProtocolConstants = { MAGIQUEST, 38, MAGIQUEST_ZERO_MARK, MAGIQUEST_ZERO_SPACE,\nMAGIQUEST_ONE_MARK, MAGIQUEST_ONE_SPACE, MAGIQUEST_ZERO_MARK, MAGIQUEST_ZERO_SPACE, PROTOCOL_IS_MSB_FIRST, 110, NULL };\n//+=============================================================================\n//\n/**\n * @param aWandId       31 bit ID\n * @param aMagnitude    9 bit Magnitude\n */\nvoid IRsend::sendMagiQuest(uint32_t aWandId, uint16_t aMagnitude) {\n\n    // Set IR carrier frequency\n    enableIROut(38);\n\n    aMagnitude &= 0x1FF; // we have 9 bit\n    LongUnion tWandId;\n    tWandId.ULong = aWandId << 1;\n    uint8_t tChecksum = (tWandId.Bytes[0]) + tWandId.Bytes[1] + tWandId.Bytes[2] + tWandId.Bytes[3];\n    tChecksum += aMagnitude + (aMagnitude >> 8);\n    tChecksum = ~tChecksum + 1;\n\n    // 8 start bits\n    sendPulseDistanceWidthData(&MagiQuestProtocolConstants, 0, 8);\n    // 48 bit data\n    sendPulseDistanceWidthData(&MagiQuestProtocolConstants, aWandId, MAGIQUEST_WAND_ID_BITS); // send only 31 bit, do not send MSB here\n    sendPulseDistanceWidthData(&MagiQuestProtocolConstants, aMagnitude, MAGIQUEST_MAGNITUDE_BITS);\n    sendPulseDistanceWidthData(&MagiQuestProtocolConstants, tChecksum, MAGIQUEST_CHECKSUM_BITS);\n#if defined(LOCAL_DEBUG)\n    // must be after sending, in order not to destroy the send timing\n    Serial.print(F(\"MagiQuest checksum=0x\"));\n    Serial.println(tChecksum, HEX);\n#endif\n}\n\n//+=============================================================================\n//\n/*\n * decodes a 56 bit result, which is not really compatible with standard decoder layout\n * magnitude is stored in command\n * 31 bit wand_id is stored in decodedRawData\n * lower 16 bit of wand_id is stored in address\n */\nbool IRrecv::decodeMagiQuest() {\n\n    // Check we have the right amount of data, magnitude and ID bits and 8 start bits + 0 stop bit\n    if (decodedIRData.rawlen != (2 * MAGIQUEST_BITS)) {\n        IR_DEBUG_PRINT(F(\"MagiQuest: \"));\n        IR_DEBUG_PRINT(F(\"Data length=\"));\n        IR_DEBUG_PRINT(decodedIRData.rawlen);\n        IR_DEBUG_PRINTLN(F(\" is not 112\"));\n        return false;\n    }\n\n    /*\n     * Check for 8 zero header bits\n     */\n    if (!decodePulseDistanceWidthData(&MagiQuestProtocolConstants, MAGIQUEST_START_BITS, 1)) {\n#if defined(LOCAL_DEBUG)\n        Serial.print(F(\"MagiQuest: \"));\n        Serial.println(F(\"Start bit decode failed\"));\n#endif\n        return false;\n    }\n    if (decodedIRData.decodedRawData != 0) {\n#if defined(LOCAL_DEBUG)\n        Serial.print(F(\"MagiQuest: \"));\n        Serial.print(F(\"Not 8 leading zero start bits received, RawData=0x\"));\n        Serial.println(decodedIRData.decodedRawData, HEX);\n#endif\n        return false;\n    }\n\n    /*\n     * Decode the 31 bit ID\n     */\n    if (!decodePulseDistanceWidthData(&MagiQuestProtocolConstants, MAGIQUEST_WAND_ID_BITS, (MAGIQUEST_START_BITS * 2) + 1)) {\n#if defined(LOCAL_DEBUG)\n        Serial.print(F(\"MagiQuest: \"));\n        Serial.println(F(\"ID decode failed\"));\n#endif\n        return false;\n    }\n    LongUnion tDecodedRawData;\n#if defined(LOCAL_DEBUG)\n    Serial.print(F(\"31 bit WandId=0x\"));\n    Serial.println(decodedIRData.decodedRawData, HEX);\n#endif\n    uint32_t tWandId = decodedIRData.decodedRawData; // save tWandId for later use\n    tDecodedRawData.ULong = decodedIRData.decodedRawData << 1; // shift for checksum computation\n    uint8_t tChecksum = tDecodedRawData.Bytes[0] + tDecodedRawData.Bytes[1] + tDecodedRawData.Bytes[2] + tDecodedRawData.Bytes[3];\n#if defined(LOCAL_DEBUG)\n    Serial.print(F(\"31 bit WandId=0x\"));\n    Serial.print(decodedIRData.decodedRawData, HEX);\n    Serial.print(F(\" shifted=0x\"));\n    Serial.println(tDecodedRawData.ULong, HEX);\n#endif\n    /*\n     * Decode the 9 bit Magnitude + 8 bit checksum\n     */\n    if (!decodePulseDistanceWidthData(&MagiQuestProtocolConstants, MAGIQUEST_MAGNITUDE_BITS + MAGIQUEST_CHECKSUM_BITS,\n            ((MAGIQUEST_WAND_ID_BITS + MAGIQUEST_START_BITS) * 2) + 1)) {\n#if defined(LOCAL_DEBUG)\n        Serial.print(F(\"MagiQuest: \"));\n        Serial.println(F(\"Magnitude + checksum decode failed\"));\n#endif\n        return false;\n    }\n\n#if defined(LOCAL_DEBUG)\n    Serial.print(F(\"Magnitude + checksum=0x\"));\n    Serial.println(decodedIRData.decodedRawData, HEX);\n#endif\n    tDecodedRawData.ULong = decodedIRData.decodedRawData;\n    decodedIRData.command = tDecodedRawData.UBytes[1] | tDecodedRawData.UBytes[2] << 8; // Values observed are 0x102,01,04,37,05,38,2D| 02,06,04|03,103,12,18,0E|09\n\n    tChecksum += tDecodedRawData.UBytes[2] /* only one bit */+ tDecodedRawData.UBytes[1] + tDecodedRawData.UBytes[0];\n    if (tChecksum != 0) {\n        decodedIRData.flags |= IRDATA_FLAGS_PARITY_FAILED;\n#if defined(LOCAL_DEBUG)\n        Serial.print(F(\"Checksum 0x\"));\n        Serial.print(tChecksum, HEX);\n        Serial.println(F(\" is not 0\"));\n#endif\n    }\n\n    // Success\n    decodedIRData.decodedRawData = tWandId;     // 31 bit wand_id\n    decodedIRData.address = tWandId;            // lower 16 bit of wand_id\n    decodedIRData.extra = tWandId >> 16;        // upper 15 bit of wand_id\n\n    decodedIRData.protocol = MAGIQUEST;\n    decodedIRData.numberOfBits = MAGIQUEST_BITS;\n    decodedIRData.flags = IRDATA_FLAGS_IS_MSB_FIRST;\n\n    return true;\n}\n#if defined(LOCAL_DEBUG)\n#undef LOCAL_DEBUG\n#endif\n#endif // _IR_MAGIQUEST_HPP\n"
    }, {
      filename: "src/ir_Samsung.hpp",
      code: "/*\n * ir_Samsung.hpp\n *\n *  Contains functions for receiving and sending Samsung IR Protocol in \"raw\" and standard format with 16 bit address and 16 or 32 bit command\n *\n *  This file is part of Arduino-IRremote https://github.com/Arduino-IRremote/Arduino-IRremote.\n *\n ************************************************************************************\n * MIT License\n *\n * Copyright (c) 2017-2024 Darryl Smith, Armin Joachimsmeyer\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is furnished\n * to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONSAMSUNGTION WITH THE SOFTWARE\n * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n ************************************************************************************\n */\n#ifndef _IR_SAMSUNG_HPP\n#define _IR_SAMSUNG_HPP\n\n#if defined(DEBUG) && !defined(LOCAL_DEBUG)\n#define LOCAL_DEBUG\n#else\n//#define LOCAL_DEBUG // This enables debug output only for this file\n#endif\n\n/** \\addtogroup Decoder Decoders and encoders for different protocols\n * @{\n */\n//==============================================================================\n//              SSSS   AAA    MMM    SSSS  U   U  N   N   GGGG\n//             S      A   A  M M M  S      U   U  NN  N  G\n//              SSS   AAAAA  M M M   SSS   U   U  N N N  G  GG\n//                 S  A   A  M   M      S  U   U  N  NN  G   G\n//             SSSS   A   A  M   M  SSSS    UUU   N   N   GGG\n//==============================================================================\n/*\n * Address=0xFFF1 Command=0x76 Raw-Data=0x8976FFF1\n +4500,-4400\n + 600,-1600 + 650,- 500 + 600,- 500 + 650,- 500\n + 600,-1650 + 600,-1600 + 650,-1600 + 600,-1650\n + 600,-1600 + 600,-1650 + 600,-1650 + 600,-1600\n + 600,-1650 + 600,-1650 + 600,-1600 + 600,-1650\n + 600,- 500 + 650,-1600 + 600,-1650 + 600,- 500\n + 650,-1600 + 600,-1650 + 600,-1650 + 600,- 500\n + 600,-1650 + 600,- 500 + 600,- 550 + 600,-1600\n + 600,- 550 + 600,- 550 + 550,- 550 + 600,-1650\n + 550\n Sum: 68750\n */\n/*\n * Samsung repeat frame can be the original frame again or a special short repeat frame,\n * then we call the protocol SamsungLG. They differ only in the handling of repeat,\n * so we can not decide for the first frame which protocol is used.\n */\n// see http://www.hifi-remote.com/wiki/index.php?title=DecodeIR#Samsung\n// https://www.mikrocontroller.net/articles/IRMP_-_english#SAMSUNG32\n// https://www.mikrocontroller.net/articles/IRMP_-_english#SAMSUNG48\n// LSB first, 1 start bit + 16 bit address + 16 or 32 bit data + 1 stop bit.\n// Here https://forum.arduino.cc/t/klimaanlage-per-ir-steuern/1051381/10 the address (0xB24D) is also 8 bits and then 8 inverted bits\n//\n// Here https://github.com/flipperdevices/flipperzero-firmware/blob/master/lib/infrared/encoder_decoder/samsung/infrared_decoder_samsung.c#L18\n// Address is 8 bit + same 8 bit if data is 8 bit and ~8 bit.\n//\n// IRP notation: {38k,5553}<1,-1|1,-3>(8,-8,D:8,S:8,F:8,~F:8,1,^110)+  ==> 8 bit + 8 bit inverted data - Samsung32\n// IRP notation: {38k,5553}<1,-1|1,-3>(8,-8,D:8,S:8,F:16,1,^110)+  ==> 16 bit data - still Samsung32\n// IRP notation: {38k,5553}<1,-1|1,-3>(8,-8,D:8,S:8,F:8,~F:8,G:8,~G:8,1,^110)+  ==> 2 x (8 bit + 8 bit inverted data) - Samsung48\n//\n#define SAMSUNG_ADDRESS_BITS        16\n#define SAMSUNG_COMMAND16_BITS      16\n#define SAMSUNG_COMMAND32_BITS      32\n#define SAMSUNG_BITS                (SAMSUNG_ADDRESS_BITS + SAMSUNG_COMMAND16_BITS)\n#define SAMSUNG48_BITS              (SAMSUNG_ADDRESS_BITS + SAMSUNG_COMMAND32_BITS)\n\n// except SAMSUNG_HEADER_MARK, values are like NEC\n#define SAMSUNG_UNIT                560             // 21.28 periods of 38 kHz, 11.2 ticks TICKS_LOW = 8.358 TICKS_HIGH = 15.0\n#define SAMSUNG_HEADER_MARK         (8 * SAMSUNG_UNIT) // 4500 | 180 periods\n#define SAMSUNG_HEADER_SPACE        (8 * SAMSUNG_UNIT) // 4500\n#define SAMSUNG_BIT_MARK            SAMSUNG_UNIT\n#define SAMSUNG_ONE_SPACE           (3 * SAMSUNG_UNIT) // 1690 | 33.8  TICKS_LOW = 25.07 TICKS_HIGH = 45.0\n#define SAMSUNG_ZERO_SPACE          SAMSUNG_UNIT\n\n#define SAMSUNG_AVERAGE_DURATION    55000 // SAMSUNG_HEADER_MARK + SAMSUNG_HEADER_SPACE  + 32 * 2,5 * SAMSUNG_UNIT + SAMSUNG_UNIT // 2.5 because we assume more zeros than ones\n#define SAMSUNG_REPEAT_DURATION     (SAMSUNG_HEADER_MARK  + SAMSUNG_HEADER_SPACE + SAMSUNG_BIT_MARK + SAMSUNG_ZERO_SPACE + SAMSUNG_BIT_MARK)\n#define SAMSUNG_REPEAT_PERIOD       110000 // Commands are repeated every 110 ms (measured from start to start) for as long as the key on the remote control is held down.\n#define SAMSUNG_MAXIMUM_REPEAT_DISTANCE     (SAMSUNG_REPEAT_PERIOD + (SAMSUNG_REPEAT_PERIOD / 4)) // 137000 - Just a guess\n\nstruct PulseDistanceWidthProtocolConstants SamsungProtocolConstants = { SAMSUNG, SAMSUNG_KHZ, SAMSUNG_HEADER_MARK,\nSAMSUNG_HEADER_SPACE, SAMSUNG_BIT_MARK, SAMSUNG_ONE_SPACE, SAMSUNG_BIT_MARK, SAMSUNG_ZERO_SPACE, PROTOCOL_IS_LSB_FIRST,\n        (SAMSUNG_REPEAT_PERIOD / MICROS_IN_ONE_MILLI), NULL };\n\nstruct PulseDistanceWidthProtocolConstants SamsungLGProtocolConstants = { SAMSUNGLG, SAMSUNG_KHZ, SAMSUNG_HEADER_MARK,\nSAMSUNG_HEADER_SPACE, SAMSUNG_BIT_MARK, SAMSUNG_ONE_SPACE, SAMSUNG_BIT_MARK, SAMSUNG_ZERO_SPACE, PROTOCOL_IS_LSB_FIRST,\n        (SAMSUNG_REPEAT_PERIOD / MICROS_IN_ONE_MILLI), &sendSamsungLGSpecialRepeat };\n/************************************\n * Start of send and decode functions\n ************************************/\n\n/**\n * Send repeat\n * Repeat commands should be sent in a 110 ms raster.\n * This repeat was sent by an LG 6711R1P071A remote\n */\nvoid IRsend::sendSamsungLGRepeat() {\n    enableIROut (SAMSUNG_KHZ);       // 38 kHz\n    mark(SAMSUNG_HEADER_MARK);      // + 4500\n    space(SAMSUNG_HEADER_SPACE);    // - 4500\n    mark(SAMSUNG_BIT_MARK);         // + 560\n    space(SAMSUNG_ZERO_SPACE);      // - 560\n    mark(SAMSUNG_BIT_MARK);         // + 560\n}\n\n/**\n * Like above, but implemented as a static function\n * Used for sending special repeat frame.\n * For use in ProtocolConstants. Saves up to 250 bytes compared to a member function.\n */\nvoid sendSamsungLGSpecialRepeat() {\n    IrSender.enableIROut(SAMSUNG_KHZ);      // 38 kHz\n    IrSender.mark(SAMSUNG_HEADER_MARK);     // + 4500\n    IrSender.space(SAMSUNG_HEADER_SPACE);   // - 4500\n    IrSender.mark(SAMSUNG_BIT_MARK);        // + 560\n    IrSender.space(SAMSUNG_ZERO_SPACE);     // - 560\n    IrSender.mark(SAMSUNG_BIT_MARK);        // + 560\n}\n\n/*\n * Sent e.g. by an LG 6711R1P071A remote\n * @param aNumberOfRepeats If < 0 then only a special repeat frame will be sent\n */\nvoid IRsend::sendSamsungLG(uint16_t aAddress, uint16_t aCommand, int_fast8_t aNumberOfRepeats) {\n    if (aNumberOfRepeats < 0) {\n        sendSamsungLGRepeat();\n        return;\n    }\n\n    // send 16 bit address and  8 command bits and then 8 inverted command bits LSB first\n    LongUnion tRawData;\n    tRawData.UWord.LowWord = aAddress;\n    tRawData.UByte.MidHighByte = aCommand;\n    tRawData.UByte.HighByte = ~aCommand;\n\n    sendPulseDistanceWidth(&SamsungLGProtocolConstants, tRawData.ULong, SAMSUNG_BITS, aNumberOfRepeats);\n}\n\n/**\n * Here we send Samsung32\n * If we get a command < 0x100, we send command and then ~command\n * If we get an address < 0x100, we send address and then address again, this makes it flipper IRDB compatible\n * !!! Be aware, that this is flexible, but makes it impossible to send e.g. 0x0042 as 16 bit value!!!\n * @param aNumberOfRepeats If < 0 then only a special repeat frame will be sent\n */\nvoid IRsend::sendSamsung(uint16_t aAddress, uint16_t aCommand, int_fast8_t aNumberOfRepeats) {\n\n    LongUnion tSendValue;\n    if (aAddress < 0x100) {\n        // This makes it flipper IRDB compatible\n        // https://github.com/flipperdevices/flipperzero-firmware/blob/master/lib/infrared/encoder_decoder/samsung/infrared_decoder_samsung.c#L18\n        // Duplicate address byte, if data is 8 bit and 8 bit inverted and address is 8bit\n        tSendValue.UBytes[1] = aAddress;\n        tSendValue.UBytes[0] = aAddress;\n    } else {\n        tSendValue.UWords[0] = aAddress;\n    }\n\n    if (aCommand < 0x100) {\n        // Send 8 command bits and then 8 inverted command bits LSB first\n        tSendValue.UBytes[2] = aCommand;\n        tSendValue.UBytes[3] = ~aCommand;\n\n    } else {\n        // Send 16 command bits\n        tSendValue.UWords[1] = aCommand;\n    }\n\n    sendPulseDistanceWidth(&SamsungProtocolConstants, tSendValue.ULong, SAMSUNG_BITS, aNumberOfRepeats);\n}\n\n/**\n * Maybe no one needs it in the wild...\n * As above, but we are able to send e.g. 0x0042 as 16 bit address\n * @param aNumberOfRepeats If < 0 then only a special repeat frame will be sent\n */\nvoid IRsend::sendSamsung16BitAddressAndCommand(uint16_t aAddress, uint16_t aCommand, int_fast8_t aNumberOfRepeats) {\n\n    LongUnion tSendValue;\n    // send 16 bit address\n    tSendValue.UWords[0] = aAddress;\n    // Send 16 command bits\n    tSendValue.UWords[1] = aCommand;\n\n    sendPulseDistanceWidth(&SamsungProtocolConstants, tSendValue.ULong, SAMSUNG_BITS, aNumberOfRepeats);\n}\n\n/**\n * Here we send Samsung48\n * We send 2 x (8 bit command and then ~command)\n */\nvoid IRsend::sendSamsung48(uint16_t aAddress, uint32_t aCommand, int_fast8_t aNumberOfRepeats) {\n\n    // send 16 bit address and 2 x ( 8 command bits and then 8 inverted command bits) LSB first\n#if __INT_WIDTH__ < 32\n    uint32_t tRawSamsungData[2]; // prepare 2 long for Samsung48\n\n    LongUnion tSendValue;\n    tSendValue.UWords[0] = aAddress;\n    tSendValue.UBytes[2] = aCommand;\n    tSendValue.UBytes[3] = ~aCommand;\n    uint8_t tUpper8BitsOfCommand = aCommand >> 8;\n    tRawSamsungData[1] = tUpper8BitsOfCommand | (~tUpper8BitsOfCommand) << 8;\n    tRawSamsungData[0] = tSendValue.ULong;\n\n    sendPulseDistanceWidthFromArray(&SamsungProtocolConstants, &tRawSamsungData[0], SAMSUNG48_BITS, aNumberOfRepeats);\n#else\n    LongLongUnion tSendValue;\n    tSendValue.UWords[0] = aAddress;\n    if (aCommand < 0x10000) {\n        tSendValue.UBytes[2] = aCommand;\n        tSendValue.UBytes[3] = ~aCommand;\n        uint8_t tUpper8BitsOfCommand = aCommand >> 8;\n        tSendValue.UBytes[4] = tUpper8BitsOfCommand;\n        tSendValue.UBytes[5] = ~tUpper8BitsOfCommand;\n    } else {\n        tSendValue.ULongLong = aAddress | aCommand << 16;\n    }\n    sendPulseDistanceWidth(&SamsungProtocolConstants, tSendValue.ULongLong, SAMSUNG48_BITS, aNumberOfRepeats);\n#endif\n}\n\nbool IRrecv::decodeSamsung() {\n\n    // Check we have enough data (68). The +4 is for initial gap, start bit mark and space + stop bit mark\n    if (decodedIRData.rawlen != ((2 * SAMSUNG_BITS) + 4) && decodedIRData.rawlen != ((2 * SAMSUNG48_BITS) + 4)\n            && (decodedIRData.rawlen != 6)) {\n        IR_DEBUG_PRINT(F(\"Samsung: \"));\n        IR_DEBUG_PRINT(F(\"Data length=\"));\n        IR_DEBUG_PRINT(decodedIRData.rawlen);\n        IR_DEBUG_PRINTLN(F(\" is not 6 or 68 or 100\"));\n        return false;\n    }\n\n    if (!checkHeader(&SamsungProtocolConstants)) {\n        return false;\n    }\n\n    // Check for SansungLG style repeat\n    if (decodedIRData.rawlen == 6) {\n        decodedIRData.flags = IRDATA_FLAGS_IS_REPEAT | IRDATA_FLAGS_IS_PROTOCOL_WITH_DIFFERENT_REPEAT | IRDATA_FLAGS_IS_LSB_FIRST;\n        decodedIRData.address = lastDecodedAddress;\n        decodedIRData.command = lastDecodedCommand;\n        decodedIRData.protocol = SAMSUNGLG;\n        return true;\n    }\n\n    /*\n     * Decode first 32 bits\n     */\n    if (!decodePulseDistanceWidthData(&SamsungProtocolConstants, SAMSUNG_BITS, 3)) {\n#if defined(LOCAL_DEBUG)\n        Serial.print(F(\"Samsung: \"));\n        Serial.println(F(\"Decode failed\"));\n#endif\n        return false;\n    }\n    LongUnion tValue;\n    tValue.ULong = decodedIRData.decodedRawData;\n    decodedIRData.address = tValue.UWord.LowWord;\n\n    if (decodedIRData.rawlen == (2 * SAMSUNG48_BITS) + 4) {\n        /*\n         * Samsung48\n         */\n        // decode additional 16 bit\n        if (!decodePulseDistanceWidthData(&SamsungProtocolConstants, (SAMSUNG_COMMAND32_BITS - SAMSUNG_COMMAND16_BITS),\n                3 + (2 * SAMSUNG_BITS))) {\n#if defined(LOCAL_DEBUG)\n            Serial.print(F(\"Samsung: \"));\n            Serial.println(F(\"Decode failed\"));\n#endif\n            return false;\n        }\n\n        /*\n         * LSB data is already in tValue.UWord.HighWord!\n         * Put latest (MSB) bits in LowWord, LSB first would have them expect in HighWord so keep this in mind for decoding below\n         */\n        tValue.UWord.LowWord = decodedIRData.decodedRawData; // We have only 16 bit in decodedRawData here\n#if __INT_WIDTH__ >= 32\n        // workaround until complete refactoring for 64 bit\n        decodedIRData.decodedRawData = (decodedIRData.decodedRawData << 32)| tValue.UWord.HighWord << 16 | decodedIRData.address; // store all 48 bits in decodedRawData\n#endif\n\n        /*\n         * Check parity of 32 bit command\n         */\n        // receive 2 * (8 bits then 8 inverted bits) LSB first\n        if (tValue.UByte.MidHighByte != (uint8_t)(~tValue.UByte.HighByte)\n                && tValue.UByte.LowByte != (uint8_t)(~tValue.UByte.MidLowByte)) {\n            decodedIRData.flags = IRDATA_FLAGS_PARITY_FAILED | IRDATA_FLAGS_IS_LSB_FIRST;\n        }\n\n        decodedIRData.command = tValue.UByte.LowByte << 8 | tValue.UByte.MidHighByte; // low and high word are swapped here, so fetch it this way\n        decodedIRData.numberOfBits = SAMSUNG48_BITS;\n        decodedIRData.protocol = SAMSUNG48;\n\n    } else {\n        /*\n         * Samsung32\n         */\n        if (tValue.UByte.MidHighByte == (uint8_t)(~tValue.UByte.HighByte)) {\n            // 8 bit command (and address) protocol\n            decodedIRData.command = tValue.UByte.MidHighByte; // first 8 bit\n            decodedIRData.address = tValue.UByte.MidLowByte;  // assume LowByte == MidLowByte\n        } else {\n            // 16 bit command protocol\n            decodedIRData.command = tValue.UWord.HighWord; // first 16 bit\n        }\n        decodedIRData.numberOfBits = SAMSUNG_BITS;\n        decodedIRData.protocol = SAMSUNG;\n    }\n\n    // check for repeat\n    checkForRepeatSpaceTicksAndSetFlag(SAMSUNG_MAXIMUM_REPEAT_DISTANCE / MICROS_PER_TICK);\n\n    return true;\n}\n\n// Old version with MSB first\nbool IRrecv::decodeSAMSUNG(decode_results *aResults) {\n    unsigned int offset = 1;  // Skip first space\n\n    // Initial mark\n    if (!matchMark(aResults->rawbuf[offset], SAMSUNG_HEADER_MARK)) {\n        return false;\n    }\n    offset++;\n\n    // Check for repeat -- like a NEC repeat\n    if ((aResults->rawlen == 4) && matchSpace(aResults->rawbuf[offset], 2250)\n            && matchMark(aResults->rawbuf[offset + 1], SAMSUNG_BIT_MARK)) {\n        aResults->bits = 0;\n        aResults->value = 0xFFFFFFFF;\n        decodedIRData.flags = IRDATA_FLAGS_IS_REPEAT;\n        decodedIRData.protocol = SAMSUNG;\n        return true;\n    }\n    if (aResults->rawlen < (2 * SAMSUNG_BITS) + 4) {\n        return false;\n    }\n\n    // Initial space\n    if (!matchSpace(aResults->rawbuf[offset], SAMSUNG_HEADER_SPACE)) {\n        return false;\n    }\n    offset++;\n\n    if (!decodePulseDistanceWidthData(SAMSUNG_BITS, offset, SAMSUNG_BIT_MARK, 0, SAMSUNG_ONE_SPACE, SAMSUNG_ZERO_SPACE,\n            PROTOCOL_IS_MSB_FIRST)) {\n        return false;\n    }\n\n    // Success\n    aResults->value = decodedIRData.decodedRawData;\n    aResults->bits = SAMSUNG_BITS;\n    aResults->decode_type = SAMSUNG;\n    decodedIRData.protocol = SAMSUNG;\n    return true;\n}\n\n// Old version with MSB first\nvoid IRsend::sendSAMSUNG(unsigned long data, int nbits) {\n    // Set IR carrier frequency\n    enableIROut (SAMSUNG_KHZ);\n\n    // Header\n    mark(SAMSUNG_HEADER_MARK);\n    space(SAMSUNG_HEADER_SPACE);\n\n    // Old version with MSB first Data + stop bit\n    sendPulseDistanceWidthData(SAMSUNG_BIT_MARK, SAMSUNG_ONE_SPACE, SAMSUNG_BIT_MARK, SAMSUNG_ZERO_SPACE, data, nbits,\n            PROTOCOL_IS_MSB_FIRST);\n}\n\n/** @}*/\n#if defined(LOCAL_DEBUG)\n#undef LOCAL_DEBUG\n#endif\n#endif // _IR_SAMSUNG_HPP\n"
    }, {
      filename: "src/ir_Sony.hpp",
      code: "/*\n * ir_Sony.hpp\n *\n *  Contains functions for receiving and sending SIRCS/Sony IR Protocol in \"raw\" and standard format with 5 bit address 7 bit command\n *\n *  This file is part of Arduino-IRremote https://github.com/Arduino-IRremote/Arduino-IRremote.\n *\n ************************************************************************************\n * MIT License\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is furnished\n * to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n ************************************************************************************\n */\n#ifndef _IR_SONY_HPP\n#define _IR_SONY_HPP\n\n#if defined(DEBUG) && !defined(LOCAL_DEBUG)\n#define LOCAL_DEBUG\n#else\n//#define LOCAL_DEBUG // This enables debug output only for this file\n#endif\n\n/** \\addtogroup Decoder Decoders and encoders for different protocols\n * @{\n */\n//==============================================================================\n//                           SSSS   OOO   N   N  Y   Y\n//                          S      O   O  NN  N   Y Y\n//                           SSS   O   O  N N N    Y\n//                              S  O   O  N  NN    Y\n//                          SSSS    OOO   N   N    Y\n//==============================================================================\n/*\n * Protocol=Sony Address=0x4B9 Command=0x7 Raw-Data=0x25C87 20 bits LSB first\n +2550,- 400\n // 7 command bits\n +1300,- 450 +1350,- 450 +1300,- 450 + 700,- 450\n + 700,- 450 + 750,- 450 + 700,- 400\n // (5,8,) 13 address bits\n +1300,- 500\n + 700,- 450 + 700,- 450 +1300,- 500 +1300,- 450\n +1300,- 450 + 700,- 450 +1350,- 400 + 750,- 450\n + 700,- 450 +1300,- 450 + 700,- 450 + 700\n Sum: 31100\n */\n/*\n * Sony is the only protocol using the pulse width encoding, which requires no stop bit\n */\n// see https://www.sbprojects.net/knowledge/ir/sirc.php\n// https://www.mikrocontroller.net/articles/IRMP_-_english#SIRCS\n// Frames are repeated every 45ms (measured from start to start) for as long as the key on the remote control is held down.\n// This leads to a 15 ms gap for a Sony20 protocol!\n// Here http://picprojects.org.uk/projects/sirc/ it is claimed, that many Sony remotes send each frame a minimum of 3 times. But 1 repeat (2 sends) has also been seen in real life.\n// LSB first, start bit + 7 command + 5 to 13 address, no stop bit\n// IRP: Sony12 {40k,600}<1,-1|2,-1>(4,-1,F:7,D:5,^45m)+ ==> 40 kHz, Unit is 600, LSB, One mark is 2 units, Start bit is 4 units, 7 bit Function, 5 bit Device, no Stop bit, every 45 milliseconds\n// IRP: Sony15 {40k,600}<1,-1|2,-1>(4,-1,F:7,D:8,^45m)+ ==> 8 bit Device\n// IRP: Sony20 {40k,600}<1,-1|2,-1>(4,-1,F:7,D:5,S:8,^45m)+ ==> 5 bit Device, 8 bit Subdevice\n//\n#define SONY_ADDRESS_BITS       5\n#define SONY_COMMAND_BITS       7\n#define SONY_EXTRA_BITS         8\n#define SONY_BITS_MIN           (SONY_COMMAND_BITS + SONY_ADDRESS_BITS)        // 12 bits\n#define SONY_BITS_15            (SONY_COMMAND_BITS + SONY_ADDRESS_BITS + 3)    // 15 bits\n#define SONY_BITS_MAX           (SONY_COMMAND_BITS + SONY_ADDRESS_BITS + SONY_EXTRA_BITS)    // 20 bits == SIRCS_20_PROTOCOL\n#define SONY_UNIT               600 // 24 periods of 40kHz\n\n#define SONY_HEADER_MARK        (4 * SONY_UNIT) // 2400\n#define SONY_ONE_MARK           (2 * SONY_UNIT) // 1200\n#define SONY_ZERO_MARK          SONY_UNIT\n#define SONY_SPACE              SONY_UNIT\n\n#define SONY_AVERAGE_DURATION_MIN   21000 // SONY_HEADER_MARK + SONY_SPACE  + 12 * 2,5 * SONY_UNIT  // 2.5 because we assume more zeros than ones\n#define SONY_AVERAGE_DURATION_MAX   33000 // SONY_HEADER_MARK + SONY_SPACE  + 20 * 2,5 * SONY_UNIT  // 2.5 because we assume more zeros than ones\n#define SONY_REPEAT_PERIOD          45000 // Commands are repeated every 45 ms (measured from start to start) for as long as the key on the remote control is held down.\n#define SONY_MAXIMUM_REPEAT_DISTANCE    (SONY_REPEAT_PERIOD - SONY_AVERAGE_DURATION_MIN) // 24 ms\n\nstruct PulseDistanceWidthProtocolConstants SonyProtocolConstants = { SONY, SONY_KHZ, SONY_HEADER_MARK, SONY_SPACE, SONY_ONE_MARK,\nSONY_SPACE, SONY_ZERO_MARK, SONY_SPACE, PROTOCOL_IS_LSB_FIRST, (SONY_REPEAT_PERIOD / MICROS_IN_ONE_MILLI), NULL };\n\n/************************************\n * Start of send and decode functions\n ************************************/\n\n/**\n * @param numberOfBits should be one of SIRCS_12_PROTOCOL, SIRCS_15_PROTOCOL, SIRCS_20_PROTOCOL. Not checked! 20 -> send 13 address bits\n */\nvoid IRsend::sendSony(uint16_t aAddress, uint8_t aCommand, int_fast8_t aNumberOfRepeats, uint8_t numberOfBits) {\n    uint32_t tData = (uint32_t) aAddress << 7 | (aCommand & 0x7F);\n    // send 5, 8, 13 address bits LSB first\n    sendPulseDistanceWidth(&SonyProtocolConstants, tData, numberOfBits, aNumberOfRepeats);\n}\n\nbool IRrecv::decodeSony() {\n\n    if (!checkHeader(&SonyProtocolConstants)) {\n        return false;\n    }\n\n    // Check we have enough data. +2 for initial gap and start bit mark and space minus the last/MSB space. NO stop bit! 26, 32, 42\n    if (decodedIRData.rawlen != (2 * SONY_BITS_MIN) + 2 && decodedIRData.rawlen != (2 * SONY_BITS_MAX) + 2\n            && decodedIRData.rawlen != (2 * SONY_BITS_15) + 2) {\n        IR_DEBUG_PRINT(F(\"Sony: \"));\n        IR_DEBUG_PRINT(F(\"Data length=\"));\n        IR_DEBUG_PRINT(decodedIRData.rawlen);\n        IR_DEBUG_PRINTLN(F(\" is not 12, 15 or 20\"));\n        return false;\n    }\n\n    if (!decodePulseDistanceWidthData(&SonyProtocolConstants, (decodedIRData.rawlen - 1) / 2, 3)) {\n#if defined(LOCAL_DEBUG)\n        Serial.print(F(\"Sony: \"));\n        Serial.println(F(\"Decode failed\"));\n#endif\n        return false;\n    }\n\n    // Success\n//    decodedIRData.flags = IRDATA_FLAGS_IS_LSB_FIRST; // Not required, since this is the start value\n    decodedIRData.command = decodedIRData.decodedRawData & 0x7F;  // first 7 bits\n    decodedIRData.address = decodedIRData.decodedRawData >> 7;    // next 5 or 8 or 13 bits\n    decodedIRData.numberOfBits = (decodedIRData.rawlen - 1) / 2;\n    decodedIRData.protocol = SONY;\n\n    //Check for repeat\n    checkForRepeatSpaceTicksAndSetFlag(SONY_MAXIMUM_REPEAT_DISTANCE / MICROS_PER_TICK);\n\n    return true;\n}\n\n/*********************************************************************************\n * Old deprecated functions, kept for backward compatibility to old 2.0 tutorials\n *********************************************************************************/\n\n/*\n * Old version with MSB first data\n */\n#define SONY_DOUBLE_SPACE_USECS    500 // usually see 713 - not using ticks as get number wrap around\nbool IRrecv::decodeSonyMSB(decode_results *aResults) {\n    long data = 0;\n    uint8_t bits = 0;\n    unsigned int offset = 0;  // Dont skip first space, check its size\n\n    if (aResults->rawlen < (2 * SONY_BITS_MIN) + 2) {\n        return false;\n    }\n\n    // Some Sony's deliver repeats fast after first\n    // unfortunately can't spot difference from of repeat from two fast clicks\n    if (aResults->rawbuf[0] < (SONY_DOUBLE_SPACE_USECS / MICROS_PER_TICK)) {\n#if defined(LOCAL_DEBUG)\n        Serial.println(F(\"IR Gap found\"));\n#endif\n        aResults->bits = 0;\n        aResults->value = 0xFFFFFFFF;\n        decodedIRData.flags = IRDATA_FLAGS_IS_REPEAT;\n        decodedIRData.protocol = SONY;\n        return true;\n    }\n    offset++;\n\n    // Check header \"mark\"\n    if (!matchMark(aResults->rawbuf[offset], SONY_HEADER_MARK)) {\n        return false;\n    }\n    offset++;\n\n    // MSB first - Not compatible to standard, which says LSB first :-(\n    while (offset + 1 < aResults->rawlen) {\n\n        // First check for the constant space length, we do not have a space at the end of raw data\n        // we are lucky, since the start space is equal the data space.\n        if (!matchSpace(aResults->rawbuf[offset], SONY_SPACE)) {\n            return false;\n        }\n        offset++;\n\n        // bit value is determined by length of the mark\n        if (matchMark(aResults->rawbuf[offset], SONY_ONE_MARK)) {\n            data = (data << 1) | 1;\n        } else if (matchMark(aResults->rawbuf[offset], SONY_ZERO_MARK)) {\n            data = (data << 1) | 0;\n        } else {\n            return false;\n        }\n        offset++;\n        bits++;\n\n    }\n\n    aResults->bits = bits;\n    aResults->value = data;\n    aResults->decode_type = SONY;\n    decodedIRData.protocol = SONY;\n    return true;\n}\n\n/**\n * Old version with MSB first data\n */\nvoid IRsend::sendSony(unsigned long data, int nbits) {\n    // Set IR carrier frequency\n    enableIROut (SONY_KHZ);\n\n    // Header\n    mark(SONY_HEADER_MARK);\n    space(SONY_SPACE);\n\n    // Old version with MSB first Data\n    sendPulseDistanceWidthData(SONY_ONE_MARK, SONY_SPACE, SONY_ZERO_MARK, SONY_SPACE, data, nbits, PROTOCOL_IS_MSB_FIRST);\n}\n\n/** @}*/\n#if defined(LOCAL_DEBUG)\n#undef LOCAL_DEBUG\n#endif\n#endif // _IR_SONY_HPP\n"
    }, {
      filename: "src/ir_JVC.hpp",
      code: "/*\n * ir_JVC.hpp\n *\n *  Contains functions for receiving and sending JVC IR Protocol in \"raw\" and standard format with 8 bit address and 8 bit command\n *\n *  This file is part of Arduino-IRremote https://github.com/Arduino-IRremote/Arduino-IRremote.\n *\n ************************************************************************************\n * MIT License\n *\n * Copyright (c) 2017-2023 Kristian Lauszus, Armin Joachimsmeyer\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is furnished\n * to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n ************************************************************************************\n */\n#ifndef _IR_JVC_HPP\n#define _IR_JVC_HPP\n\n#if defined(DEBUG) && !defined(LOCAL_DEBUG)\n#define LOCAL_DEBUG\n#else\n//#define LOCAL_DEBUG // This enables debug output only for this file\n#endif\n\n/** \\addtogroup Decoder Decoders and encoders for different protocols\n * @{\n */\n//==============================================================================\n//                             JJJJJ  V   V   CCCC\n//                               J    V   V  C\n//                               J     V V   C\n//                             J J     V V   C\n//                              J       V     CCCC\n//==============================================================================\n/*\n +8400,-4150\n + 550,-1550 + 550,- 500 + 550,- 500 + 550,- 500\n + 550,-1500 + 600,-1500 + 600,-1500 + 550,-1550\n + 550,- 500 + 550,-1550 + 550,-1550 + 550,- 500\n + 500,-1600 + 550,-1550 + 550,-1500 + 600,- 500\n + 550\n Sum: 40350\n */\n// https://www.sbprojects.net/knowledge/ir/jvc.php\n// http://www.hifi-remote.com/johnsfine/DecodeIR.html#JVC\n// IRP: {38k,525}<1,-1|1,-3>(16,-8,(D:8,F:8,1,-45)+)\n// LSB first, 1 start bit + 8 bit address + 8 bit command + 1 stop bit.\n// The JVC protocol repeats by skipping the header mark and space -> this leads to a poor repeat detection for JVC protocol.\n// Some JVC devices require to send 3 repeats. https://github.com/Arduino-IRremote/Arduino-IRremote/issues/21\n#define JVC_ADDRESS_BITS      8 // 8 bit address\n#define JVC_COMMAND_BITS      8 // Command\n\n#define JVC_BITS              (JVC_ADDRESS_BITS + JVC_COMMAND_BITS) // 16 - The number of bits in the protocol\n#define JVC_UNIT              526 // 20 periods of 38 kHz (526.315789)\n\n#define JVC_HEADER_MARK       (16 * JVC_UNIT) // 8400\n#define JVC_HEADER_SPACE      (8 * JVC_UNIT)  // 4200\n\n#define JVC_BIT_MARK          JVC_UNIT        // The length of a Bit:Mark\n#define JVC_ONE_SPACE         (3 * JVC_UNIT)  // 1578 - The length of a Bit:Space for 1's\n#define JVC_ZERO_SPACE        JVC_UNIT        // The length of a Bit:Space for 0's\n\n#define JVC_REPEAT_DISTANCE   (uint16_t)(45 * JVC_UNIT)  // 23625 - Commands are repeated with a distance of 23 ms for as long as the key on the remote control is held down.\n#define JVC_REPEAT_PERIOD     65000 // assume around 40 ms for a JVC frame. JVC IR Remotes: RM-SA911U, RM-SX463U have 45 ms period\n\nstruct PulseDistanceWidthProtocolConstants JVCProtocolConstants = { JVC, JVC_KHZ, JVC_HEADER_MARK, JVC_HEADER_SPACE, JVC_BIT_MARK,\nJVC_ONE_SPACE, JVC_BIT_MARK, JVC_ZERO_SPACE, PROTOCOL_IS_LSB_FIRST, (JVC_REPEAT_PERIOD / MICROS_IN_ONE_MILLI), NULL };\n\n/************************************\n * Start of send and decode functions\n ************************************/\n\n/**\n * The JVC protocol repeats by skipping the header mark and space -> this leads to a poor repeat detection for JVC protocol.\n */\nvoid IRsend::sendJVC(uint8_t aAddress, uint8_t aCommand, int_fast8_t aNumberOfRepeats) {\n    // Set IR carrier frequency\n    enableIROut (JVC_KHZ); // 38 kHz\n\n    if (aNumberOfRepeats < 0) {\n        // The JVC protocol repeats by skipping the header.\n        aNumberOfRepeats = 0;\n    } else {\n        mark(JVC_HEADER_MARK);\n        space(JVC_HEADER_SPACE);\n    }\n\n    uint_fast8_t tNumberOfCommands = aNumberOfRepeats + 1;\n    while (tNumberOfCommands > 0) {\n\n        // Address + command\n        sendPulseDistanceWidthData(&JVCProtocolConstants, aAddress | (aCommand << JVC_ADDRESS_BITS), JVC_BITS);\n\n        tNumberOfCommands--;\n        // skip last delay!\n        if (tNumberOfCommands > 0) {\n            // send repeated command in a fixed raster\n            delay(JVC_REPEAT_DISTANCE / MICROS_IN_ONE_MILLI);\n        }\n    }\n}\n\nbool IRrecv::decodeJVC() {\n\n//    uint_fast8_t tRawlen = decodedIRData.rawlen; // Using a local variable does not improve code size\n\n    // Check we have the right amount of data (36 or 34). The +4 is for initial gap, start bit mark and space + stop bit mark.\n    // +4 is for first frame, +2 is for repeats\n    if (decodedIRData.rawlen != ((2 * JVC_BITS) + 2) && decodedIRData.rawlen != ((2 * JVC_BITS) + 4)) {\n        IR_DEBUG_PRINT(F(\"JVC: \"));\n        IR_DEBUG_PRINT(F(\"Data length=\"));\n        IR_DEBUG_PRINT(decodedIRData.rawlen);\n        IR_DEBUG_PRINTLN(F(\" is not 34 or 36\"));\n        return false;\n    }\n\n    if (decodedIRData.rawlen == ((2 * JVC_BITS) + 2)) {\n        /*\n         * Check for repeat\n         * Check leading space and first and last mark length\n         */\n        if (decodedIRData.initialGap < ((JVC_REPEAT_DISTANCE + (JVC_REPEAT_DISTANCE / 4) / MICROS_PER_TICK))\n                && matchMark(decodedIRData.rawDataPtr->rawbuf[1], JVC_BIT_MARK)\n                && matchMark(decodedIRData.rawDataPtr->rawbuf[decodedIRData.rawlen - 1], JVC_BIT_MARK)) {\n            /*\n             * We have a repeat here, so do not check for start bit\n             */\n            decodedIRData.flags = IRDATA_FLAGS_IS_REPEAT | IRDATA_FLAGS_IS_LSB_FIRST;\n            decodedIRData.address = lastDecodedAddress;\n            decodedIRData.command = lastDecodedCommand;\n            decodedIRData.protocol = JVC;\n        }\n    } else {\n\n        if (!checkHeader(&JVCProtocolConstants)) {\n            return false;\n        }\n\n        if (!decodePulseDistanceWidthData(&JVCProtocolConstants, JVC_BITS)) {\n#if defined(LOCAL_DEBUG)\n            Serial.print(F(\"JVC: \"));\n            Serial.println(F(\"Decode failed\"));\n#endif\n            return false;\n        }\n\n        // Success\n//    decodedIRData.flags = IRDATA_FLAGS_IS_LSB_FIRST; // Not required, since this is the start value\n        decodedIRData.command = decodedIRData.decodedRawData >> JVC_ADDRESS_BITS;  // upper 8 bits of LSB first value\n        decodedIRData.address = decodedIRData.decodedRawData & 0xFF;    // lowest 8 bit of LSB first value\n        decodedIRData.numberOfBits = JVC_BITS;\n        decodedIRData.protocol = JVC;\n    }\n\n    return true;\n}\n\n/*********************************************************************************\n * Old deprecated functions, kept for backward compatibility to old 2.0 tutorials\n *********************************************************************************/\nbool IRrecv::decodeJVCMSB(decode_results *aResults) {\n    unsigned int offset = 1; // Skip first space\n\n    // Check for repeat\n    if ((aResults->rawlen - 1 == 33) && matchMark(aResults->rawbuf[offset], JVC_BIT_MARK)\n            && matchMark(aResults->rawbuf[aResults->rawlen - 1], JVC_BIT_MARK)) {\n        aResults->bits = 0;\n        aResults->value = 0xFFFFFFFF;\n        decodedIRData.flags = IRDATA_FLAGS_IS_REPEAT;\n        decodedIRData.protocol = JVC;\n        return true;\n    }\n\n    // Initial mark\n    if (!matchMark(aResults->rawbuf[offset], JVC_HEADER_MARK)) {\n        return false;\n    }\n    offset++;\n\n    // Check we have enough data - +3 for start bit mark and space + stop bit mark\n    if (aResults->rawlen <= (2 * JVC_BITS) + 3) {\n        IR_DEBUG_PRINT(F(\"Data length=\"));\n        IR_DEBUG_PRINT(aResults->rawlen);\n        IR_DEBUG_PRINTLN(F(\" is too small. >= 36 is required.\"));\n        return false;\n    }\n\n    // Initial space\n    if (!matchSpace(aResults->rawbuf[offset], JVC_HEADER_SPACE)) {\n        return false;\n    }\n    offset++;\n\n    if (!decodePulseDistanceWidthData(JVC_BITS, offset, JVC_BIT_MARK, 0, JVC_ONE_SPACE, JVC_ZERO_SPACE, PROTOCOL_IS_MSB_FIRST)) {\n        return false;\n    }\n\n    // Stop bit\n    if (!matchMark(aResults->rawbuf[offset + (2 * JVC_BITS)], JVC_BIT_MARK)) {\n#if defined(LOCAL_DEBUG)\n        Serial.println(F(\"Stop bit mark length is wrong\"));\n#endif\n        return false;\n    }\n\n    // Success\n    aResults->value = decodedIRData.decodedRawData;\n    aResults->bits = JVC_BITS;\n    aResults->decode_type = JVC;\n    decodedIRData.protocol = JVC;\n\n    return true;\n}\n\n/**\n * With Send sendJVCMSB() you can send your old 32 bit codes.\n * To convert one into the other, you must reverse the byte positions and then reverse all bit positions of each byte.\n * Use bitreverse32Bit().\n * Or write it as one binary string and reverse/mirror it.\n * Example:\n * 0xCB340102 byte reverse -> 02 01 34 CB bit reverse-> 40 80 2C D3.\n * 0xCB340102 is binary 11001011001101000000000100000010.\n * 0x40802CD3 is binary 01000000100000000010110011010011.\n * If you read the first binary sequence backwards (right to left), you get the second sequence.\n */\nvoid IRsend::sendJVCMSB(unsigned long data, int nbits, bool repeat) {\n    // Set IR carrier frequency\n    enableIROut (JVC_KHZ);\n\n    // Only send the Header if this is NOT a repeat command\n    if (!repeat) {\n        mark(JVC_HEADER_MARK);\n        space(JVC_HEADER_SPACE);\n    }\n\n    // Old version with MSB first Data\n    sendPulseDistanceWidthData(JVC_BIT_MARK, JVC_ONE_SPACE, JVC_BIT_MARK, JVC_ZERO_SPACE, data, nbits, PROTOCOL_IS_MSB_FIRST);\n}\n\n/** @}*/\n#if defined(LOCAL_DEBUG)\n#undef LOCAL_DEBUG\n#endif\n#endif // _IR_JVC_HPP\n"
    }, {
      filename: "src/ir_FAST.hpp",
      code: "/*\n * ir_FAST.hpp\n *\n *  Contains functions for receiving and sending FAST IR protocol with 8 bit command\n *\n *  This file is part of Arduino-IRremote https://github.com/Arduino-IRremote/Arduino-IRremote.\n *\n ************************************************************************************\n * MIT License\n *\n * Copyright (c) 2023 Armin Joachimsmeyer\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is furnished\n * to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n ************************************************************************************\n */\n#ifndef _IR_FAST_HPP\n#define _IR_FAST_HPP\n\n#include \"TinyIR.h\"\n\n#if defined(DEBUG) && !defined(LOCAL_DEBUG)\n#define LOCAL_DEBUG\n#else\n//#define LOCAL_DEBUG // This enables debug output only for this file\n#endif\n\n/** \\addtogroup Decoder Decoders and encoders for different protocols\n * @{\n */\n// generated with https://patorjk.com/software/taag/#p=display&f=Alphabet&t=FAST\n//==============================================================================\n//                             FFFF   AA    SSS  TTTTTT\n//                             F     A  A  S       TT\n//                             FFF   AAAA   SSS    TT\n//                             F     A  A      S   TT\n//                             F     A  A  SSSS    TT\n//==============================================================================\n#include \"TinyIR.h\"\n/*\nProtocol=FAST Address=0x0 Command=0x76 Raw-Data=0x8976 16 bits LSB first\n +2100,-1050\n + 550,- 500 + 550,-1550 + 550,-1550 + 550,- 500\n + 550,-1550 + 550,-1550 + 550,-1550 + 550,- 500\n + 550,-1550 + 550,- 500 + 550,- 500 + 550,-1550\n + 550,- 500 + 550,- 500 + 550,- 500 + 550,-1550\n + 550\nSum: 28900\n*/\nstruct PulseDistanceWidthProtocolConstants FASTProtocolConstants = { FAST, FAST_KHZ, FAST_HEADER_MARK, FAST_HEADER_SPACE,\nFAST_BIT_MARK, FAST_ONE_SPACE, FAST_BIT_MARK, FAST_ZERO_SPACE, PROTOCOL_IS_LSB_FIRST, (FAST_REPEAT_PERIOD / MICROS_IN_ONE_MILLI),\nNULL };\n\n/************************************\n * Start of send and decode functions\n ************************************/\n\n/**\n * The FAST protocol repeats by skipping the header mark and space -> this leads to a poor repeat detection for JVC protocol.\n */\nvoid IRsend::sendFAST(uint8_t aCommand, int_fast8_t aNumberOfRepeats) {\n    // Set IR carrier frequency\n    enableIROut(FAST_KHZ); // 38 kHz\n\n    uint_fast8_t tNumberOfCommands = aNumberOfRepeats + 1;\n    while (tNumberOfCommands > 0) {\n\n        mark(FAST_HEADER_MARK);\n        space(FAST_HEADER_SPACE);\n\n        sendPulseDistanceWidthData(&FASTProtocolConstants, aCommand | (((uint8_t)(~aCommand)) << 8), FAST_BITS);\n\n        tNumberOfCommands--;\n        // skip last delay!\n        if (tNumberOfCommands > 0) {\n            // send repeated command in a fixed raster\n            delay(FAST_REPEAT_DISTANCE / MICROS_IN_ONE_MILLI);\n        }\n    }\n}\n\nbool IRrecv::decodeFAST() {\n\n//    uint_fast8_t tRawlen = decodedIRData.rawlen; // Using a local variable does not improve code size\n\n    // Check we have the right amount of data (36). The +4 is for initial gap, start bit mark and space + stop bit mark.\n    if (decodedIRData.rawlen != ((2 * FAST_BITS) + 4)) {\n        IR_DEBUG_PRINT(F(\"FAST: \"));\n        IR_DEBUG_PRINT(F(\"Data length=\"));\n        IR_DEBUG_PRINT(decodedIRData.rawlen);\n        IR_DEBUG_PRINTLN(F(\" is not 36\"));\n        return false;\n    }\n\n    if (!checkHeader(&FASTProtocolConstants)) {\n        return false;\n    }\n\n    if (!decodePulseDistanceWidthData(&FASTProtocolConstants, FAST_BITS)) {\n#if defined(LOCAL_DEBUG)\n        Serial.print(F(\"FAST: \"));\n        Serial.println(F(\"Decode failed\"));\n#endif\n        return false;\n    }\n\n    WordUnion tValue;\n    tValue.UWord = decodedIRData.decodedRawData;\n\n    if (tValue.UByte.LowByte != (uint8_t)~(tValue.UByte.HighByte)) {\n#if defined(LOCAL_DEBUG)\n        Serial.print(F(\"FAST: \"));\n        Serial.print(F(\"8 bit parity is not correct. Expected=0x\"));\n        Serial.print((uint8_t)~(tValue.UByte.LowByte), HEX);\n        Serial.print(F(\" received=0x\"));\n        Serial.print(tValue.UByte.HighByte, HEX);\n        Serial.print(F(\" data=0x\"));\n        Serial.println(tValue.UWord, HEX);\n#endif\n        decodedIRData.flags = IRDATA_FLAGS_PARITY_FAILED;\n    }\n\n    checkForRepeatSpaceTicksAndSetFlag(FAST_MAXIMUM_REPEAT_DISTANCE / MICROS_PER_TICK);\n\n    // Success\n//    decodedIRData.flags = IRDATA_FLAGS_IS_LSB_FIRST; // Not required, since this is the start value\n    decodedIRData.command = tValue.UByte.LowByte;\n    decodedIRData.address = 0; // No address for this protocol\n    decodedIRData.numberOfBits = FAST_BITS;\n    decodedIRData.protocol = FAST;\n\n    return true;\n}\n\n/** @}*/\n#if defined(LOCAL_DEBUG)\n#undef LOCAL_DEBUG\n#endif\n#endif // _IR_FAST_HPP\n"
    }, {
      filename: "src/IRFeedbackLED.hpp",
      code: "/**\n * @file IRFeedbackLED.hpp\n *\n * @brief All Feedback LED specific functions are contained in this file.\n *\n *  This file is part of Arduino-IRremote https://github.com/Arduino-IRremote/Arduino-IRremote.\n *\n *************************************************************************************\n * MIT License\n *\n * Copyright (c) 2021-2022 Armin Joachimsmeyer\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is furnished\n * to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n ************************************************************************************\n */\n#ifndef _IR_FEEDBACK_LED_HPP\n#define _IR_FEEDBACK_LED_HPP\n\n/** \\addtogroup FeedbackLEDFunctions Feedback LED functions\n * @{\n */\n\n/**\n * Contains pin number and enable status of the feedback LED\n */\nstruct FeedbackLEDControlStruct {\n    uint8_t FeedbackLEDPin;         ///< if 0, then take board specific FEEDBACK_LED_ON() and FEEDBACK_LED_OFF() functions\n    uint8_t LedFeedbackEnabled; ///< LED_FEEDBACK_ENABLED_FOR_RECEIVE or LED_FEEDBACK_ENABLED_FOR_SEND -> enable blinking of pin on IR processing\n};\n\nstruct FeedbackLEDControlStruct FeedbackLEDControl; ///< The feedback LED control instance\n\n/**\n * Enable blinking of feedback LED (LED_BUILTIN is taken as default) on IR sending and receiving\n * Cannot disable it here!!! Use disableLEDFeedbackForReceive() or disableLEDFeedbackForSend()\n * @param aFeedbackLEDPin If aFeedbackLEDPin == 0, then take board specific FEEDBACK_LED_ON() and FEEDBACK_LED_ON() and FEEDBACK_LED_OFF() functions\n *                        If FeedbackLEDPin == 0 and no LED_BUILTIN defined, disable LED feedback\n * @param aEnableLEDFeedback If LED_FEEDBACK_ENABLED_FOR_RECEIVE or LED_FEEDBACK_ENABLED_FOR_SEND -> enable blinking of Feedback LED\n */\nvoid setLEDFeedback(uint8_t aFeedbackLEDPin, uint8_t aEnableLEDFeedback) {\n\n    FeedbackLEDControl.FeedbackLEDPin = aFeedbackLEDPin; // default is 0 -> use LED_BUILTIN if available, else disable feedback\n\n    if (aEnableLEDFeedback != DO_NOT_ENABLE_LED_FEEDBACK) {\n        FeedbackLEDControl.LedFeedbackEnabled |= aEnableLEDFeedback;\n        if (aFeedbackLEDPin != USE_DEFAULT_FEEDBACK_LED_PIN) {\n            pinModeFast(aFeedbackLEDPin, OUTPUT);\n#if defined(LED_BUILTIN)\n        } else {\n            pinModeFast(LED_BUILTIN, OUTPUT);\n#else\n            FeedbackLEDControl.LedFeedbackEnabled = LED_FEEDBACK_DISABLED_COMPLETELY; // we have no LED_BUILTIN available\n#endif\n        }\n    }\n}\n\n/*\n * Direct replacement for blink13()\n */\nvoid setLEDFeedback(bool aEnableLEDFeedback) {\n    bool tEnableLEDFeedback = LED_FEEDBACK_DISABLED_COMPLETELY;\n    if (aEnableLEDFeedback) {\n        tEnableLEDFeedback = LED_FEEDBACK_ENABLED_FOR_SEND | LED_FEEDBACK_ENABLED_FOR_RECEIVE;\n    }\n    setLEDFeedback(FeedbackLEDControl.FeedbackLEDPin, tEnableLEDFeedback);\n}\n\nvoid enableLEDFeedback() {\n    FeedbackLEDControl.LedFeedbackEnabled |= LED_FEEDBACK_ENABLED_FOR_RECEIVE;\n}\n\nvoid disableLEDFeedback() {\n    FeedbackLEDControl.LedFeedbackEnabled &= ~(LED_FEEDBACK_ENABLED_FOR_RECEIVE);\n}\n\nvoid enableLEDFeedbackForSend() {\n    FeedbackLEDControl.LedFeedbackEnabled |= LED_FEEDBACK_ENABLED_FOR_SEND;\n}\n\nvoid disableLEDFeedbackForSend() {\n    FeedbackLEDControl.LedFeedbackEnabled &= ~(LED_FEEDBACK_ENABLED_FOR_SEND);\n}\n\n/**\n * Flash LED while receiving or sending IR data. Does not check if enabled, this must be done by the caller.\n * Handles the 0 value of FeedbackLEDPin and the macro FEEDBACK_LED_IS_ACTIVE_LOW.\n */\n#if defined(ESP32) || defined(ESP8266)\nIRAM_ATTR\n#endif\nvoid setFeedbackLED(bool aSwitchLedOn) {\n    if (aSwitchLedOn) {\n        if (FeedbackLEDControl.FeedbackLEDPin != USE_DEFAULT_FEEDBACK_LED_PIN) {\n#if defined(FEEDBACK_LED_IS_ACTIVE_LOW)\n                digitalWriteFast(FeedbackLEDControl.FeedbackLEDPin, LOW); // Turn user defined pin LED on\n#else\n            digitalWriteFast(FeedbackLEDControl.FeedbackLEDPin, HIGH); // Turn user defined pin LED on\n#endif\n#if defined(LED_BUILTIN) // use fast macros here\n            } else {\n#  if defined(FEEDBACK_LED_IS_ACTIVE_LOW)\n                digitalWriteFast(LED_BUILTIN, LOW); // For AVR, this generates a single cbi command\n#  else\n                digitalWriteFast(LED_BUILTIN, HIGH); // For AVR, this generates a single sbi command\n#  endif\n#endif\n        }\n    } else {\n        if (FeedbackLEDControl.FeedbackLEDPin != USE_DEFAULT_FEEDBACK_LED_PIN) {\n#if defined(FEEDBACK_LED_IS_ACTIVE_LOW)\n            digitalWriteFast(FeedbackLEDControl.FeedbackLEDPin, HIGH); // Turn user defined pin LED off\n#else\n            digitalWriteFast(FeedbackLEDControl.FeedbackLEDPin, LOW); // Turn user defined pin LED off\n#endif\n#if defined(LED_BUILTIN)\n            } else {\n#  if defined(FEEDBACK_LED_IS_ACTIVE_LOW)\n                digitalWriteFast(LED_BUILTIN, HIGH); // For AVR, this generates a single sbi command\n#  else\n                digitalWriteFast(LED_BUILTIN, LOW); // For AVR, this generates a single cbi command\n#  endif\n#endif\n        }\n    }\n}\n\n/**\n * Old deprecated function name for setLEDFeedback() or enableLEDFeedback() / disableLEDFeedback()\n */\nvoid IRrecv::blink13(uint8_t aEnableLEDFeedback) {\n    setLEDFeedback(FeedbackLEDControl.FeedbackLEDPin, aEnableLEDFeedback);\n}\n/**\n * Old deprecated function name for setLEDFeedback()\n */\nvoid setBlinkPin(uint8_t aBlinkPin) {\n    setLEDFeedback(aBlinkPin, FeedbackLEDControl.LedFeedbackEnabled);\n}\n\n/** @}*/\n\n#endif // _IR_FEEDBACK_LED_HPP\n"
    }, {
      filename: "src/ir_DistanceWidthProtocol.hpp",
      code: "/*\n * ir_DistanceWidthProtocol.hpp\n *\n * Contains only the decoder functions for universal pulse width or pulse distance protocols!\n * The send functions are used by almost all protocols and therefore in IRSend.hh.\n *\n * This decoder tries to decode a pulse distance or pulse distance width with constant period (or pulse width - not enabled yet) protocol.\n * 1. Analyze all space and mark length\n * 2. Decide which protocol we have\n * 3. Try to decode with the mark and space data found in step 1\n * 4. Assume one start bit / header and one stop bit, since pulse distance data must have a stop bit!\n * No data and address decoding, only raw data as result.\n *\n * Pulse distance data can be sent with the generic function as in SendDemo example line 155:\n * https://github.com/Arduino-IRremote/Arduino-IRremote/blob/d51b540cb2ddf1424888d2d9e6b62fe1ef46859d/examples/SendDemo/SendDemo.ino#L155\n * void sendPulseDistanceWidthData(unsigned int aOneMarkMicros, unsigned int aOneSpaceMicros, unsigned int aZeroMarkMicros,\n *            unsigned int aZeroSpaceMicros, uint32_t aData, uint8_t aNumberOfBits, bool aMSBfirst, bool aSendStopBit = false)\n * The header must be sent manually with:\n *          IrSender.mark(MarkMicros)\n *          IrSender.space(SpaceMicros);\n *\n * Or send it by filling a DecodedRawDataArray and with the sendPulseDistanceWidthFromArray() function as in SendDemo example line 175:\n * https://github.com/Arduino-IRremote/Arduino-IRremote/blob/d51b540cb2ddf1424888d2d9e6b62fe1ef46859d/examples/SendDemo/SendDemo.ino#L175\n * sendPulseDistanceWidthFromArray(uint_fast8_t aFrequencyKHz, unsigned int aHeaderMarkMicros,\n *         unsigned int aHeaderSpaceMicros, unsigned int aOneMarkMicros, unsigned int aOneSpaceMicros, unsigned int aZeroMarkMicros,\n *         unsigned int aZeroSpaceMicros, uint32_t *aDecodedRawDataArray, unsigned int aNumberOfBits, uint8_t aFlags,\n *         unsigned int aRepeatPeriodMillis, int_fast8_t aNumberOfRepeats)\n *\n *  This file is part of Arduino-IRremote https://github.com/Arduino-IRremote/Arduino-IRremote.\n *\n ************************************************************************************\n * MIT License\n *\n * Copyright (c) 2022-2023 Armin Joachimsmeyer\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is furnished\n * to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n ************************************************************************************\n */\n#ifndef _IR_DISTANCE_WIDTH_HPP\n#define _IR_DISTANCE_WIDTH_HPP\n\n#if !defined(DISTANCE_WIDTH_MAXIMUM_REPEAT_DISTANCE_MICROS)\n#define DISTANCE_WIDTH_MAXIMUM_REPEAT_DISTANCE_MICROS       100000 // 100 ms, bit it is just a guess\n#endif\n\n#if defined(DEBUG) && !defined(LOCAL_DEBUG)\n#define LOCAL_DEBUG\n#else\n//#define LOCAL_DEBUG // This enables debug output only for this file\n#endif\n\n// accept durations up to 50 * 50 (MICROS_PER_TICK) 2500 microseconds\n#define DURATION_ARRAY_SIZE 50\n\n// Switch the decoding according to your needs\n//#define USE_MSB_DECODING_FOR_DISTANCE_DECODER // If active, it resembles LG, otherwise LSB first as most other protocols e.g. NEC and Kaseikyo/Panasonic\n\n/** \\addtogroup Decoder Decoders and encoders for different protocols\n * @{\n */\n//=====================================================================================\n// DDD   III   SSS  TTTTTT   AA   N   N   CCC  EEEE     W     W  III  DDD  TTTTTT  H  H\n// D  D   I   S       TT    A  A  NN  N  C     E        W     W   I   D  D   TT    H  H\n// D  D   I    SSS    TT    AAAA  N N N  C     EEE      W  W  W   I   D  D   TT    HHHH\n// D  D   I       S   TT    A  A  N  NN  C     E         W W W    I   D  D   TT    H  H\n// DDD   III  SSSS    TT    A  A  N   N   CCC  EEEE       W W    III  DDD    TT    H  H\n//=====================================================================================\n// see: https://www.mikrocontroller.net/articles/IRMP_-_english#Codings\n#if defined(LOCAL_DEBUG)\nvoid printDurations(uint8_t aArray[], uint8_t aMaxIndex) {\n    for (uint_fast8_t i = 0; i <= aMaxIndex; i++) {\n        //Print index at the beginning of a new line\n        if (i % 10 == 0) {\n            if (i == 0) {\n                Serial.print(' '); // indentation for the first index 0\n            } else {\n                Serial.println(); // new line for next indexes 10, 20 etc.\n            }\n            Serial.print(i);\n            Serial.print(F(\": \"));\n        }\n        // Print number of values in array and duration if != 0\n        Serial.print(aArray[i]);\n        if (aArray[i] != 0) {\n            Serial.print('x');\n            Serial.print(i * (uint16_t) MICROS_PER_TICK);\n        }\n        Serial.print(F(\" | \"));\n    }\n    Serial.println();\n}\n#endif\n\n/*\n * @return false if more than 2 distinct duration values found\n */\nbool aggregateArrayCounts(uint8_t aArray[], uint8_t aMaxIndex, uint8_t *aShortIndex, uint8_t *aLongIndex) {\n    uint8_t tSum = 0;\n    uint16_t tWeightedSum = 0;\n    for (uint_fast8_t i = 0; i <= aMaxIndex; i++) {\n        uint8_t tCurrentDurations = aArray[i];\n        if (tCurrentDurations != 0) {\n            // Add it to sum and remove array content\n            tSum += tCurrentDurations;\n            tWeightedSum += (tCurrentDurations * i);\n            aArray[i] = 0;\n        }\n        if ((tCurrentDurations == 0 || i == aMaxIndex) && tSum != 0) {\n            // here we have a sum and a gap after the values\n            uint8_t tAggregateIndex = (tWeightedSum + (tSum / 2)) / tSum; // with rounding\n            aArray[tAggregateIndex] = tSum; // disabling this line increases code size by 2 - unbelievable!\n            // store aggregate for later decoding\n            if (*aShortIndex == 0) {\n                *aShortIndex = tAggregateIndex;\n            } else if (*aLongIndex == 0) {\n                *aLongIndex = tAggregateIndex;\n            } else {\n                // we have 3 bins => this is likely no pulse width or distance protocol. e.g. it can be RC5.\n                return false;\n            }\n            // initialize for next aggregation\n            tSum = 0;\n            tWeightedSum = 0;\n        }\n    }\n    return true;\n}\n\n/*\n * Try to decode a pulse distance or pulse width protocol.\n * 1. Analyze all space and mark length\n * 2. Decide if we have an pulse width or distance protocol\n * 3. Try to decode with the mark and space data found in step 1\n * No data and address decoding, only raw data as result.\n */\nbool IRrecv::decodeDistanceWidth() {\n    uint8_t tDurationArray[DURATION_ARRAY_SIZE]; // For up to 49 ticks / 2450 us\n\n    /*\n     * Accept only protocols with at least 8 bits\n     */\n    if (decodedIRData.rawlen < (2 * 8) + 4) {\n        IR_DEBUG_PRINT(F(\"PULSE_DISTANCE_WIDTH: \"));\n        IR_DEBUG_PRINT(F(\"Data length=\"));\n        IR_DEBUG_PRINT(decodedIRData.rawlen);\n        IR_DEBUG_PRINTLN(F(\" is less than 20\"));\n        return false;\n    }\n\n    // Reset duration array\n    memset(tDurationArray, 0, DURATION_ARRAY_SIZE);\n\n    uint8_t tIndexOfMaxDuration = 0;\n    /*\n     * Count number of mark durations up to 49 ticks. Skip leading start and trailing stop bit.\n     */\n    for (IRRawlenType i = 3; i < decodedIRData.rawlen - 2; i += 2) {\n        auto tDurationTicks = decodedIRData.rawDataPtr->rawbuf[i];\n        if (tDurationTicks < DURATION_ARRAY_SIZE) {\n            tDurationArray[tDurationTicks]++; // count duration if less than DURATION_ARRAY_SIZE (50)\n            if (tIndexOfMaxDuration < tDurationTicks) {\n                tIndexOfMaxDuration = tDurationTicks;\n            }\n        } else {\n#if defined(LOCAL_DEBUG)\n            Serial.print(F(\"PULSE_DISTANCE_WIDTH: \"));\n            Serial.print(F(\"Mark \"));\n            Serial.print(tDurationTicks * MICROS_PER_TICK);\n            Serial.print(F(\" is longer than maximum \"));\n            Serial.print(DURATION_ARRAY_SIZE * MICROS_PER_TICK);\n            Serial.print(F(\" us. Index=\"));\n            Serial.println(i);\n#endif\n            return false;\n        }\n    }\n\n    /*\n     * Aggregate mark counts to one duration bin\n     */\n    uint8_t tMarkTicksShort = 0;\n    uint8_t tMarkTicksLong = 0;\n    bool tSuccess = aggregateArrayCounts(tDurationArray, tIndexOfMaxDuration, &tMarkTicksShort, &tMarkTicksLong);\n#if defined(LOCAL_DEBUG)\n    Serial.println(F(\"Mark:\"));\n    printDurations(tDurationArray, tIndexOfMaxDuration);\n#endif\n\n    if (!tSuccess) {\n#if defined(LOCAL_DEBUG)\n        Serial.print(F(\"PULSE_DISTANCE_WIDTH: \"));\n        Serial.println(F(\"Mark aggregation failed, more than 2 distinct mark duration values found\"));\n#endif\n        return false;\n    }\n\n    // Reset duration array\n    memset(tDurationArray, 0, DURATION_ARRAY_SIZE);\n\n    /*\n     * Count number of space durations. Skip leading start and trailing stop bit.\n     */\n    tIndexOfMaxDuration = 0;\n    for (IRRawlenType i = 4; i < decodedIRData.rawlen - 2; i += 2) {\n        auto tDurationTicks = decodedIRData.rawDataPtr->rawbuf[i];\n        if (tDurationTicks < DURATION_ARRAY_SIZE) {\n            tDurationArray[tDurationTicks]++;\n            if (tIndexOfMaxDuration < tDurationTicks) {\n                tIndexOfMaxDuration = tDurationTicks;\n            }\n        } else {\n#if defined(LOCAL_DEBUG)\n            Serial.print(F(\"PULSE_DISTANCE_WIDTH: \"));\n            Serial.print(F(\"Space \"));\n            Serial.print(tDurationTicks * MICROS_PER_TICK);\n            Serial.print(F(\" is longer than maximum \"));\n            Serial.print(DURATION_ARRAY_SIZE * MICROS_PER_TICK);\n            Serial.print(F(\" us. Index=\"));\n            Serial.println(i);\n#endif\n            return false;\n        }\n    }\n\n    /*\n     * Aggregate space counts to one duration bin\n     */\n    uint8_t tSpaceTicksShort = 0;\n    uint8_t tSpaceTicksLong = 0;\n    tSuccess = aggregateArrayCounts(tDurationArray, tIndexOfMaxDuration, &tSpaceTicksShort, &tSpaceTicksLong);\n#if defined(LOCAL_DEBUG)\n    Serial.println(F(\"Space:\"));\n    printDurations(tDurationArray, tIndexOfMaxDuration);\n#endif\n\n    if (!tSuccess) {\n#if defined(LOCAL_DEBUG)\n        Serial.print(F(\"PULSE_DISTANCE_WIDTH: \"));\n        Serial.println(F(\"Space aggregation failed, more than 2 distinct space duration values found\"));\n#endif\n        return false;\n    }\n\n    /*\n     * Print characteristics of this protocol. Durations are in ticks.\n     * Number of bits, start bit, start pause, long mark, long space, short mark, short space\n     *\n     * NEC:         32, 180, 90,  0, 34, 11, 11\n     * Samsung32:   32,  90, 90,  0, 34, 11, 11\n     * LG:          28, 180, 84,  0, 32, 10, 11\n     * JVC:         16, 168, 84,  0, 32, 10, 10\n     * Kaseikyo:    48.  69, 35,  0, 26,  9,  9\n     * Sony:  12|15|20,  48, 12, 24,  0, 12, 12 // the only known pulse width protocol\n     */\n#if defined(LOCAL_DEBUG)\n    Serial.print(F(\"DistanceWidthTimingInfoStruct: \"));\n    Serial.print(decodedIRData.rawDataPtr->rawbuf[1] * MICROS_PER_TICK);\n    Serial.print(F(\", \"));\n    Serial.print(decodedIRData.rawDataPtr->rawbuf[2] * MICROS_PER_TICK);\n    Serial.print(F(\", \"));\n    Serial.print(tMarkTicksLong * MICROS_PER_TICK);\n    Serial.print(F(\", \"));\n    Serial.print(tSpaceTicksLong * MICROS_PER_TICK);\n    Serial.print(F(\", \"));\n    Serial.print(tMarkTicksShort * MICROS_PER_TICK);\n    Serial.print(F(\", \"));\n    Serial.println(tSpaceTicksShort * MICROS_PER_TICK);\n#endif\n#if RAW_BUFFER_LENGTH <= 508\n    uint_fast8_t tNumberOfBits;\n#else\n    uint16_t tNumberOfBits;\n#endif\n    tNumberOfBits = (decodedIRData.rawlen / 2) - 1;\n    if (tSpaceTicksLong > 0 && tMarkTicksLong == 0) {\n        // For PULSE_DISTANCE a stop bit is mandatory, for PULSE_WIDTH it is not required!\n        tNumberOfBits--; // Correct for stop bit\n    }\n    decodedIRData.numberOfBits = tNumberOfBits;\n    uint8_t tNumberOfAdditionalArrayValues = (tNumberOfBits - 1) / BITS_IN_RAW_DATA_TYPE;\n\n    /*\n     * We can have the following protocol timings\n     * Pulse distance:          Pulses/marks are constant, pause/spaces have different length, like NEC.\n     * Pulse width:             Pulses/marks have different length, pause/spaces are constant, like Sony.\n     * Pulse distance width:    Pulses/marks and pause/spaces have different length, often the bit length is constant, like MagiQuest.\n     * Pulse distance width can be decoded by pulse width decoder, if this decoder does not check the length of pause/spaces.\n     */\n\n    if (tMarkTicksLong == 0 && tSpaceTicksLong == 0) {\n#if defined(LOCAL_DEBUG)\n        Serial.print(F(\"PULSE_DISTANCE: \"));\n        Serial.println(F(\"Only 1 distinct duration value for each space and mark found\"));\n#endif\n        return false;\n    }\n    unsigned int tSpaceMicrosShort;\n#if defined DECODE_STRICT_CHECKS\n        if(tMarkTicksLong > 0 && tSpaceTicksLong > 0) {\n            // We have different mark and space length here, so signal decodePulseDistanceWidthData() not to check against constant length decodePulseDistanceWidthData\n            tSpaceMicrosShort = 0;\n        }\n#endif\n    tSpaceMicrosShort = tSpaceTicksShort * MICROS_PER_TICK;\n    unsigned int tMarkMicrosShort = tMarkTicksShort * MICROS_PER_TICK;\n    unsigned int tMarkMicrosLong = tMarkTicksLong * MICROS_PER_TICK;\n    unsigned int tSpaceMicrosLong = tSpaceTicksLong * MICROS_PER_TICK;\n    IRRawlenType tStartIndex = 3;  // skip leading start bit for decoding.\n\n    for (uint_fast8_t i = 0; i <= tNumberOfAdditionalArrayValues; ++i) {\n        uint8_t tNumberOfBitsForOneDecode = tNumberOfBits;\n        /*\n         * Decode in 32/64 bit chunks. Only the last chunk can contain less than 32/64 bits\n         */\n        if (tNumberOfBitsForOneDecode > BITS_IN_RAW_DATA_TYPE) {\n            tNumberOfBitsForOneDecode = BITS_IN_RAW_DATA_TYPE;\n        }\n        bool tResult;\n        if (tMarkTicksLong > 0) {\n            /*\n             * Here short and long mark durations found.\n             */\n            decodedIRData.protocol = PULSE_WIDTH;\n            tResult = decodePulseDistanceWidthData(tNumberOfBitsForOneDecode, tStartIndex, tMarkMicrosLong, tMarkMicrosShort,\n                    tSpaceMicrosShort, 0,\n#if defined(USE_MSB_DECODING_FOR_DISTANCE_DECODER)\n                    true\n#else\n                    false\n#endif\n                    );\n        } else {\n            /*\n             * Here short and long space durations found.\n             */\n            decodedIRData.protocol = PULSE_DISTANCE;\n            tResult = decodePulseDistanceWidthData(tNumberOfBitsForOneDecode, tStartIndex, tMarkMicrosShort, tMarkMicrosShort,\n                    tSpaceMicrosLong, tSpaceMicrosShort,\n#if defined(USE_MSB_DECODING_FOR_DISTANCE_DECODER)\n                    true\n#else\n                    false\n#endif\n                    );\n        }\n        if (!tResult) {\n#if defined(LOCAL_DEBUG)\n            Serial.print(F(\"PULSE_WIDTH: \"));\n            Serial.println(F(\"Decode failed\"));\n#endif\n            return false;\n        }\n#if defined(LOCAL_DEBUG)\n        Serial.print(F(\"PULSE_WIDTH: \"));\n        Serial.print(F(\"decodedRawData=0x\"));\n        Serial.println(decodedIRData.decodedRawData, HEX);\n#endif\n        // fill array with decoded data\n        decodedIRData.decodedRawDataArray[i] = decodedIRData.decodedRawData;\n        tStartIndex += (2 * BITS_IN_RAW_DATA_TYPE);\n        tNumberOfBits -= BITS_IN_RAW_DATA_TYPE;\n    }\n\n#if defined(USE_MSB_DECODING_FOR_DISTANCE_DECODER)\n    decodedIRData.flags = IRDATA_FLAGS_IS_MSB_FIRST;\n#endif\n\n    // Check for repeat\n    checkForRepeatSpaceTicksAndSetFlag(DISTANCE_WIDTH_MAXIMUM_REPEAT_DISTANCE_MICROS / MICROS_PER_TICK);\n\n    /*\n     * Store timing data to reproduce frame for sending\n     */\n    decodedIRData.DistanceWidthTimingInfo.HeaderMarkMicros = (decodedIRData.rawDataPtr->rawbuf[1] * MICROS_PER_TICK);\n    decodedIRData.DistanceWidthTimingInfo.HeaderSpaceMicros = (decodedIRData.rawDataPtr->rawbuf[2] * MICROS_PER_TICK);\n    decodedIRData.DistanceWidthTimingInfo.ZeroMarkMicros = tMarkMicrosShort;\n    decodedIRData.DistanceWidthTimingInfo.ZeroSpaceMicros = tSpaceMicrosShort;\n    if (tMarkMicrosLong != 0) {\n        decodedIRData.DistanceWidthTimingInfo.OneMarkMicros = tMarkMicrosLong;\n\n        decodedIRData.DistanceWidthTimingInfo.OneSpaceMicros = tSpaceMicrosShort;\n        if (tSpaceMicrosLong != 0) {\n            // Assume long space for zero when we have PulseDistanceWidth -> enables constant bit length\n            decodedIRData.DistanceWidthTimingInfo.ZeroSpaceMicros = tSpaceMicrosLong;\n        }\n    } else {\n        decodedIRData.DistanceWidthTimingInfo.OneMarkMicros = tMarkMicrosShort;\n\n        // Here tMarkMicrosLong is 0 => tSpaceMicrosLong != 0\n        decodedIRData.DistanceWidthTimingInfo.OneSpaceMicros = tSpaceMicrosLong;\n    }\n\n#if defined(LOCAL_DEBUG)\n    Serial.print(F(\"DistanceWidthTimingInfo=\"));\n    IrReceiver.printDistanceWidthTimingInfo(&Serial, &decodedIRData.DistanceWidthTimingInfo);\n    Serial.println();\n#endif\n    return true;\n}\n\n/** @}*/\n#if defined(LOCAL_DEBUG)\n#undef LOCAL_DEBUG\n#endif\n#endif // _IR_DISTANCE_WIDTH_HPP\n"
    }, {
      filename: "src/IRReceive.hpp",
      code: "/*\n * IRReceive.hpp\n * This file is exclusively included by IRremote.h to enable easy configuration of library switches\n *\n *  Contains all IRrecv class functions as well as other receiver related functions.\n *\n *  This file is part of Arduino-IRremote https://github.com/Arduino-IRremote/Arduino-IRremote.\n *\n ************************************************************************************\n * MIT License\n *\n * Copyright (c) 2009-2023 Ken Shirriff, Rafi Khan, Armin Joachimsmeyer\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is furnished\n * to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n ************************************************************************************\n */\n#ifndef _IR_RECEIVE_HPP\n#define _IR_RECEIVE_HPP\n\n#if defined(DEBUG) && !defined(LOCAL_DEBUG)\n//#define LOCAL_DEBUG //\n#else\n//#define LOCAL_DEBUG // This enables debug output only for this file\n#endif\n\n#if defined(TRACE) && !defined(LOCAL_TRACE)\n#define LOCAL_TRACE\n#else\n//#define LOCAL_TRACE // This enables debug output only for this file\n#endif\n/*\n * Low level hardware timing measurement\n */\n//#define _IR_MEASURE_TIMING // for ISR\n//#define _IR_TIMING_TEST_PIN 7 // \"pinModeFast(_IR_TIMING_TEST_PIN, OUTPUT);\" is executed at start()\n//\n/*\n * Check for additional required characteristics of timing like length of mark for a constant mark protocol,\n * where space length determines the bit value. Requires up to 194 additional bytes of program memory.\n */\n//#define DECODE_STRICT_CHECKS\n/** \\addtogroup Receiving Receiving IR data for multiple protocols\n * @{\n */\n/**\n * The receiver instance\n */\nIRrecv IrReceiver;\n\n/*\n * The control structure instance\n */\nstruct irparams_struct irparams; // the irparams instance\n\n/**\n * Instantiate the IRrecv class. Multiple instantiation is not supported.\n * @param IRReceivePin Arduino pin to use. No sanity check is made.\n */\nIRrecv::IRrecv() {\n    decodedIRData.rawDataPtr = &irparams; // for decodePulseDistanceData() etc.\n    setReceivePin(0);\n#if !defined(NO_LED_FEEDBACK_CODE)\n    setLEDFeedback(0, DO_NOT_ENABLE_LED_FEEDBACK);\n#endif\n}\n\nIRrecv::IRrecv(uint_fast8_t aReceivePin) {\n    decodedIRData.rawDataPtr = &irparams; // for decodePulseDistanceData() etc.\n    setReceivePin(aReceivePin);\n#if !defined(NO_LED_FEEDBACK_CODE)\n    setLEDFeedback(0, DO_NOT_ENABLE_LED_FEEDBACK);\n#endif\n}\n\n/**\n * Instantiate the IRrecv class. Multiple instantiation is not supported.\n * @param aReceivePin Arduino pin to use, where a demodulating IR receiver is connected.\n * @param aFeedbackLEDPin if 0, then take board specific FEEDBACK_LED_ON() and FEEDBACK_LED_OFF() functions\n */\nIRrecv::IRrecv(uint_fast8_t aReceivePin, uint_fast8_t aFeedbackLEDPin) {\n    decodedIRData.rawDataPtr = &irparams; // for decodePulseDistanceData() etc.\n    setReceivePin(aReceivePin);\n#if !defined(NO_LED_FEEDBACK_CODE)\n    setLEDFeedback(aFeedbackLEDPin, DO_NOT_ENABLE_LED_FEEDBACK);\n#else\n    (void) aFeedbackLEDPin;\n#endif\n}\n\n/**********************************************************************************************************************\n * Interrupt Service Routine - Called every 50 us\n *\n * Duration in ticks of 50 us of alternating SPACE, MARK are recorded in irparams.rawbuf array.\n * 'rawlen' counts the number of entries recorded so far.\n * First entry is the SPACE between transmissions.\n *\n * As soon as one SPACE entry gets longer than RECORD_GAP_TICKS, state switches to STOP (frame received). Timing of SPACE continues.\n * A call of resume() switches from STOP to IDLE.\n * As soon as first MARK arrives in IDLE, gap width is recorded and new logging starts.\n *\n * With digitalRead and Feedback LED\n * 15 pushs, 1 in, 1 eor before start of code = 2 us @16MHz + * 7.2 us computation time (6us idle time) + * pop + reti = 2.25 us @16MHz => 10.3 to 11.5 us @16MHz\n * With portInputRegister and mask and Feedback LED code commented\n * 9 pushs, 1 in, 1 eor before start of code = 1.25 us @16MHz + * 2.25 us computation time + * pop + reti = 1.5 us @16MHz => 5 us @16MHz\n * => Minimal CPU frequency is 4 MHz\n *\n **********************************************************************************************************************/\n#if defined(ESP8266) || defined(ESP32)\nIRAM_ATTR\n#endif\nvoid IRReceiveTimerInterruptHandler() {\n#if defined(_IR_MEASURE_TIMING) && defined(_IR_TIMING_TEST_PIN)\n    digitalWriteFast(_IR_TIMING_TEST_PIN, HIGH); // 2 clock cycles\n#endif\n// 7 - 8.5 us for ISR body (without pushes and pops) for ATmega328 @16MHz\n\n#if defined(TIMER_REQUIRES_RESET_INTR_PENDING)\n    timerResetInterruptPending(); // reset TickCounterForISR interrupt flag if required (currently only for Teensy and ATmega4809)\n#endif\n\n// Read if IR Receiver -> SPACE [xmt LED off] or a MARK [xmt LED on]\n#if defined(__AVR__)\n    uint8_t tIRInputLevel = *irparams.IRReceivePinPortInputRegister & irparams.IRReceivePinMask;\n#else\n    uint_fast8_t tIRInputLevel = (uint_fast8_t) digitalReadFast(irparams.IRReceivePin);\n#endif\n\n    /*\n     * Increase TickCounter and clip it at maximum 0xFFFF / 3.2 seconds at 50 us ticks\n     */\n    if (irparams.TickCounterForISR < UINT16_MAX) {\n        irparams.TickCounterForISR++;  // One more 50uS tick\n    }\n\n    /*\n     * Due to a ESP32 compiler bug https://github.com/espressif/esp-idf/issues/1552 no switch statements are possible for ESP32\n     * So we change the code to if / else if\n     */\n//    switch (irparams.StateForISR) {\n//\n    if (irparams.StateForISR == IR_REC_STATE_IDLE) {\n        /*\n         * Here we are just resumed and maybe in the middle of a transmission\n         */\n        if (tIRInputLevel == INPUT_MARK) {\n            // check if we did not start in the middle of a transmission by checking the minimum length of leading space\n            if (irparams.TickCounterForISR > RECORD_GAP_TICKS) {\n#if defined(_IR_MEASURE_TIMING) && defined(_IR_TIMING_TEST_PIN)\n//                digitalWriteFast(_IR_TIMING_TEST_PIN, HIGH); // 2 clock cycles\n#endif\n                /*\n                 * Gap between two transmissions just ended; Record gap duration + start recording transmission\n                 * Initialize all state machine variables\n                 */\n                irparams.OverflowFlag = false;\n                irparams.rawbuf[0] = irparams.TickCounterForISR;\n                irparams.rawlen = 1;\n                irparams.StateForISR = IR_REC_STATE_MARK;\n            } // otherwise stay in idle state\n            irparams.TickCounterForISR = 0; // reset counter in both cases\n        }\n\n    } else if (irparams.StateForISR == IR_REC_STATE_MARK) {  // Timing mark\n        if (tIRInputLevel != INPUT_MARK) {\n            /*\n             * Mark ended here. Record mark time in rawbuf array\n             */\n#if defined(_IR_MEASURE_TIMING) && defined(_IR_TIMING_TEST_PIN)\n//            digitalWriteFast(_IR_TIMING_TEST_PIN, HIGH); // 2 clock cycles\n#endif\n            irparams.rawbuf[irparams.rawlen++] = irparams.TickCounterForISR; // record mark\n            irparams.StateForISR = IR_REC_STATE_SPACE;\n            irparams.TickCounterForISR = 0; // This resets the tick counter also at end of frame :-)\n        }\n\n    } else if (irparams.StateForISR == IR_REC_STATE_SPACE) {  // Timing space\n        if (tIRInputLevel == INPUT_MARK) {\n            /*\n             * Space ended here. Check for overflow and record space time in rawbuf array\n             */\n            if (irparams.rawlen >= RAW_BUFFER_LENGTH) {\n                // Flag up a read OverflowFlag; Stop the state machine\n                irparams.OverflowFlag = true;\n                irparams.StateForISR = IR_REC_STATE_STOP;\n#if !IR_REMOTE_DISABLE_RECEIVE_COMPLETE_CALLBACK\n                /*\n                 * Call callback if registered (not NULL)\n                 */\n                if (irparams.ReceiveCompleteCallbackFunction != NULL) {\n                    irparams.ReceiveCompleteCallbackFunction();\n                }\n#endif\n            } else {\n#if defined(_IR_MEASURE_TIMING) && defined(_IR_TIMING_TEST_PIN)\n//                digitalWriteFast(_IR_TIMING_TEST_PIN, HIGH); // 2 clock cycles\n#endif\n                irparams.rawbuf[irparams.rawlen++] = irparams.TickCounterForISR; // record space\n                irparams.StateForISR = IR_REC_STATE_MARK;\n            }\n            irparams.TickCounterForISR = 0;\n\n        } else if (irparams.TickCounterForISR > RECORD_GAP_TICKS) {\n            /*\n             * Maximum space duration reached here.\n             * Current code is ready for processing!\n             * We received a long space, which indicates gap between codes.\n             * Switch to IR_REC_STATE_STOP\n             * Don't reset TickCounterForISR; keep counting width of next leading space\n             */\n            irparams.StateForISR = IR_REC_STATE_STOP;\n#if !IR_REMOTE_DISABLE_RECEIVE_COMPLETE_CALLBACK\n            /*\n             * Call callback if registered (not NULL)\n             */\n            if (irparams.ReceiveCompleteCallbackFunction != NULL) {\n                irparams.ReceiveCompleteCallbackFunction();\n            }\n#endif\n        }\n    } else if (irparams.StateForISR == IR_REC_STATE_STOP) {\n        /*\n         * Complete command received\n         * stay here until resume() is called, which switches state to IR_REC_STATE_IDLE\n         */\n#if defined(_IR_MEASURE_TIMING) && defined(_IR_TIMING_TEST_PIN)\n//        digitalWriteFast(_IR_TIMING_TEST_PIN, HIGH); // 2 clock cycles\n#endif\n        if (tIRInputLevel == INPUT_MARK) {\n            // Reset gap TickCounterForISR, to prepare for detection if we are in the middle of a transmission after call of resume()\n            irparams.TickCounterForISR = 0;\n        }\n    }\n\n#if !defined(NO_LED_FEEDBACK_CODE)\n    if (FeedbackLEDControl.LedFeedbackEnabled == LED_FEEDBACK_ENABLED_FOR_RECEIVE) {\n        setFeedbackLED(tIRInputLevel == INPUT_MARK);\n    }\n#endif\n\n#ifdef _IR_MEASURE_TIMING\n    digitalWriteFast(_IR_TIMING_TEST_PIN, LOW); // 2 clock cycles\n#endif\n\n}\n\n/*\n * The ISR, which calls the interrupt handler\n */\n#if defined(TIMER_INTR_NAME) || defined(ISR)\n#  if defined(TIMER_INTR_NAME)\nISR (TIMER_INTR_NAME) // for ISR definitions\n#  elif defined(ISR)\nISR()\n// for functions definitions which are called by separate (board specific) ISR\n#  endif\n{\n    IRReceiveTimerInterruptHandler();\n}\n#endif\n\n/**********************************************************************************************************************\n * Stream like API\n **********************************************************************************************************************/\n/**\n * Initializes the receive and feedback pin\n * @param aReceivePin The Arduino pin number, where a demodulating IR receiver is connected.\n * @param aEnableLEDFeedback if true / ENABLE_LED_FEEDBACK, then let the feedback led blink on receiving IR signal\n * @param aFeedbackLEDPin if 0 / USE_DEFAULT_FEEDBACK_LED_PIN, then take board specific FEEDBACK_LED_ON() and FEEDBACK_LED_OFF() functions\n */\nvoid IRrecv::begin(uint_fast8_t aReceivePin, bool aEnableLEDFeedback, uint_fast8_t aFeedbackLEDPin) {\n\n    setReceivePin(aReceivePin);\n#if !defined(NO_LED_FEEDBACK_CODE)\n    uint_fast8_t tEnableLEDFeedback = DO_NOT_ENABLE_LED_FEEDBACK;\n    if (aEnableLEDFeedback) {\n        tEnableLEDFeedback = LED_FEEDBACK_ENABLED_FOR_RECEIVE;\n    }\n    setLEDFeedback(aFeedbackLEDPin, tEnableLEDFeedback);\n#else\n    (void) aEnableLEDFeedback;\n    (void) aFeedbackLEDPin;\n#endif\n\n#if defined(_IR_MEASURE_TIMING) && defined(_IR_TIMING_TEST_PIN)\n    pinModeFast(_IR_TIMING_TEST_PIN, OUTPUT);\n#endif\n    start();\n}\n\n/**\n * Sets / changes the receiver pin number\n */\nvoid IRrecv::setReceivePin(uint_fast8_t aReceivePinNumber) {\n    irparams.IRReceivePin = aReceivePinNumber;\n#if defined(__AVR__)\n#  if defined(__digitalPinToBit)\n    if (__builtin_constant_p(aReceivePinNumber)) {\n        irparams.IRReceivePinMask = 1UL << (__digitalPinToBit(aReceivePinNumber));\n    } else {\n        irparams.IRReceivePinMask = digitalPinToBitMask(aReceivePinNumber); // requires 10 bytes PGM, even if not referenced (?because it is assembler code?)\n    }\n#  else\n    irparams.IRReceivePinMask = digitalPinToBitMask(aReceivePinNumber); // requires 10 bytes PGM, even if not referenced (?because it is assembler code?)\n#  endif\n#  if defined(__digitalPinToPINReg)\n    /*\n     * This code is 54 bytes smaller, if aReceivePinNumber is a constant :-), but 38 byte longer if it is not constant (,which is not likely).\n     */\n    if (__builtin_constant_p(aReceivePinNumber)) {\n        irparams.IRReceivePinPortInputRegister = __digitalPinToPINReg(aReceivePinNumber);\n    } else {\n        irparams.IRReceivePinPortInputRegister = portInputRegister(digitalPinToPort(aReceivePinNumber)); // requires 44 bytes PGM, even if not referenced\n    }\n#  else\n    irparams.IRReceivePinPortInputRegister = portInputRegister(digitalPinToPort(aReceivePinNumber)); // requires 44 bytes PGM, even if not referenced\n#  endif\n#endif\n    // Set pin mode once. pinModeFast makes no difference if used, but saves 224 if not referenced :-(\n    pinModeFast(aReceivePinNumber, INPUT); // Seems to be at least required by ESP32\n}\n\n/**\n * Sets the function to call if a protocol message has arrived\n */\nvoid IRrecv::registerReceiveCompleteCallback(void (*aReceiveCompleteCallbackFunction)(void)) {\n    irparams.ReceiveCompleteCallbackFunction = aReceiveCompleteCallbackFunction;\n}\n\n/**\n * Start the receiving process.\n * This configures the timer and the state machine for IR reception\n * and enables the receive sample timer interrupt which consumes a small amount of CPU every 50 us.\n */\nvoid IRrecv::start() {\n\n    // Setup for cyclic 50 us interrupt\n    timerConfigForReceive(); // no interrupts enabled here!\n\n    // Initialize state machine state\n    resume();\n\n    // Timer interrupt is enabled after state machine reset\n    timerEnableReceiveInterrupt(); // Enables the receive sample timer interrupt which consumes a small amount of CPU every 50 us.\n#ifdef _IR_MEASURE_TIMING\n    pinModeFast(_IR_TIMING_TEST_PIN, OUTPUT);\n#endif\n}\n\n/*\n * Do not resume() reading of IR data\n */\nvoid IRrecv::restartTimer() {\n    // Setup for cyclic 50 us interrupt\n    timerConfigForReceive(); // no interrupts enabled here!\n    // Timer interrupt is enabled after state machine reset\n    timerEnableReceiveInterrupt(); // Enables the receive sample timer interrupt which consumes a small amount of CPU every 50 us.\n#ifdef _IR_MEASURE_TIMING\n    pinModeFast(_IR_TIMING_TEST_PIN, OUTPUT);\n#endif\n}\n/**\n * Alias for start().\n */\nvoid IRrecv::enableIRIn() {\n    start();\n}\n\n/**\n * Configures the timer and the state machine for IR reception.\n * The tick counter value is already at 100 when decode() gets true, because of the 5000 us minimal gap defined in RECORD_GAP_MICROS.\n * @param aMicrosecondsToAddToGapCounter To compensate for the amount of microseconds the timer was stopped / disabled.\n */\nvoid IRrecv::start(uint32_t aMicrosecondsToAddToGapCounter) {\n    irparams.TickCounterForISR += aMicrosecondsToAddToGapCounter / MICROS_PER_TICK;\n    start();\n}\nvoid IRrecv::restartTimer(uint32_t aMicrosecondsToAddToGapCounter) {\n    irparams.TickCounterForISR += aMicrosecondsToAddToGapCounter / MICROS_PER_TICK;\n    restartTimer();\n}\nvoid IRrecv::startWithTicksToAdd(uint16_t aTicksToAddToGapCounter) {\n    irparams.TickCounterForISR += aTicksToAddToGapCounter;\n    start();\n}\nvoid IRrecv::restartTimerWithTicksToAdd(uint16_t aTicksToAddToGapCounter) {\n    irparams.TickCounterForISR += aTicksToAddToGapCounter;\n    restartTimer();\n}\n\nvoid IRrecv::addTicksToInternalTickCounter(uint16_t aTicksToAddToInternalTickCounter) {\n    irparams.TickCounterForISR += aTicksToAddToInternalTickCounter;\n}\n\nvoid IRrecv::addMicrosToInternalTickCounter(uint16_t aMicrosecondsToAddToInternalTickCounter) {\n    irparams.TickCounterForISR += aMicrosecondsToAddToInternalTickCounter / MICROS_PER_TICK;\n}\n/**\n * Restarts receiver after send. Is a NOP if sending does not require a timer.\n */\nvoid IRrecv::restartAfterSend() {\n#if defined(SEND_PWM_BY_TIMER) && !defined(SEND_PWM_DOES_NOT_USE_RECEIVE_TIMER)\n    start();\n#endif\n}\n\n/**\n * Disables the timer for IR reception.\n */\nvoid IRrecv::stop() {\n    timerDisableReceiveInterrupt();\n}\n\nvoid IRrecv::stopTimer() {\n    timerDisableReceiveInterrupt();\n}\n/**\n * Alias for stop().\n */\nvoid IRrecv::disableIRIn() {\n    stop();\n}\n/**\n * Alias for stop().\n */\nvoid IRrecv::end() {\n    stop();\n}\n\n/**\n * Returns status of reception\n * @return true if no reception is on-going.\n */\nbool IRrecv::isIdle() {\n    return (irparams.StateForISR == IR_REC_STATE_IDLE || irparams.StateForISR == IR_REC_STATE_STOP) ? true : false;\n}\n\n/**\n * Restart the ISR (Interrupt Service Routine) state machine, to enable receiving of the next IR frame.\n * Internal counting of gap timing is independent of StateForISR and therefore independent of call time of resume().\n */\nvoid IRrecv::resume() {\n    // This check allows to call resume at arbitrary places or more than once\n    if (irparams.StateForISR == IR_REC_STATE_STOP) {\n        irparams.StateForISR = IR_REC_STATE_IDLE;\n    }\n}\n\n/**\n * Is internally called by decode before calling decoders.\n * Must be used to setup data, if you call decoders manually.\n */\nvoid IRrecv::initDecodedIRData() {\n\n    if (irparams.OverflowFlag) {\n        decodedIRData.flags = IRDATA_FLAGS_WAS_OVERFLOW;\n#if defined(LOCAL_DEBUG)\n        Serial.print(F(\"Overflow happened, try to increase the \\\"RAW_BUFFER_LENGTH\\\" value of \"));\n        Serial.print(RAW_BUFFER_LENGTH);\n        Serial.println(F(\" with #define RAW_BUFFER_LENGTH=<biggerValue>\"));\n#endif\n\n    } else {\n        decodedIRData.flags = IRDATA_FLAGS_EMPTY;\n        // save last protocol, command and address for repeat handling (where they are compared or copied back :-))\n        lastDecodedProtocol = decodedIRData.protocol; // repeat patterns can be equal between protocols (e.g. NEC, Samsung and LG), so we must keep the original one\n        lastDecodedCommand = decodedIRData.command;\n        lastDecodedAddress = decodedIRData.address;\n\n    }\n\n    //These 2 variables allow to call resume() directly after decode, if no dump is required. since 4.3.0.\n    decodedIRData.initialGap = decodedIRData.rawDataPtr->rawbuf[0];\n    decodedIRData.rawlen = decodedIRData.rawDataPtr->rawlen;\n\n    decodedIRData.protocol = UNKNOWN;\n    decodedIRData.command = 0;\n    decodedIRData.address = 0;\n    decodedIRData.decodedRawData = 0;\n    decodedIRData.numberOfBits = 0;\n}\n\n/**\n * Returns true if IR receiver data is available.\n */\nbool IRrecv::available() {\n    return (irparams.StateForISR == IR_REC_STATE_STOP);\n}\n\n/**\n * If IR receiver data is available, returns pointer to IrReceiver.decodedIRData, else NULL.\n */\nIRData* IRrecv::read() {\n    if (irparams.StateForISR != IR_REC_STATE_STOP) {\n        return NULL;\n    }\n    if (decode()) {\n        return &decodedIRData;\n    } else {\n        return NULL;\n    }\n}\n\n/**\n * The main decode function, attempts to decode the recently receive IR signal.\n * The set of decoders used is determined by active definitions of the DECODE_<PROTOCOL> macros.\n * Results of decoding are stored in IrReceiver.decodedIRData.* like e.g. IrReceiver.decodedIRData.command.\n * @return false if no IR receiver data available, true if data available.\n */\nbool IRrecv::decode() {\n    if (irparams.StateForISR != IR_REC_STATE_STOP) {\n        return false;\n    }\n\n    initDecodedIRData(); // sets IRDATA_FLAGS_WAS_OVERFLOW\n\n    if (decodedIRData.flags & IRDATA_FLAGS_WAS_OVERFLOW) {\n        /*\n         * Set OverflowFlag flag and return true here, to let the loop call resume or print raw data.\n         */\n        decodedIRData.protocol = UNKNOWN;\n        return true;\n    }\n\n#if defined(DECODE_NEC) || defined(DECODE_ONKYO)\n    IR_TRACE_PRINTLN(F(\"Attempting NEC/Onkyo decode\"));\n    if (decodeNEC()) {\n        return true;\n    }\n#endif\n\n#if defined(DECODE_PANASONIC) || defined(DECODE_KASEIKYO)\n    IR_TRACE_PRINTLN(F(\"Attempting Panasonic/Kaseikyo decode\"));\n    if (decodeKaseikyo()) {\n        return true;\n    }\n#endif\n\n#if defined(DECODE_DENON)\n    IR_TRACE_PRINTLN(F(\"Attempting Denon/Sharp decode\"));\n    if (decodeDenon()) {\n        return true;\n    }\n#endif\n\n#if defined(DECODE_SONY)\n    IR_TRACE_PRINTLN(F(\"Attempting Sony decode\"));\n    if (decodeSony()) {\n        return true;\n    }\n#endif\n\n#if defined(DECODE_RC5)\n    IR_TRACE_PRINTLN(F(\"Attempting RC5 decode\"));\n    if (decodeRC5()) {\n        return true;\n    }\n#endif\n\n#if defined(DECODE_RC6)\n    IR_TRACE_PRINTLN(F(\"Attempting RC6 decode\"));\n    if (decodeRC6()) {\n        return true;\n    }\n#endif\n\n#if defined(DECODE_LG)\n    IR_TRACE_PRINTLN(F(\"Attempting LG decode\"));\n    if (decodeLG()) {\n        return true;\n    }\n#endif\n\n#if defined(DECODE_JVC)\n    IR_TRACE_PRINTLN(F(\"Attempting JVC decode\"));\n    if (decodeJVC()) {\n        return true;\n    }\n#endif\n\n#if defined(DECODE_SAMSUNG)\n    IR_TRACE_PRINTLN(F(\"Attempting Samsung decode\"));\n    if (decodeSamsung()) {\n        return true;\n    }\n#endif\n    /*\n     * Start of the exotic protocols\n     */\n\n#if defined(DECODE_BEO)\n    IR_TRACE_PRINTLN(F(\"Attempting Bang & Olufsen decode\"));\n    if (decodeBangOlufsen()) {\n        return true;\n    }\n#endif\n\n#if defined(DECODE_FAST)\n    IR_TRACE_PRINTLN(F(\"Attempting FAST decode\"));\n    if (decodeFAST()) {\n        return true;\n    }\n#endif\n\n#if defined(DECODE_WHYNTER)\n    IR_TRACE_PRINTLN(F(\"Attempting Whynter decode\"));\n    if (decodeWhynter()) {\n        return true;\n    }\n#endif\n\n#if defined(DECODE_LEGO_PF)\n    IR_TRACE_PRINTLN(F(\"Attempting Lego Power Functions\"));\n    if (decodeLegoPowerFunctions()) {\n        return true;\n    }\n#endif\n\n#if defined(DECODE_BOSEWAVE)\n    IR_TRACE_PRINTLN(F(\"Attempting Bosewave  decode\"));\n    if (decodeBoseWave()) {\n        return true;\n    }\n#endif\n\n#if defined(DECODE_MAGIQUEST)\n    IR_TRACE_PRINTLN(F(\"Attempting MagiQuest decode\"));\n    if (decodeMagiQuest()) {\n        return true;\n    }\n#endif\n\n    /*\n     * Try the universal decoder for pulse distance protocols\n     */\n#if defined(DECODE_DISTANCE_WIDTH)\n    IR_TRACE_PRINTLN(F(\"Attempting universal Distance Width decode\"));\n    if (decodeDistanceWidth()) {\n        return true;\n    }\n#endif\n\n    /*\n     * Last resort is the universal hash decode which always return true\n     */\n#if defined(DECODE_HASH)\n    IR_TRACE_PRINTLN(F(\"Hash decode\"));\n    // decodeHash returns a hash on any input.\n    // Thus, it needs to be last in the list.\n    // If you add any decodes, add them before this.\n    if (decodeHash()) {\n        return true;\n    }\n#endif\n\n    /*\n     * Return true here, to let the loop decide to call resume or to print raw data.\n     */\n    return true;\n}\n\n/**********************************************************************************************************************\n * Common decode functions\n **********************************************************************************************************************/\n/**\n * Decode pulse distance width protocols.\n *\n * We can have the following protocol timings\n * Pulse distance:          Pulses/marks are constant, pause/spaces have different length, like NEC.\n * Pulse width:             Pulses/marks have different length, pause/spaces are constant, like Sony.\n * Pulse distance width:    Pulses/marks and pause/spaces have different length, often the bit length is constant, like MagiQuest.\n * Pulse distance width can be decoded like pulse width decoder, if this decoder does not check the length of pause/spaces.\n *\n * Input is     IrReceiver.decodedIRData.rawDataPtr->rawbuf[]\n * Output is    IrReceiver.decodedIRData.decodedRawData\n *\n * Assume pulse distance if aOneMarkMicros == aZeroMarkMicros\n *\n * @param   aNumberOfBits       Number of bits to decode from decodedIRData.rawDataPtr->rawbuf[] array.\n * @param   aStartOffset        Offset in decodedIRData.rawDataPtr->rawbuf[] to start decoding. Must point to a mark.\n * @param   aOneMarkMicros      Taken as constant BitMarkMicros for pulse distance.\n * @param   aZeroMarkMicros     Not required if DECODE_STRICT_CHECKS is not defined.\n * @param   aOneSpaceMicros     Taken as (constant) BitSpaceMicros for pulse width.\n * @param   aZeroSpaceMicros    Not required if DECODE_STRICT_CHECKS is not defined.\n * @param   aMSBfirst           If true send Most Significant Bit first, else send Least Significant Bit (lowest bit) first.\n * @return  true                If decoding was successful\n */\nbool IRrecv::decodePulseDistanceWidthData(uint_fast8_t aNumberOfBits, IRRawlenType aStartOffset, uint16_t aOneMarkMicros,\n        uint16_t aZeroMarkMicros, uint16_t aOneSpaceMicros, uint16_t aZeroSpaceMicros, bool aMSBfirst) {\n\n    auto *tRawBufPointer = &decodedIRData.rawDataPtr->rawbuf[aStartOffset];\n\n    bool isPulseDistanceProtocol = (aOneMarkMicros == aZeroMarkMicros); // If true, we have a constant mark -> pulse distance protocol\n\n    IRRawDataType tDecodedData = 0; // For MSB first tDecodedData is shifted left each loop\n    IRRawDataType tMask = 1UL; // Mask is only used for LSB first\n\n    for (uint_fast8_t i = aNumberOfBits; i > 0; i--) {\n        // get one mark and space pair\n        unsigned int tMarkTicks;\n        unsigned int tSpaceTicks;\n        bool tBitValue;\n\n        if (isPulseDistanceProtocol) {\n            /*\n             * Pulse distance here, it is not required to check constant mark duration (aOneMarkMicros) and zero space duration.\n             */\n#if defined DECODE_STRICT_CHECKS\n            tMarkTicks = *tRawBufPointer++;\n#else\n            (void) aZeroSpaceMicros;\n            tRawBufPointer++;\n#endif\n            tSpaceTicks = *tRawBufPointer++; // maybe buffer overflow for last bit, but we do not evaluate this value :-)\n            tBitValue = matchSpace(tSpaceTicks, aOneSpaceMicros); // Check for variable length space indicating a 1 or 0\n\n#if defined DECODE_STRICT_CHECKS\n            // Check for constant length mark\n            if (!matchMark(tMarkTicks, aOneMarkMicros)) {\n#  if defined(LOCAL_DEBUG)\n                Serial.print(F(\"Mark=\"));\n                Serial.print(tMarkTicks * MICROS_PER_TICK);\n                Serial.print(F(\" is not \"));\n                Serial.print(aOneMarkMicros);\n                Serial.print(F(\". Index=\"));\n                Serial.print(aNumberOfBits - i);\n                Serial.print(' ');\n#  endif\n                return false;\n            }\n#endif\n\n        } else {\n            /*\n             * Pulse width here, it is not required to check (constant) space duration and zero mark duration.\n             */\n            tMarkTicks = *tRawBufPointer++;\n            tBitValue = matchMark(tMarkTicks, aOneMarkMicros); // Check for variable length mark indicating a 1 or 0\n\n#if defined DECODE_STRICT_CHECKS\n            tSpaceTicks = *tRawBufPointer++; // maybe buffer overflow for last bit, but we do not evaluate this value :-)\n#else\n            (void) aZeroMarkMicros;\n            (void) aZeroSpaceMicros;\n            tRawBufPointer++;\n#endif\n        }\n\n        if (aMSBfirst) {\n            tDecodedData <<= 1;\n        }\n\n        if (tBitValue) {\n            // It's a 1 -> set the bit\n            if (aMSBfirst) {\n                tDecodedData |= 1;\n            } else {\n                tDecodedData |= tMask;\n            }\n            IR_TRACE_PRINTLN(F(\"=> 1\"));\n        } else {\n#if defined DECODE_STRICT_CHECKS\n            /*\n             * Additionally check length of length parameter which determine a zero\n             */\n            if (isPulseDistanceProtocol) {\n                if (!matchSpace(tSpaceTicks, aZeroSpaceMicros)) {\n#  if defined(LOCAL_DEBUG)\n                    Serial.print(F(\"Space=\"));\n                    Serial.print(tSpaceTicks * MICROS_PER_TICK);\n                    Serial.print(F(\" is not \"));\n                    Serial.print(aOneSpaceMicros);\n                    Serial.print(F(\" or \"));\n                    Serial.print(aZeroSpaceMicros);\n                    Serial.print(F(\". Index=\"));\n                    Serial.print(aNumberOfBits - i);\n                    Serial.print(' ');\n#  endif\n                    return false;\n                }\n            } else {\n                if (!matchMark(tMarkTicks, aZeroMarkMicros)) {\n#  if defined(LOCAL_DEBUG)\n                    Serial.print(F(\"Mark=\"));\n                    Serial.print(tMarkTicks * MICROS_PER_TICK);\n                    Serial.print(F(\" is not \"));\n                    Serial.print(aOneMarkMicros);\n                    Serial.print(F(\" or \"));\n                    Serial.print(aZeroMarkMicros);\n                    Serial.print(F(\". Index=\"));\n                    Serial.print(aNumberOfBits - i);\n                    Serial.print(' ');\n#  endif\n                    return false;\n                }\n            }\n#endif\n            // do not set the bit\n            IR_TRACE_PRINTLN(F(\"=> 0\"));\n        }\n#if defined DECODE_STRICT_CHECKS\n        // If we have no stop bit, assume that last space, which is not recorded, is correct, since we can not check it\n        if (aZeroSpaceMicros == aOneSpaceMicros\n                && tRawBufPointer < &decodedIRData.rawDataPtr->rawbuf[decodedIRData.rawDataPtr->rawlen]) {\n            // Check for constant length space (of pulse width protocol) here\n            if (!matchSpace(tSpaceTicks, aOneSpaceMicros)) {\n#  if defined(LOCAL_DEBUG)\n                Serial.print(F(\"Space=\"));\n                Serial.print(tSpaceTicks * MICROS_PER_TICK);\n                Serial.print(F(\" is not \"));\n                Serial.print(aOneSpaceMicros);\n                Serial.print(F(\". Index=\"));\n                Serial.print(aNumberOfBits - i);\n                Serial.print(' ');\n#  endif\n                return false;\n            }\n        }\n#endif\n        tMask <<= 1;\n    }\n    decodedIRData.decodedRawData = tDecodedData;\n    return true;\n}\n\n/**\n * Decode pulse distance protocols for PulseDistanceWidthProtocolConstants.\n * @return  true if decoding was successful\n */\nbool IRrecv::decodePulseDistanceWidthData(PulseDistanceWidthProtocolConstants *aProtocolConstants, uint_fast8_t aNumberOfBits,\n        IRRawlenType aStartOffset) {\n\n    return decodePulseDistanceWidthData(aNumberOfBits, aStartOffset, aProtocolConstants->DistanceWidthTimingInfo.OneMarkMicros,\n            aProtocolConstants->DistanceWidthTimingInfo.ZeroMarkMicros, aProtocolConstants->DistanceWidthTimingInfo.OneSpaceMicros,\n            aProtocolConstants->DistanceWidthTimingInfo.ZeroSpaceMicros, aProtocolConstants->Flags);\n}\n\n/*\n * Static variables for the getBiphaselevel function\n */\nuint_fast8_t sBiphaseDecodeRawbuffOffset;   // Index into raw timing array\nuint16_t sBiphaseCurrentTimingIntervals;    // 1, 2 or 3. Number of aBiphaseTimeUnit intervals of the current rawbuf[sBiphaseDecodeRawbuffOffset] timing.\nuint_fast8_t sBiphaseUsedTimingIntervals;   // Number of already used intervals of sCurrentTimingIntervals.\nuint16_t sBiphaseTimeUnit;\n\nvoid IRrecv::initBiphaselevel(uint_fast8_t aRCDecodeRawbuffOffset, uint16_t aBiphaseTimeUnit) {\n    sBiphaseDecodeRawbuffOffset = aRCDecodeRawbuffOffset;\n    sBiphaseTimeUnit = aBiphaseTimeUnit;\n    sBiphaseUsedTimingIntervals = 0;\n}\n\n/**\n * Gets the level of one time interval (aBiphaseTimeUnit) at a time from the raw buffer.\n * The RC5/6 decoding is easier if the data is broken into time intervals.\n * E.g. if the buffer has mark for 2 time intervals and space for 1,\n * successive calls to getBiphaselevel will return 1, 1, 0.\n *\n *               _   _   _   _   _   _   _   _   _   _   _   _   _\n *         _____| |_| |_| |_| |_| |_| |_| |_| |_| |_| |_| |_| |_| |\n *                ^   ^   ^   ^   ^   ^   ^   ^   ^   ^   ^   ^   ^    Significant clock edge\n *               _     _   _   ___   _     ___     ___   _   - Mark\n * Data    _____| |___| |_| |_|   |_| |___|   |___|   |_| |  - Data starts with a mark->space bit\n *                1   0   0   0   1   1   0   1   0   1   1  - Space\n * A mark to space at a significant clock edge results in a 1\n * A space to mark at a significant clock edge results in a 0 (for RC6)\n * Returns current level [MARK or SPACE] or -1 for error (measured time interval is not a multiple of sBiphaseTimeUnit).\n */\nuint_fast8_t IRrecv::getBiphaselevel() {\n    uint_fast8_t tLevelOfCurrentInterval; // 0 (SPACE) or 1 (MARK)\n\n    if (sBiphaseDecodeRawbuffOffset >= decodedIRData.rawlen) {\n        return SPACE;  // After end of recorded buffer, assume space.\n    }\n\n    tLevelOfCurrentInterval = (sBiphaseDecodeRawbuffOffset) & 1; // on odd rawbuf offsets we have mark timings\n\n    /*\n     * Setup data if sUsedTimingIntervals is 0\n     */\n    if (sBiphaseUsedTimingIntervals == 0) {\n        uint16_t tCurrentTimingWith = decodedIRData.rawDataPtr->rawbuf[sBiphaseDecodeRawbuffOffset];\n        uint16_t tMarkExcessCorrection = (tLevelOfCurrentInterval == MARK) ? MARK_EXCESS_MICROS : -MARK_EXCESS_MICROS;\n\n        if (matchTicks(tCurrentTimingWith, sBiphaseTimeUnit + tMarkExcessCorrection)) {\n            sBiphaseCurrentTimingIntervals = 1;\n        } else if (matchTicks(tCurrentTimingWith, (2 * sBiphaseTimeUnit) + tMarkExcessCorrection)) {\n            sBiphaseCurrentTimingIntervals = 2;\n        } else if (matchTicks(tCurrentTimingWith, (3 * sBiphaseTimeUnit) + tMarkExcessCorrection)) {\n            sBiphaseCurrentTimingIntervals = 3;\n        } else {\n            return -1;\n        }\n    }\n\n// We use another interval from tCurrentTimingIntervals\n    sBiphaseUsedTimingIntervals++;\n\n// keep track of current timing offset\n    if (sBiphaseUsedTimingIntervals >= sBiphaseCurrentTimingIntervals) {\n        // we have used all intervals of current timing, switch to next timing value\n        sBiphaseUsedTimingIntervals = 0;\n        sBiphaseDecodeRawbuffOffset++;\n    }\n\n    IR_TRACE_PRINTLN(tLevelOfCurrentInterval);\n\n    return tLevelOfCurrentInterval;\n}\n\n/**********************************************************************************************************************\n * Internal Hash decode function\n **********************************************************************************************************************/\n#define FNV_PRIME_32 16777619   ///< used for decodeHash()\n#define FNV_BASIS_32 2166136261 ///< used for decodeHash()\n\n/**\n * Compare two (tick) values for Hash decoder\n * Use a tolerance of 20% to enable e.g. 500 and 600 (NEC timing) to be equal\n * @return  0 if newval is shorter, 1 if newval is equal, and 2 if newval is longer\n */\nuint_fast8_t IRrecv::compare(uint16_t oldval, uint16_t newval) {\n    if (newval * 10 < oldval * 8) {\n        return 0;\n    }\n    if (oldval * 10 < newval * 8) {\n        return 2;\n    }\n    return 1;\n}\n\n/**\n * decodeHash - decode an arbitrary IR code.\n * Instead of decoding using a standard encoding scheme\n * (e.g. Sony, NEC, RC5), the code is hashed to a 32-bit value.\n *\n * The algorithm: look at the sequence of MARK and SPACE signals, and see if each one\n * is shorter (0), the same length (1), or longer (2) than the previous MARK or SPACE.\n * Hash the resulting sequence of 0's, 1's, and 2's to a 32-bit value.\n * This will give a unique value for each different code (probably), for most code systems.\n *\n * Use FNV hash algorithm: http://isthe.com/chongo/tech/comp/fnv/#FNV-param\n * Converts the raw code values into a 32-bit hash code.\n * Hopefully this code is unique for each button.\n * This isn't a \"real\" decoding, just an arbitrary value.\n *\n * see: http://www.righto.com/2010/01/using-arbitrary-remotes-with-arduino.html\n */\nbool IRrecv::decodeHash() {\n    unsigned long hash = FNV_BASIS_32; // the result is the same no matter if we use a long or unsigned long variable\n\n// Require at least 6 samples to prevent triggering on noise\n    if (decodedIRData.rawlen < 6) {\n        return false;\n    }\n    for (IRRawlenType i = 1; (i + 2) < decodedIRData.rawlen; i++) {\n        // Compare mark with mark and space with space\n        uint_fast8_t value = compare(decodedIRData.rawDataPtr->rawbuf[i], decodedIRData.rawDataPtr->rawbuf[i + 2]);\n        // Add value into the hash\n        hash = (hash * FNV_PRIME_32) ^ value;\n    }\n\n    decodedIRData.decodedRawData = hash;\n    decodedIRData.numberOfBits = 32;\n    decodedIRData.protocol = UNKNOWN;\n\n    return true;\n}\n\nbool IRrecv::decodeHashOld(decode_results *aResults) {\n    unsigned long hash = FNV_BASIS_32;\n\n// Require at least 6 samples to prevent triggering on noise\n    if (aResults->rawlen < 6) {\n        return false;\n    }\n\n    for (uint8_t i = 3; i < aResults->rawlen; i++) {\n        uint_fast8_t value = compare(aResults->rawbuf[i - 2], aResults->rawbuf[i]);\n        // Add value into the hash\n        hash = (hash * FNV_PRIME_32) ^ value;\n    }\n\n    aResults->value = hash;\n    aResults->bits = 32;\n    aResults->decode_type = UNKNOWN;\n    decodedIRData.protocol = UNKNOWN;\n\n    return true;\n}\n\n/**********************************************************************************************************************\n * Match functions\n **********************************************************************************************************************/\n\n/*\n * returns true if values do match\n */\nbool IRrecv::checkHeader(PulseDistanceWidthProtocolConstants *aProtocolConstants) {\n// Check header \"mark\" and \"space\"\n    if (!matchMark(decodedIRData.rawDataPtr->rawbuf[1], aProtocolConstants->DistanceWidthTimingInfo.HeaderMarkMicros)) {\n#if defined(LOCAL_TRACE)\n        Serial.print(::getProtocolString(aProtocolConstants->ProtocolIndex));\n        Serial.println(F(\": Header mark length is wrong\"));\n#endif\n        return false;\n    }\n    if (!matchSpace(decodedIRData.rawDataPtr->rawbuf[2], aProtocolConstants->DistanceWidthTimingInfo.HeaderSpaceMicros)) {\n#if defined(LOCAL_TRACE)\n        Serial.print(::getProtocolString(aProtocolConstants->ProtocolIndex));\n        Serial.println(F(\": Header space length is wrong\"));\n#endif\n        return false;\n    }\n    return true;\n}\n\n/*\n * Do not check for same address and command, because it is almost not possible to press 2 different buttons on the remote within around 100 ms.\n * And if really required, it can be enabled here, or done manually in user program.\n * And we have still no RC6 toggle bit check for detecting a second press on the same button.\n */\nvoid IRrecv::checkForRepeatSpaceTicksAndSetFlag(uint16_t aMaximumRepeatSpaceTicks) {\n    if (decodedIRData.rawDataPtr->rawbuf[0] < aMaximumRepeatSpaceTicks\n#if defined(ENABLE_FULL_REPEAT_CHECK)\n            && decodedIRData.address == lastDecodedAddress && decodedIRData.command == lastDecodedCommand /* requires around 85 bytes program space */\n#endif\n            ) {\n        decodedIRData.flags |= IRDATA_FLAGS_IS_REPEAT;\n    }\n}\n\n/**\n * Match function without compensating for marks exceeded or spaces shortened by demodulator hardware\n * Currently not used\n */\nbool matchTicks(uint16_t aMeasuredTicks, uint16_t aMatchValueMicros) {\n#if defined(LOCAL_TRACE)\n    Serial.print(F(\"Testing: \"));\n    Serial.print(TICKS_LOW(aMatchValueMicros), DEC);\n    Serial.print(F(\" <= \"));\n    Serial.print(aMeasuredTicks, DEC);\n    Serial.print(F(\" <= \"));\n    Serial.print(TICKS_HIGH(aMatchValueMicros), DEC);\n#endif\n    bool passed = ((aMeasuredTicks >= TICKS_LOW(aMatchValueMicros)) && (aMeasuredTicks <= TICKS_HIGH(aMatchValueMicros)));\n#if defined(LOCAL_TRACE)\n    if (passed) {\n        Serial.println(F(\" => passed\"));\n    } else {\n        Serial.println(F(\" => FAILED\"));\n    }\n#endif\n    return passed;\n}\n\nbool MATCH(uint16_t measured_ticks, uint16_t desired_us) {\n    return matchTicks(measured_ticks, desired_us);\n}\n\n/**\n * Compensate for marks exceeded by demodulator hardware\n */\nbool matchMark(uint16_t aMeasuredTicks, uint16_t aMatchValueMicros) {\n#if defined(LOCAL_TRACE)\n    Serial.print(F(\"Testing mark (actual vs desired): \"));\n    Serial.print(aMeasuredTicks * MICROS_PER_TICK, DEC);\n    Serial.print(F(\"us vs \"));\n    Serial.print(aMatchValueMicros, DEC);\n    Serial.print(F(\"us: \"));\n    Serial.print(TICKS_LOW(aMatchValueMicros + MARK_EXCESS_MICROS) * MICROS_PER_TICK, DEC);\n    Serial.print(F(\" <= \"));\n    Serial.print(aMeasuredTicks * MICROS_PER_TICK, DEC);\n    Serial.print(F(\" <= \"));\n    Serial.print(TICKS_HIGH(aMatchValueMicros + MARK_EXCESS_MICROS) * MICROS_PER_TICK, DEC);\n#endif\n    // compensate for marks exceeded by demodulator hardware\n    bool passed = ((aMeasuredTicks >= TICKS_LOW(aMatchValueMicros + MARK_EXCESS_MICROS))\n            && (aMeasuredTicks <= TICKS_HIGH(aMatchValueMicros + MARK_EXCESS_MICROS)));\n#if defined(LOCAL_TRACE)\n    if (passed) {\n        Serial.println(F(\" => passed\"));\n    } else {\n        Serial.println(F(\" => FAILED\"));\n    }\n#endif\n    return passed;\n}\n\nbool MATCH_MARK(uint16_t measured_ticks, uint16_t desired_us) {\n    return matchMark(measured_ticks, desired_us);\n}\n\n/**\n * Compensate for spaces shortened by demodulator hardware\n */\nbool matchSpace(uint16_t aMeasuredTicks, uint16_t aMatchValueMicros) {\n#if defined(LOCAL_TRACE)\n    Serial.print(F(\"Testing space (actual vs desired): \"));\n    Serial.print(aMeasuredTicks * MICROS_PER_TICK, DEC);\n    Serial.print(F(\"us vs \"));\n    Serial.print(aMatchValueMicros, DEC);\n    Serial.print(F(\"us: \"));\n    Serial.print(TICKS_LOW(aMatchValueMicros - MARK_EXCESS_MICROS) * MICROS_PER_TICK, DEC);\n    Serial.print(F(\" <= \"));\n    Serial.print(aMeasuredTicks * MICROS_PER_TICK, DEC);\n    Serial.print(F(\" <= \"));\n    Serial.print(TICKS_HIGH(aMatchValueMicros - MARK_EXCESS_MICROS) * MICROS_PER_TICK, DEC);\n#endif\n    // compensate for spaces shortened by demodulator hardware\n    bool passed = ((aMeasuredTicks >= TICKS_LOW(aMatchValueMicros - MARK_EXCESS_MICROS))\n            && (aMeasuredTicks <= TICKS_HIGH(aMatchValueMicros - MARK_EXCESS_MICROS)));\n#if defined(LOCAL_TRACE)\n    if (passed) {\n        Serial.println(F(\" => passed\"));\n    } else {\n        Serial.println(F(\" => FAILED\"));\n    }\n#endif\n    return passed;\n}\n\nbool MATCH_SPACE(uint16_t measured_ticks, uint16_t desired_us) {\n    return matchSpace(measured_ticks, desired_us);\n}\n\n/**\n * Getter function for MARK_EXCESS_MICROS\n */\nint getMarkExcessMicros() {\n    return MARK_EXCESS_MICROS;\n}\n\n/*\n * Check if protocol is not detected and detected space between two transmissions\n * is smaller than known value for protocols (Sony with around 24 ms)\n * @return true, if CheckForRecordGapsMicros() has printed a message, i.e. gap < 15ms (RECORD_GAP_MICROS_WARNING_THRESHOLD)\n */\nbool IRrecv::checkForRecordGapsMicros(Print *aSerial) {\n    /*\n     * Check if protocol is not detected and detected space between two transmissions\n     * is smaller than known value for protocols (Sony with around 24 ms)\n     */\n    if (decodedIRData.protocol <= PULSE_DISTANCE\n            && decodedIRData.initialGap < (RECORD_GAP_MICROS_WARNING_THRESHOLD / MICROS_PER_TICK)) {\n        aSerial->println();\n        aSerial->print(F(\"Space of \"));\n        aSerial->print(decodedIRData.initialGap * MICROS_PER_TICK);\n        aSerial->print(F(\" us between two detected transmission is smaller than the minimal gap of \"));\n        aSerial->print(RECORD_GAP_MICROS_WARNING_THRESHOLD);\n        aSerial->println(F(\" us known for implemented protocols like NEC, Sony, RC% etc..\"));\n        aSerial->println(F(\"But it can be OK for some yet unsupported protocols, and especially for repeats.\"));\n        aSerial->println(F(\"If you get unexpected results, try to increase the RECORD_GAP_MICROS in IRremote.h.\"));\n        aSerial->println();\n        return true;\n    }\n    return false;\n}\n\n/**********************************************************************************************************************\n * Print functions\n * Since a library should not allocate the \"Serial\" object, all functions require a pointer to a Print object.\n **********************************************************************************************************************/\nvoid IRrecv::printActiveIRProtocols(Print *aSerial) {\n// call no class function with same name\n    ::printActiveIRProtocols(aSerial);\n}\nvoid printActiveIRProtocols(Print *aSerial) {\n#if defined(DECODE_ONKYO)\n    aSerial->print(F(\"Onkyo, \"));\n#elif defined(DECODE_NEC)\n    aSerial->print(F(\"NEC/NEC2/Onkyo/Apple, \"));\n#endif\n#if defined(DECODE_PANASONIC) || defined(DECODE_KASEIKYO)\n    aSerial->print(F(\"Panasonic/Kaseikyo, \"));\n#endif\n#if defined(DECODE_DENON)\n    aSerial->print(F(\"Denon/Sharp, \"));\n#endif\n#if defined(DECODE_SONY)\n    aSerial->print(F(\"Sony, \"));\n#endif\n#if defined(DECODE_RC5)\n    aSerial->print(F(\"RC5, \"));\n#endif\n#if defined(DECODE_RC6)\n    aSerial->print(F(\"RC6, \"));\n#endif\n#if defined(DECODE_LG)\n    aSerial->print(F(\"LG, \"));\n#endif\n#if defined(DECODE_JVC)\n    aSerial->print(F(\"JVC, \"));\n#endif\n#if defined(DECODE_SAMSUNG)\n    aSerial->print(F(\"Samsung, \"));\n#endif\n    /*\n     * Start of the exotic protocols\n     */\n#if defined(DECODE_BEO)\n    aSerial->print(F(\"Bang & Olufsen, \"));\n#endif\n#if defined(DECODE_FAST)\n    aSerial->print(F(\"FAST, \"));\n#endif\n#if defined(DECODE_WHYNTER)\n    aSerial->print(F(\"Whynter, \"));\n#endif\n#if defined(DECODE_LEGO_PF)\n    aSerial->print(F(\"Lego Power Functions, \"));\n#endif\n#if defined(DECODE_BOSEWAVE)\n    aSerial->print(F(\"Bosewave , \"));\n#endif\n#if defined(DECODE_MAGIQUEST)\n    aSerial->print(F(\"MagiQuest, \"));\n#endif\n#if defined(DECODE_DISTANCE_WIDTH)\n    aSerial->print(F(\"Universal Pulse Distance Width, \"));\n#endif\n#if defined(DECODE_HASH)\n    aSerial->print(F(\"Hash \"));\n#endif\n#if defined(NO_DECODER) // for sending raw only\n    (void)aSerial; // to avoid compiler warnings\n#endif\n}\n\n/**\n * Function to print values and flags of IrReceiver.decodedIRData in one line.\n * Ends with println().\n *\n * @param aSerial   The Print object on which to write, for Arduino you can use &Serial.\n * @param aPrintRepeatGap     If true also print the gap before repeats.\n * @param aCheckForRecordGapsMicros   If true, call CheckForRecordGapsMicros() which may do a long printout,\n *                                    which in turn may block the proper detection of repeats.*\n * @return true, if CheckForRecordGapsMicros() has printed a message, i.e. gap < 15ms (RECORD_GAP_MICROS_WARNING_THRESHOLD).\n */\nbool IRrecv::printIRResultShort(Print *aSerial, bool aPrintRepeatGap, bool aCheckForRecordGapsMicros) {\n// call no class function with same name\n    ::printIRResultShort(aSerial, &decodedIRData, aPrintRepeatGap);\n    if (aCheckForRecordGapsMicros && decodedIRData.protocol != UNKNOWN) {\n        return checkForRecordGapsMicros(aSerial);\n    }\n    return false;\n}\n\nvoid IRrecv::printDistanceWidthTimingInfo(Print *aSerial, DistanceWidthTimingInfoStruct *aDistanceWidthTimingInfo) {\n    aSerial->print(aDistanceWidthTimingInfo->HeaderMarkMicros);\n    aSerial->print(F(\", \"));\n    aSerial->print(aDistanceWidthTimingInfo->HeaderSpaceMicros);\n    aSerial->print(F(\", \"));\n    aSerial->print(aDistanceWidthTimingInfo->OneMarkMicros);\n    aSerial->print(F(\", \"));\n    aSerial->print(aDistanceWidthTimingInfo->OneSpaceMicros);\n    aSerial->print(F(\", \"));\n    aSerial->print(aDistanceWidthTimingInfo->ZeroMarkMicros);\n    aSerial->print(F(\", \"));\n    aSerial->print(aDistanceWidthTimingInfo->ZeroSpaceMicros);\n}\n\nuint32_t IRrecv::getTotalDurationOfRawData() {\n    uint16_t tSumOfDurationTicks = 0;\n\n    for (IRRawlenType i = 1; i < decodedIRData.rawlen; i++) {\n        tSumOfDurationTicks += decodedIRData.rawDataPtr->rawbuf[i];\n    }\n    return tSumOfDurationTicks * (uint32_t) MICROS_PER_TICK;\n}\n\n/**\n * Function to print values and flags of IrReceiver.decodedIRData in one line.\n * Ends with println().\n * !!!Attention: The result differs on a 8 bit or 32 bit platform!!!\n *\n * @param aSerial The Print object on which to write, for Arduino you can use &Serial.\n */\nvoid IRrecv::printIRSendUsage(Print *aSerial) {\n    if (decodedIRData.flags & IRDATA_FLAGS_IS_PROTOCOL_WITH_DIFFERENT_REPEAT) {\n        /*\n         * Here we have a repeat of type NEC2 or SamsungLG. -> Inform the user to use this and not the initial protocol for sending.\n         */\n        Serial.print(F(\"!Use the \"));\n        Serial.print(getProtocolString());\n        Serial.println(F(\" protocol for sending!\"));\n    } else {\n        if (decodedIRData.protocol != UNKNOWN\n                && (decodedIRData.flags & (IRDATA_FLAGS_IS_AUTO_REPEAT | IRDATA_FLAGS_IS_REPEAT)) == 0x00) {\n#if defined(DECODE_DISTANCE_WIDTH)\n        uint_fast8_t tNumberOfArrayData = 0;\n        if (decodedIRData.protocol == PULSE_DISTANCE || decodedIRData.protocol == PULSE_WIDTH) {\n#  if __INT_WIDTH__ < 32\n            aSerial->print(F(\"Send on a 8 bit platform with: \"));\n            tNumberOfArrayData = ((decodedIRData.numberOfBits - 1) / 32) + 1;\n            if(tNumberOfArrayData > 1) {\n                aSerial->println();\n                aSerial->print(F(\"    uint32_t tRawData[]={0x\"));\n#  else\n                aSerial->print(F(\"Send on a 32 bit platform with: \"));\n            tNumberOfArrayData = ((decodedIRData.numberOfBits - 1) / 64) + 1;\n            if(tNumberOfArrayData > 1) {\n                aSerial->println();\n                aSerial->print(F(\"    uint64_t tRawData[]={0x\"));\n#  endif\n                for (uint_fast8_t i = 0; i < tNumberOfArrayData; ++i) {\n#  if (__INT_WIDTH__ < 32)\n                    aSerial->print(decodedIRData.decodedRawDataArray[i], HEX);\n#  else\n                    PrintULL::print(aSerial, decodedIRData.decodedRawDataArray[i], HEX);\n#  endif\n                    if (i != tNumberOfArrayData - 1) {\n                        aSerial->print(F(\", 0x\"));\n                    }\n                }\n                aSerial->println(F(\"};\"));\n                aSerial->print(F(\"    \"));\n            }\n        } else {\n            aSerial->print(F(\"Send with: \"));\n        }\n        aSerial->print(F(\"IrSender.send\"));\n\n#else\n            aSerial->print(F(\"Send with: IrSender.send\"));\n#endif\n\n#if defined(DECODE_DISTANCE_WIDTH)\n        if (decodedIRData.protocol != PULSE_DISTANCE && decodedIRData.protocol != PULSE_WIDTH) {\n#endif\n            aSerial->print(getProtocolString());\n            aSerial->print(F(\"(0x\"));\n#if defined(DECODE_MAGIQUEST)\n            if (decodedIRData.protocol == MAGIQUEST) {\n#  if (__INT_WIDTH__ < 32)\n                aSerial->print(decodedIRData.decodedRawData, HEX);\n#  else\n                PrintULL::print(aSerial, decodedIRData.decodedRawData, HEX);\n#  endif\n            } else {\n                aSerial->print(decodedIRData.address, HEX);\n            }\n#else\n            /*\n             * New decoders have address and command\n             */\n            aSerial->print(decodedIRData.address, HEX);\n#endif\n\n            aSerial->print(F(\", 0x\"));\n            aSerial->print(decodedIRData.command, HEX);\n            if (decodedIRData.protocol == SONY) {\n                aSerial->print(F(\", 2, \"));\n                aSerial->print(decodedIRData.numberOfBits);\n            } else {\n                aSerial->print(F(\", <numberOfRepeats>\"));\n            }\n\n#if defined(DECODE_DISTANCE_WIDTH)\n        } else {\n            /*\n             * Pulse distance or pulse width here\n             */\n            aSerial->print(\"PulseDistanceWidth\");\n            if(tNumberOfArrayData > 1) {\n                aSerial->print(\"FromArray(38, \");\n            } else {\n                aSerial->print(\"(38, \");\n            }\n            printDistanceWidthTimingInfo(aSerial, &decodedIRData.DistanceWidthTimingInfo);\n\n            if(tNumberOfArrayData > 1) {\n                aSerial->print(F(\", &tRawData[0], \"));\n            } else {\n                aSerial->print(F(\", 0x\"));\n#  if (__INT_WIDTH__ < 32)\n                aSerial->print(decodedIRData.decodedRawData, HEX);\n#  else\n                PrintULL::print(aSerial, decodedIRData.decodedRawData, HEX);\n#  endif\n                aSerial->print(F(\", \"));\n            }\n            aSerial->print(decodedIRData.numberOfBits);// aNumberOfBits\n            aSerial->print(F(\", PROTOCOL_IS_\"));\n\n            if (decodedIRData.flags & IRDATA_FLAGS_IS_MSB_FIRST) {\n                aSerial->print('M');\n            } else {\n                aSerial->print('L');\n            }\n            aSerial->print(F(\"SB_FIRST, <RepeatPeriodMillis>, <numberOfRepeats>\"));\n        }\n#endif\n#if defined(DECODE_PANASONIC) || defined(DECODE_KASEIKYO)\n        if ((decodedIRData.flags & IRDATA_FLAGS_EXTRA_INFO) && decodedIRData.protocol == KASEIKYO) {\n            aSerial->print(F(\", 0x\"));\n            aSerial->print(decodedIRData.extra, HEX);\n        }\n#endif\n            aSerial->print(F(\");\"));\n            aSerial->println();\n        }\n    }\n}\n\n/**\n * Function to print protocol number, address, command, raw data and repeat flag of IrReceiver.decodedIRData in one short line.\n * Does not print a Newline / does not end with println().\n *\n * @param aSerial The Print object on which to write, for Arduino you can use &Serial.\n */\nvoid IRrecv::printIRResultMinimal(Print *aSerial) {\n    aSerial->print(F(\"P=\"));\n    aSerial->print(decodedIRData.protocol);\n    if (decodedIRData.protocol == UNKNOWN) {\n#if defined(DECODE_HASH)\n        aSerial->print(F(\" #=0x\"));\n#  if (__INT_WIDTH__ < 32)\n        aSerial->print(decodedIRData.decodedRawData, HEX);\n#  else\n        PrintULL::print(aSerial, decodedIRData.decodedRawData, HEX);\n#  endif\n#endif\n        aSerial->print(' ');\n        aSerial->print((decodedIRData.rawlen + 1) / 2, DEC);\n        aSerial->println(F(\" bits received\"));\n    } else {\n        /*\n         * New decoders have address and command\n         */\n        aSerial->print(F(\" A=0x\"));\n        aSerial->print(decodedIRData.address, HEX);\n\n        aSerial->print(F(\" C=0x\"));\n        aSerial->print(decodedIRData.command, HEX);\n\n        aSerial->print(F(\" Raw=0x\"));\n#if (__INT_WIDTH__ < 32)\n        aSerial->print(decodedIRData.decodedRawData, HEX);\n#else\n        PrintULL::print(aSerial, decodedIRData.decodedRawData, HEX);\n#endif\n\n        if (decodedIRData.flags & (IRDATA_FLAGS_IS_AUTO_REPEAT | IRDATA_FLAGS_IS_REPEAT)) {\n            aSerial->print(F(\" R\"));\n        }\n    }\n}\n\n/**\n * Dump out the timings in IrReceiver.decodedIRData.rawDataPtr->rawbuf[] array 8 values per line.\n *\n * @param aSerial The Print object on which to write, for Arduino you can use &Serial.\n * @param aOutputMicrosecondsInsteadOfTicks Output the (rawbuf_values * MICROS_PER_TICK) for better readability.\n */\nvoid IRrecv::printIRResultRawFormatted(Print *aSerial, bool aOutputMicrosecondsInsteadOfTicks) {\n\n// Print Raw data\n    aSerial->print(F(\"rawData[\"));\n    aSerial->print(decodedIRData.rawlen, DEC);\n    aSerial->println(F(\"]: \"));\n\n    /*\n     * Print initial gap\n     */\n    aSerial->print(F(\" -\"));\n    if (aOutputMicrosecondsInsteadOfTicks) {\n        aSerial->println((uint32_t) decodedIRData.initialGap * MICROS_PER_TICK, DEC);\n    } else {\n        aSerial->println(decodedIRData.initialGap, DEC);\n    }\n\n// Newline is printed every 8. value, if tCounterForNewline % 8 == 0\n    uint_fast8_t tCounterForNewline = 6; // first newline is after the 2 values of the start bit\n\n// check if we have a protocol with no or 8 start bits\n#if defined(DECODE_DENON) || defined(DECODE_MAGIQUEST)\n    if (\n#  if defined(DECODE_DENON)\n            decodedIRData.protocol == DENON || decodedIRData.protocol == SHARP ||\n#  endif\n#  if defined(DECODE_MAGIQUEST)\n            decodedIRData.protocol == MAGIQUEST ||\n#  endif\n            false) {\n        tCounterForNewline = 0; // no or 8 start bits\n    }\n#endif\n\n    uint32_t tDuration;\n    uint16_t tSumOfDurationTicks = 0;\n    for (IRRawlenType i = 1; i < decodedIRData.rawlen; i++) {\n        auto tCurrentTicks = decodedIRData.rawDataPtr->rawbuf[i];\n        if (aOutputMicrosecondsInsteadOfTicks) {\n            tDuration = tCurrentTicks * MICROS_PER_TICK;\n        } else {\n            tDuration = tCurrentTicks;\n        }\n        tSumOfDurationTicks += tCurrentTicks; // compute length of protocol frame\n\n        if (!(i & 1)) {  // even\n            aSerial->print('-');\n        } else {  // odd\n            aSerial->print(F(\" +\"));\n        }\n\n        // padding only for big values\n        if (aOutputMicrosecondsInsteadOfTicks && tDuration < 1000) {\n            aSerial->print(' ');\n        }\n        if (aOutputMicrosecondsInsteadOfTicks && tDuration < 100) {\n            aSerial->print(' ');\n        }\n        if (tDuration < 10) {\n            aSerial->print(' ');\n        }\n        aSerial->print(tDuration, DEC);\n\n        if ((i & 1) && (i + 1) < decodedIRData.rawlen) {\n            aSerial->print(','); //',' not required for last one\n        }\n\n        tCounterForNewline++;\n        if ((tCounterForNewline % 8) == 0) {\n            aSerial->println();\n        }\n    }\n\n    aSerial->println();\n    aSerial->print(\"Sum: \");\n    if (aOutputMicrosecondsInsteadOfTicks) {\n        aSerial->println((uint32_t) tSumOfDurationTicks * MICROS_PER_TICK, DEC);\n    } else {\n        aSerial->println(tSumOfDurationTicks, DEC);\n    }\n}\n\n/**\n * Dump out the IrReceiver.decodedIRData.rawDataPtr->rawbuf[] to be used as C definition for sendRaw().\n *\n * Compensate received values by MARK_EXCESS_MICROS, like it is done for decoding!\n * Print ticks in 8 bit format to save space.\n * Maximum is 255*50 microseconds = 12750 microseconds = 12.75 ms, which hardly ever occurs inside an IR sequence.\n * Recording of IRremote anyway stops at a gap of RECORD_GAP_MICROS (5 ms).\n *\n * @param aSerial The Print object on which to write, for Arduino you can use &Serial.\n * @param aOutputMicrosecondsInsteadOfTicks Output the (rawbuf_values * MICROS_PER_TICK) for better readability.\n */\nvoid IRrecv::compensateAndPrintIRResultAsCArray(Print *aSerial, bool aOutputMicrosecondsInsteadOfTicks) {\n// Start declaration\n    if (aOutputMicrosecondsInsteadOfTicks) {\n        aSerial->print(F(\"uint16_t rawData[\"));         // variable type, array name\n    } else {\n        aSerial->print(F(\"uint8_t rawTicks[\"));          // variable type, array name\n    }\n\n    aSerial->print(decodedIRData.rawlen - 1, DEC);    // array size\n    aSerial->print(F(\"] = {\"));    // Start declaration\n\n// Dump data\n    for (IRRawlenType i = 1; i < decodedIRData.rawlen; i++) {\n        uint32_t tDuration = decodedIRData.rawDataPtr->rawbuf[i] * MICROS_PER_TICK;\n\n        if (i & 1) {\n            // Mark\n            tDuration -= MARK_EXCESS_MICROS;\n        } else {\n            tDuration += MARK_EXCESS_MICROS;\n        }\n\n        if (aOutputMicrosecondsInsteadOfTicks) {\n            aSerial->print(tDuration);\n        } else {\n            unsigned int tTicks = (tDuration + (MICROS_PER_TICK / 2)) / MICROS_PER_TICK;\n            /*\n             * Clip to 8 bit value\n             */\n            tTicks = (tTicks > UINT8_MAX) ? UINT8_MAX : tTicks;\n            aSerial->print(tTicks);\n        }\n        if (i + 1 < decodedIRData.rawlen) aSerial->print(',');                // ',' not required on last one\n        if (!(i & 1)) aSerial->print(' ');\n    }\n\n// End declaration\n    aSerial->print(F(\"};\"));                //\n\n// Comment\n    aSerial->print(F(\"  // \"));\n    printIRResultShort(aSerial);\n\n// Newline\n    aSerial->println(\"\");\n}\n\n/**\n * Store the decodedIRData to be used for sendRaw().\n *\n * Compensate received values by MARK_EXCESS_MICROS, like it is done for decoding and store it in an array provided.\n *\n * Maximum for uint8_t is 255*50 microseconds = 12750 microseconds = 12.75 ms, which hardly ever occurs inside an IR sequence.\n * Recording of IRremote anyway stops at a gap of RECORD_GAP_MICROS (5 ms).\n * @param aArrayPtr Address of an array provided by the caller.\n */\nvoid IRrecv::compensateAndStoreIRResultInArray(uint8_t *aArrayPtr) {\n\n// Store data, skip leading space#\n    IRRawlenType i;\n    for (i = 1; i < decodedIRData.rawlen; i++) {\n        uint32_t tDuration = decodedIRData.rawDataPtr->rawbuf[i] * MICROS_PER_TICK;\n        if (i & 1) {\n            // Mark\n            tDuration -= MARK_EXCESS_MICROS;\n        } else {\n            tDuration += MARK_EXCESS_MICROS;\n        }\n\n        unsigned int tTicks = (tDuration + (MICROS_PER_TICK / 2)) / MICROS_PER_TICK;\n        *aArrayPtr = (tTicks > UINT8_MAX) ? UINT8_MAX : tTicks; // we store it in an 8 bit array\n        aArrayPtr++;\n    }\n}\n\n/**\n * Print results as C variables to be used for sendXXX()\n * @param aSerial The Print object on which to write, for Arduino you can use &Serial.\n */\nvoid IRrecv::printIRResultAsCVariables(Print *aSerial) {\n// Now dump \"known\" codes\n    if (decodedIRData.protocol != UNKNOWN) {\n\n        /*\n         * New decoders have address and command\n         */\n        aSerial->print(F(\"uint16_t\"));\n        aSerial->print(F(\" address = 0x\"));\n        aSerial->print(decodedIRData.address, HEX);\n        aSerial->println(';');\n\n        aSerial->print(F(\"uint16_t\"));\n        aSerial->print(F(\" command = 0x\"));\n        aSerial->print(decodedIRData.command, HEX);\n        aSerial->println(';');\n\n        // All protocols have raw data\n#if __INT_WIDTH__ < 32\n        aSerial->print(F(\"uint32_t rawData = 0x\"));\n#else\n        aSerial->print(F(\"uint64_t rawData = 0x\"));\n#endif\n#if (__INT_WIDTH__ < 32)\n        aSerial->print(decodedIRData.decodedRawData, HEX);\n#else\n        PrintULL::print(aSerial, decodedIRData.decodedRawData, HEX);\n#endif\n        aSerial->println(';');\n        aSerial->println();\n    }\n}\n\n#if defined(__AVR__)\nconst __FlashStringHelper* IRrecv::getProtocolString() {\n// call no class function with same name\n    return ::getProtocolString(decodedIRData.protocol);\n}\n#else\nconst char* IRrecv::getProtocolString() {\n    // call no class function with same name\n    return ::getProtocolString(decodedIRData.protocol);\n}\n#endif\n\n/**********************************************************************************************************************\n * The OLD and DEPRECATED decode function with parameter aResults, kept for backward compatibility to old 2.0 tutorials\n * This function calls the old MSB first decoders and fills only the 3 variables:\n * aResults->value\n * aResults->bits\n * aResults->decode_type\n **********************************************************************************************************************/\nbool IRrecv::decode_old(decode_results *aResults) {\n\n    if (irparams.StateForISR != IR_REC_STATE_STOP) {\n        return false;\n    }\n\n// copy for usage by legacy programs\n    aResults->rawbuf = irparams.rawbuf;\n    aResults->rawlen = irparams.rawlen;\n    if (irparams.OverflowFlag) {\n        // Copy overflow flag to decodedIRData.flags\n        irparams.OverflowFlag = false;\n        irparams.rawlen = 0; // otherwise we have OverflowFlag again at next ISR call\n        IR_DEBUG_PRINTLN(F(\"Overflow happened\"));\n    }\n    aResults->overflow = irparams.OverflowFlag;\n    aResults->value = 0;\n\n    decodedIRData.flags = IRDATA_FLAGS_IS_MSB_FIRST; // for print\n\n#if defined(DECODE_NEC)\n    IR_DEBUG_PRINTLN(F(\"Attempting old NEC decode\"));\n    if (decodeNECMSB(aResults)) {\n        return true;\n    }\n#endif\n\n#if defined(DECODE_SONY)\n    IR_DEBUG_PRINTLN(F(\"Attempting old Sony decode\"));\n    if (decodeSonyMSB(aResults)) {\n        return true;\n    }\n#endif\n\n#if defined(DECODE_RC5)\n    IR_DEBUG_PRINTLN(F(\"Attempting RC5 decode\"));\n    if (decodeRC5()) {\n        aResults->bits = decodedIRData.numberOfBits;\n        aResults->value = decodedIRData.decodedRawData;\n        aResults->decode_type = RC5;\n\n        return true;\n    }\n#endif\n\n#if defined(DECODE_RC6)\n    IR_DEBUG_PRINTLN(F(\"Attempting RC6 decode\"));\n    if (decodeRC6()) {\n        aResults->bits = decodedIRData.numberOfBits;\n        aResults->value = decodedIRData.decodedRawData;\n        aResults->decode_type = RC6;\n        return true;\n    }\n#endif\n\n//    Removed bool IRrecv::decodePanasonicMSB(decode_results *aResults) since  implementations was wrong (wrong length), and nobody recognized it\n\n#if defined(DECODE_LG)\n    IR_DEBUG_PRINTLN(F(\"Attempting old LG decode\"));\n    if (decodeLGMSB(aResults)) {return true;}\n#endif\n\n#if defined(DECODE_JVC)\n    IR_DEBUG_PRINTLN(F(\"Attempting old JVC decode\"));\n    if (decodeJVCMSB(aResults)) {\n        return true;\n    }\n#endif\n\n#if defined(DECODE_SAMSUNG)\n    IR_DEBUG_PRINTLN(F(\"Attempting old SAMSUNG decode\"));\n    if (decodeSAMSUNG(aResults)) {\n        return true;\n    }\n#endif\n\n#if defined(DECODE_DENON)\n    IR_DEBUG_PRINTLN(F(\"Attempting old Denon decode\"));\n    if (decodeDenonOld(aResults)) {\n        return true;\n    }\n#endif\n\n// decodeHash returns a hash on any input.\n// Thus, it needs to be last in the list.\n// If you add any decodes, add them before this.\n    if (decodeHashOld(aResults)) {\n        return true;\n    }\n// Throw away and start over\n    resume();\n    return false;\n}\n\n/** @}*/\n#if defined(_IR_MEASURE_TIMING)\n#undef _IR_MEASURE_TIMING\n#endif\n#if defined(LOCAL_TRACE)\n#undef LOCAL_TRACE\n#endif\n#if defined(LOCAL_DEBUG)\n#undef LOCAL_DEBUG\n#endif\n#endif // _IR_RECEIVE_HPP\n"
    }, {
      filename: "src/IRProtocol.h",
      code: "/**\n * @file IRProtocol.h\n * @brief Common declarations for receiving and sending.\n *\n * This file is part of Arduino-IRremote https://github.com/Arduino-IRremote/Arduino-IRremote.\n *\n *\n ************************************************************************************\n * MIT License\n *\n * Copyright (c) 2020-2023 Armin Joachimsmeyer\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is furnished\n * to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n ************************************************************************************\n */\n#ifndef _IR_PROTOCOL_H\n#define _IR_PROTOCOL_H\n\n/**\n * An enum consisting of all supported formats.\n * You do NOT need to remove entries from this list when disabling protocols!\n * !!!Must be the same order as ProtocolNames in IRReceive.hpp!!!\n */\ntypedef enum {\n    UNKNOWN = 0,\n    PULSE_WIDTH,\n    PULSE_DISTANCE,\n    APPLE,\n    DENON,\n    JVC,\n    LG,\n    LG2,\n    NEC,\n    NEC2, /* NEC with full frame as repeat */\n    ONKYO,\n    PANASONIC,\n    KASEIKYO,\n    KASEIKYO_DENON,\n    KASEIKYO_SHARP,\n    KASEIKYO_JVC,\n    KASEIKYO_MITSUBISHI,\n    RC5,\n    RC6,\n    SAMSUNG,\n    SAMSUNGLG,\n    SAMSUNG48,\n    SHARP,\n    SONY,\n    /* Now the exotic protocols */\n    BANG_OLUFSEN,\n    BOSEWAVE,\n    LEGO_PF,\n    MAGIQUEST,\n    WHYNTER,\n    FAST\n} decode_type_t;\n\n#define SIRCS_12_PROTOCOL       12\n#define SIRCS_15_PROTOCOL       15\n#define SIRCS_20_PROTOCOL       20\n\nstruct DistanceWidthTimingInfoStruct {\n    uint16_t HeaderMarkMicros;\n    uint16_t HeaderSpaceMicros;\n    uint16_t OneMarkMicros;\n    uint16_t OneSpaceMicros;\n    uint16_t ZeroMarkMicros;\n    uint16_t ZeroSpaceMicros;\n};\n\n/*\n * Definitions for member IRData.flags\n */\n#define IRDATA_FLAGS_EMPTY              0x00\n#define IRDATA_FLAGS_IS_REPEAT          0x01 ///< The gap between the preceding frame is as smaller than the maximum gap expected for a repeat. !!!We do not check for changed command or address, because it is almost not possible to press 2 different buttons on the remote within around 100 ms!!!\n#define IRDATA_FLAGS_IS_AUTO_REPEAT     0x02 ///< The current repeat frame is a repeat, that is always sent after a regular frame and cannot be avoided. Only specified for protocols DENON, and LEGO.\n#define IRDATA_FLAGS_PARITY_FAILED      0x04 ///< The current (autorepeat) frame violated parity check.\n#define IRDATA_FLAGS_TOGGLE_BIT         0x08 ///< Is set if RC5 or RC6 toggle bit is set.\n#define IRDATA_TOGGLE_BIT_MASK          0x08 ///< deprecated -is set if RC5 or RC6 toggle bit is set.\n#define IRDATA_FLAGS_EXTRA_INFO         0x10 ///< There is extra info not contained in address and data (e.g. Kaseikyo unknown vendor ID, or in decodedRawDataArray).\n#define IRDATA_FLAGS_IS_PROTOCOL_WITH_DIFFERENT_REPEAT 0x20 ///< Here we have a repeat of type NEC2 or SamsungLG\n#define IRDATA_FLAGS_WAS_OVERFLOW       0x40 ///< irparams.rawlen is set to 0 in this case to avoid endless OverflowFlag.\n#define IRDATA_FLAGS_IS_MSB_FIRST       0x80 ///< Value is mainly determined by the (known) protocol.\n#define IRDATA_FLAGS_IS_LSB_FIRST       0x00\n\n#define RAW_DATA_ARRAY_SIZE             ((((RAW_BUFFER_LENGTH - 2) - 1) / (2 * BITS_IN_RAW_DATA_TYPE)) + 1) // The -2 is for initial gap + stop bit mark, 128 mark + spaces for 64 bit.\n/**\n * Data structure for the user application, available as decodedIRData.\n * Filled by decoders and read by print functions or user application.\n */\nstruct IRData {\n    decode_type_t protocol; ///< UNKNOWN, NEC, SONY, RC5, PULSE_DISTANCE, ...\n    uint16_t address; ///< Decoded address, Distance protocol (tMarkTicksLong (if tMarkTicksLong == 0, then tMarkTicksShort) << 8) | tSpaceTicksLong\n    uint16_t command;       ///< Decoded command, Distance protocol (tMarkTicksShort << 8) | tSpaceTicksShort\n    uint16_t extra; ///< Contains upper 16 bit of Magiquest WandID, Kaseikyo unknown vendor ID and Distance protocol (HeaderMarkTicks << 8) | HeaderSpaceTicks.\n    IRRawDataType decodedRawData; ///< Up to 32/64 bit decoded raw data, to be used for send functions.\n#if defined(DECODE_DISTANCE_WIDTH)\n    // This replaces the address, command, extra and decodedRawData in case of protocol == PULSE_DISTANCE or -rather seldom- protocol == PULSE_WIDTH.\n    DistanceWidthTimingInfoStruct DistanceWidthTimingInfo; // 12 bytes\n    IRRawDataType decodedRawDataArray[RAW_DATA_ARRAY_SIZE]; ///< 32/64 bit decoded raw data, to be used for send function.\n#endif\n    uint16_t numberOfBits; ///< Number of bits received for data (address + command + parity) - to determine protocol length if different length are possible.\n    uint8_t flags;          ///< IRDATA_FLAGS_IS_REPEAT, IRDATA_FLAGS_WAS_OVERFLOW etc. See IRDATA_FLAGS_* definitions above\n\n    // These 2 variables allow to call resume() directly after decode, if no dump is required. Since 4.3.0.\n    IRRawlenType rawlen;        ///< counter of entries in rawbuf\n    uint16_t initialGap;        ///< rawbuf[0] contains the initial gap of the last frame.\n\n    irparams_struct *rawDataPtr; ///< Pointer of the raw timing data to be decoded. Mainly the OverflowFlag and the data buffer filled by receiving ISR.\n};\n\nstruct PulseDistanceWidthProtocolConstants {\n    decode_type_t ProtocolIndex;\n    uint_fast8_t FrequencyKHz;\n    DistanceWidthTimingInfoStruct DistanceWidthTimingInfo;\n    uint8_t Flags;\n    unsigned int RepeatPeriodMillis;\n    void (*SpecialSendRepeatFunction)(); // using non member functions here saves up to 250 bytes for send demo\n//    void (IRsend::*SpecialSendRepeatFunction)();\n};\n/*\n * Definitions for member PulseDistanceWidthProtocolConstants.Flags\n */\n#define SUPPRESS_STOP_BIT_FOR_THIS_DATA 0x20 // Stop bit is otherwise sent for all pulse distance protocols.\n#define PROTOCOL_IS_MSB_FIRST           IRDATA_FLAGS_IS_MSB_FIRST\n#define PROTOCOL_IS_LSB_FIRST           IRDATA_FLAGS_IS_LSB_FIRST\n\n/*\n * Carrier frequencies for various protocols\n */\n#if !defined(BEO_KHZ) // guard used for unit test, which sends and receive Bang&Olufsen with 38 kHz.\n#define BEO_KHZ         455\n#endif\n#define SONY_KHZ        40\n#define BOSEWAVE_KHZ    38\n#define DENON_KHZ       38\n#define JVC_KHZ         38\n#define LG_KHZ          38\n#define NEC_KHZ         38\n#define SAMSUNG_KHZ     38\n#define KASEIKYO_KHZ    37\n#define RC5_RC6_KHZ     36\n\n#if defined(__AVR__)\nconst __FlashStringHelper* getProtocolString(decode_type_t aProtocol);\n#else\nconst char* getProtocolString(decode_type_t aProtocol);\n#endif\nvoid printIRResultShort(Print *aSerial, IRData *aIRDataPtr, bool aPrintGap); // A static function to be able to print send or copied received data.\n\n/*\n * Convenience functions to convert MSB to LSB values\n */\nuint8_t bitreverseOneByte(uint8_t aValue);\nuint32_t bitreverse32Bit(uint32_t aInput);\n\n#endif // _IR_PROTOCOL_H\n"
    }, {
      filename: "src/ac_LG.h",
      code: "/*\n * ac_LG.h\n *\n *  Contains definitions for receiving and sending LG air conditioner IR Protocol\n *\n *  This file is part of Arduino-IRremote https://github.com/Arduino-IRremote/Arduino-IRremote.\n *\n ************************************************************************************\n * MIT License\n *\n * Copyright (c) 2021 Armin Joachimsmeyer\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is furnished\n * to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n ************************************************************************************\n */\n// see also: https://github.com/crankyoldgit/IRremoteESP8266/blob/master/src/ir_LG.h\n#ifndef _AC_LG_H\n#define _AC_LG_H\n\n#include <Arduino.h>\n\n/** \\addtogroup Airconditoners Air conditioner special code\n * @{\n */\n\n#define LG_ADDRESS  0x88\n\n/*\n * The basic IR command codes\n * Parts of the codes (especially the lower nibbles) may be modified to contain\n * additional information like temperature, fan speed and minutes.\n */\n#define LG_SWITCH_ON_MASK       0x0800  // This bit is masked if we switch Power on\n#define LG_MODE_COOLING         0x0800  // Temperature and fan speed in lower nibbles\n#define LG_MODE_DEHUMIDIFIYING  0x0990  // sets also temperature to 24 and fan speed to 0\n#define LG_MODE_FAN             0x0A30  // sets also temperature to 18\n#define LG_MODE_AUTO            0x0B00  // The remote initially sets also temperature to 22 and fan speed to 4\n#define LG_MODE_HEATING         0x0C00  // Temperature and fan speed in lower nibbles\n#define LG_ENERGY_SAVING_ON     0x1004\n#define LG_ENERGY_SAVING_OFF    0x1005\n#define LG_JET_ON               0x1008\n#define LG_WALL_SWING_ON        0x1314\n#define LG_WALL_SWING_OFF       0x1315\n#define LG_SWING_ON             0x1316  // not verified, for AKB73757604\n#define LG_SWING_OFF            0x1317  // not verified, for AKB73757604\n#define LG_TIMER_ON             0x8000  // relative minutes in lower nibbles\n#define LG_TIMER_OFF            0x9000  // relative minutes in lower nibbles\n#define LG_SLEEP                0xA000  // relative minutes in lower nibbles\n#define LG_CLEAR_ALL            0xB000  // Timers and sleep\n#define LG_POWER_DOWN           0xC005\n#define LG_LIGHT                0xC00A\n#define LG_AUTO_CLEAN_ON        0xC00B\n#define LG_AUTO_CLEAN_OFF       0xC00C\n\n/*\n * Commands as printed in menu and uses as first parameter for sendCommandAndParameter\n */\n#define LG_COMMAND_OFF          '0'\n#define LG_COMMAND_ON           '1'\n#define LG_COMMAND_SWING        's'\n#define LG_COMMAND_AUTO_CLEAN   'a'\n#define LG_COMMAND_JET          'j'\n#define LG_COMMAND_ENERGY       'e'\n#define LG_COMMAND_LIGHT        'l'\n#define LG_COMMAND_FAN_SPEED    'f'\n#define LG_COMMAND_TEMPERATURE  't'\n#define LG_COMMAND_TEMPERATURE_PLUS '+'\n#define LG_COMMAND_TEMPERATURE_MINUS '-'\n#define LG_COMMAND_MODE         'm'\n#define LG_COMMAND_SLEEP        'S'\n#define LG_COMMAND_TIMER_ON     'T'\n#define LG_COMMAND_TIMER_OFF    'O'\n#define LG_COMMAND_CLEAR_ALL    'C'\n\n/*\n * The modes are encoded as character values for easy printing :-)\n */\n#define AC_MODE_COOLING         'c'\n#define AC_MODE_DEHUMIDIFIYING  'd'\n#define AC_MODE_FAN             'f'\n#define AC_MODE_AUTO            'a'\n#define AC_MODE_HEATING         'h'\n\n// see https://github.com/crankyoldgit/IRremoteESP8266/blob/master/src/ir_LG.h\nunion LGProtocol {\n    uint32_t raw;  ///< The state of the IR remote in IR code form.\n    struct {\n        uint32_t Checksum :4;\n        uint32_t Fan :3;\n        uint32_t FanExt :1;\n        uint32_t Temp :4;\n        uint32_t Mode :4; // highest bit 1 => Set temperature and ventilation by mode\n        uint32_t Function :3;\n        uint32_t SwitchOnMask :1; /* Content is 0 when switching from off to on */\n        uint32_t Signature :8; /* Content is 0x88, LG_ADDRESS */\n    };\n};\n\nclass Aircondition_LG {\npublic:\n    bool sendCommandAndParameter(char aCommand, int aParameter);\n    void setType(bool aIsWallType);\n    void printMenu(Print *aSerial);\n    void sendIRCommand(uint16_t aCommand);\n    void sendTemperatureFanSpeedAndMode();\n    /*\n     * Internal state of the air condition\n     */\n#define LG_IS_WALL_TYPE true\n#define LG_IS_TOWER_TYPE false\n    bool ACIsWallType;      // false : TOWER, true : WALL\n    bool PowerIsOn;\n\n    // These value are encoded and sent by AC_LG_SendCommandAndParameter()\n    uint8_t FanIntensity = 1;    // 0 -> low, 4 high, 5 -> cycle\n    uint8_t Temperature = 22;    // temperature : 18 ~ 30\n    uint8_t Mode = AC_MODE_COOLING;\n    bool useLG2Protocol = false;\n};\n\n/** @}*/\n#endif // _AC_LG_H\n"
    }, {
      filename: "src/ir_Pronto.hpp",
      code: "/*\n * @file ir_Pronto.hpp\n * @brief In this file, the functions IRrecv::compensateAndPrintPronto and IRsend::sendPronto are defined.\n *\n * See http://www.harctoolbox.org/Glossary.html#ProntoSemantics\n * Pronto database http://www.remotecentral.com/search.htm\n *\n *  This file is part of Arduino-IRremote https://github.com/Arduino-IRremote/Arduino-IRremote.\n *\n ************************************************************************************\n * MIT License\n *\n * Copyright (c) 2020 Bengt Martensson\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is furnished\n * to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n ************************************************************************************\n */\n#ifndef _IR_PRONTO_HPP\n#define _IR_PRONTO_HPP\n\n#if defined(DEBUG) && !defined(LOCAL_DEBUG)\n#define LOCAL_DEBUG\n#else\n//#define LOCAL_DEBUG // This enables debug output only for this file\n#endif\n\n/** \\addtogroup Decoder Decoders and encoders for different protocols\n * @{\n */\n\n//! @cond\n// DO NOT EXPORT from this file\nstatic const uint16_t learnedToken = 0x0000U;\nstatic const uint16_t learnedNonModulatedToken = 0x0100U;\nstatic const uint16_t bitsInHexadecimal = 4U;\nstatic const uint16_t digitsInProntoNumber = 4U;\nstatic const uint16_t numbersInPreamble = 4U;\nstatic const uint16_t hexMask = 0xFU;\nstatic const uint32_t referenceFrequency = 4145146UL;\nstatic const uint16_t fallbackFrequency = 64767U; // To use with frequency = 0;\nstatic const uint32_t microsecondsInSeconds = 1000000UL;\nstatic const uint16_t PRONTO_DEFAULT_GAP = 45000;\n//! @endcond\n\nstatic uint16_t toFrequencyKHz(uint16_t code) {\n    return ((referenceFrequency / code) + 500) / 1000;\n}\n\n/*\n * Parse the string given as Pronto Hex, and send it a number of times given as argument.\n * The first number denotes the type of the signal. 0000 denotes a raw IR signal with modulation,\n // The second number denotes a frequency code\n */\nvoid IRsend::sendPronto(const uint16_t *data, uint16_t length, int_fast8_t aNumberOfRepeats) {\n    uint16_t timebase = (microsecondsInSeconds * data[1] + referenceFrequency / 2) / referenceFrequency;\n    uint16_t khz;\n    switch (data[0]) {\n    case learnedToken: // normal, \"learned\"\n        khz = toFrequencyKHz(data[1]);\n        break;\n    case learnedNonModulatedToken: // non-demodulated, \"learned\"\n        khz = 0U;\n        break;\n    default:\n        return; // There are other types, but they are not handled yet.\n    }\n    uint16_t intros = 2 * data[2];\n    uint16_t repeats = 2 * data[3];\n#if defined(LOCAL_DEBUG)\n    Serial.print(F(\"sendPronto intros=\"));\n    Serial.print(intros);\n    Serial.print(F(\" repeats=\"));\n    Serial.println(repeats);\n#endif\n    if (numbersInPreamble + intros + repeats != length) { // inconsistent sizes\n        return;\n    }\n\n    /*\n     * Generate a new microseconds timing array for sendRaw.\n     * If recorded by IRremote, intro contains the whole IR data and repeat is empty\n     */\n    uint16_t durations[intros + repeats];\n    for (uint16_t i = 0; i < intros + repeats; i++) {\n        uint32_t duration = ((uint32_t) data[i + numbersInPreamble]) * timebase;\n        durations[i] = (uint16_t) ((duration <= UINT16_MAX) ? duration : UINT16_MAX);\n    }\n\n    /*\n     * Send the intro. intros is even.\n     * Do not send the trailing space here, send it if repeats are requested\n     */\n    if (intros >= 2) {\n        sendRaw(durations, intros - 1, khz);\n    }\n\n    if (repeats == 0 || aNumberOfRepeats == 0) {\n        // only send intro once\n        return;\n    }\n\n    /*\n     * Now send the trailing space/gap of the intro and all the repeats\n     */\n    if (intros >= 2) {\n        delay(durations[intros - 1] / MICROS_IN_ONE_MILLI); // equivalent to space(durations[intros - 1]); but allow bigger values for the gap\n    }\n    for (int i = 0; i < aNumberOfRepeats; i++) {\n        sendRaw(durations + intros, repeats - 1, khz);\n        if ((i + 1) < aNumberOfRepeats) { // skip last trailing space/gap, see above\n            delay(durations[intros + repeats - 1] / MICROS_IN_ONE_MILLI);\n        }\n    }\n}\n\n/**\n * Parse the string given as Pronto Hex, and send it a number of times given\n * as the second argument. Thereby the division of the Pronto Hex into\n * an intro-sequence and a repeat sequence is taken into account:\n * First the intro sequence is sent, then the repeat sequence is sent times-1 times.\n * However, if the intro sequence is empty, the repeat sequence is sent times times.\n * <a href=\"http://www.harctoolbox.org/Glossary.html#ProntoSemantics\">Reference</a>.\n *\n * Note: Using this function is very wasteful for the memory consumption on\n * a small board.\n * Normally it is a much better idea to use a tool like e.g. IrScrutinizer\n * to transform Pronto type signals offline\n * to a more memory efficient format.\n *\n * @param str C type string (null terminated) containing a Pronto Hex representation.\n * @param aNumberOfRepeats Number of times to send the signal.\n */\nvoid IRsend::sendPronto(const char *str, int_fast8_t aNumberOfRepeats) {\n    size_t len = strlen(str) / (digitsInProntoNumber + 1) + 1;\n    uint16_t data[len];\n    const char *p = str;\n    char *endptr[1];\n    for (uint16_t i = 0; i < len; i++) {\n        long x = strtol(p, endptr, 16);\n        if (x == 0 && i >= numbersInPreamble) {\n            // Alignment error?, bail immediately (often right result).\n            len = i;\n            break;\n        }\n        data[i] = static_cast<uint16_t>(x); // If input is conforming, there can be no overflow!\n        p = *endptr;\n    }\n    sendPronto(data, len, aNumberOfRepeats);\n}\n\n#if defined(__AVR__)\n/**\n * Version of sendPronto that reads from PROGMEM, saving RAM memory.\n * @param str pronto C type string (null terminated) containing a Pronto Hex representation.\n * @param aNumberOfRepeats Number of times to send the signal.\n */\n//far pointer (? for ATMega2560 etc.)\nvoid IRsend::sendPronto_PF(uint_farptr_t str, int_fast8_t aNumberOfRepeats) {\n    size_t len = strlen_PF(str);\n    char work[len + 1];\n    strcpy_PF(work, str); // We know that string including terminating character fits in work\n    sendPronto(work, aNumberOfRepeats);\n}\n\n//standard pointer\nvoid IRsend::sendPronto_P(const char *str, int_fast8_t aNumberOfRepeats) {\n    size_t len = strlen_P(str);\n    char work[len + 1];\n    strcpy_P(work, str);\n    sendPronto(work, aNumberOfRepeats);\n}\n#endif\n\nvoid IRsend::sendPronto(const __FlashStringHelper *str, int_fast8_t aNumberOfRepeats) {\n    size_t len = strlen_P(reinterpret_cast<const char*>(str));\n    char work[len + 1];\n    strcpy_P(work, reinterpret_cast<const char*>(str));\n    return sendPronto(work, aNumberOfRepeats);\n}\n\nstatic uint16_t effectiveFrequency(uint16_t frequency) {\n    return frequency > 0 ? frequency : fallbackFrequency;\n}\n\nstatic uint16_t toTimebase(uint16_t frequency) {\n    return microsecondsInSeconds / effectiveFrequency(frequency);\n}\n\nstatic uint16_t toFrequencyCode(uint16_t frequency) {\n    return referenceFrequency / effectiveFrequency(frequency);\n}\n\nstatic char hexDigit(uint16_t x) {\n    return (char) (x <= 9 ? ('0' + x) : ('A' + (x - 10)));\n}\n\nstatic void dumpDigit(Print *aSerial, uint16_t number) {\n    aSerial->print(hexDigit(number));\n}\n\nstatic void dumpNumber(Print *aSerial, uint16_t number) {\n    for (uint16_t i = 0; i < digitsInProntoNumber; i++) {\n        uint16_t shifts = bitsInHexadecimal * (digitsInProntoNumber - 1 - i);\n        dumpDigit(aSerial, (number >> shifts) & hexMask);\n    }\n    aSerial->print(' ');\n}\n\nstatic void dumpDuration(Print *aSerial, uint32_t duration, uint16_t timebase) {\n    dumpNumber(aSerial, (duration + timebase / 2) / timebase);\n}\n\n/*\n * Compensate received values by MARK_EXCESS_MICROS, like it is done for decoding!\n */\nstatic void compensateAndDumpSequence(Print *aSerial, const volatile uint16_t *data, size_t length, uint16_t timebase) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t tDuration = data[i] * MICROS_PER_TICK;\n        if (i & 1) {\n            // Mark\n            tDuration -= getMarkExcessMicros();\n        } else {\n            tDuration += getMarkExcessMicros();\n        }\n        dumpDuration(aSerial, tDuration, timebase);\n    }\n\n    // append a gap\n    dumpDuration(aSerial, PRONTO_DEFAULT_GAP, timebase);\n}\n\n/**\n * Print the result (second argument) as Pronto Hex on the Print supplied as argument.\n * Used in the ReceiveDump example.\n * @param aSerial The Print object on which to write, for Arduino you can use &Serial.\n * @param aFrequencyHertz Modulation frequency in Hz. Often 38000Hz.\n */\nvoid IRrecv::compensateAndPrintIRResultAsPronto(Print *aSerial, uint16_t aFrequencyHertz) {\n    aSerial->println(F(\"Pronto Hex as string\"));\n    aSerial->print(F(\"char prontoData[] = \\\"\"));\n    dumpNumber(aSerial, aFrequencyHertz > 0 ? learnedToken : learnedNonModulatedToken);\n    dumpNumber(aSerial, toFrequencyCode(aFrequencyHertz));\n    dumpNumber(aSerial, (decodedIRData.rawlen + 1) / 2);\n    dumpNumber(aSerial, 0);\n    uint16_t timebase = toTimebase(aFrequencyHertz);\n    compensateAndDumpSequence(aSerial, &decodedIRData.rawDataPtr->rawbuf[1], decodedIRData.rawlen - 1, timebase); // skip leading space\n    aSerial->println(\"\\\";\");\n}\n\n/*\n * Functions for dumping Pronto to a String. This is not very time and space efficient\n * and can lead to resource problems especially on small processors like AVR's\n */\n\nstatic bool dumpDigit(String *aString, uint16_t number) {\n    aString->concat(hexDigit(number));\n    return number;\n}\n\nstatic size_t dumpNumber(String *aString, uint16_t number) {\n\n    size_t size = 0;\n\n    for (uint16_t i = 0; i < digitsInProntoNumber; i++) {\n        uint16_t shifts = bitsInHexadecimal * (digitsInProntoNumber - 1 - i);\n        size += dumpDigit(aString, (number >> shifts) & hexMask);\n    }\n    aString->concat(' ');\n    size++;\n\n    return size;\n}\n\n/*\n * Compensate received values by MARK_EXCESS_MICROS, like it is done for decoding!\n */\nstatic size_t dumpDuration(String *aString, uint32_t duration, uint16_t timebase) {\n    return dumpNumber(aString, (duration + timebase / 2) / timebase);\n}\n\nstatic size_t compensateAndDumpSequence(String *aString, const volatile uint16_t *data, size_t length, uint16_t timebase) {\n\n    size_t size = 0;\n\n    for (size_t i = 0; i < length; i++) {\n        uint32_t tDuration = data[i] * MICROS_PER_TICK;\n        if (i & 1) {\n            // Mark\n            tDuration -= getMarkExcessMicros();\n        } else {\n            tDuration += getMarkExcessMicros();\n        }\n        size += dumpDuration(aString, tDuration, timebase);\n    }\n\n    // append minimum gap\n    size += dumpDuration(aString, PRONTO_DEFAULT_GAP, timebase);\n\n    return size;\n}\n\n/*\n * Writes Pronto HEX to a String object.\n * Returns the amount of characters added to the string.(360 characters for a NEC code!)\n */\nsize_t IRrecv::compensateAndStorePronto(String *aString, uint16_t frequency) {\n\n    size_t size = 0;\n    uint16_t timebase = toTimebase(frequency);\n\n    size += dumpNumber(aString, frequency > 0 ? learnedToken : learnedNonModulatedToken);\n    size += dumpNumber(aString, toFrequencyCode(frequency));\n    size += dumpNumber(aString, (decodedIRData.rawlen + 1) / 2);\n    size += dumpNumber(aString, 0);\n    size += compensateAndDumpSequence(aString, &decodedIRData.rawDataPtr->rawbuf[1], decodedIRData.rawlen - 1,\n            timebase); // skip leading space\n\n    return size;\n}\n\n/** @}*/\n#if defined(LOCAL_DEBUG)\n#undef LOCAL_DEBUG\n#endif\n#endif // _IR_PRONTO_HPP\n"
    }, {
      filename: "src/IRSend.hpp",
      code: "/*\n * IRSend.hpp\n *\n *  Contains common functions for sending\n *\n *  This file is part of Arduino-IRremote https://github.com/Arduino-IRremote/Arduino-IRremote.\n *\n ************************************************************************************\n * MIT License\n *\n * Copyright (c) 2009-2023 Ken Shirriff, Rafi Khan, Armin Joachimsmeyer\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is furnished\n * to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n ************************************************************************************\n */\n#ifndef _IR_SEND_HPP\n#define _IR_SEND_HPP\n\n#if defined(DEBUG) && !defined(LOCAL_DEBUG)\n#define LOCAL_DEBUG\n#else\n//#define LOCAL_DEBUG // This enables debug output only for this file\n#endif\n\n#if defined(TRACE) && !defined(LOCAL_TRACE)\n#define LOCAL_TRACE\n#else\n//#define LOCAL_TRACE // This enables debug output only for this file\n#endif\n\n/*\n * Low level hardware timing measurement\n */\n//#define _IR_MEASURE_TIMING // for mark()\n//#define _IR_TIMING_TEST_PIN 7 // \"pinModeFast(_IR_TIMING_TEST_PIN, OUTPUT);\" is executed at begin()\n//\n/*\n * This improves readability of code by avoiding a lot of #if defined clauses\n */\n#if defined(IR_SEND_PIN)\n#define sendPin IR_SEND_PIN\n#endif\n\n/** \\addtogroup Sending Sending IR data for multiple protocols\n * @{\n */\n\n// The sender instance\nIRsend IrSender;\n\nIRsend::IRsend() { // @suppress(\"Class members should be properly initialized\")\n#if !defined(IR_SEND_PIN)\n    sendPin = 0;\n#endif\n\n#if !defined(NO_LED_FEEDBACK_CODE)\n    setLEDFeedback(0, DO_NOT_ENABLE_LED_FEEDBACK);\n#endif\n}\n\n#if defined(IR_SEND_PIN)\n/**\n * Only required to set LED feedback\n * Simple start with defaults - LED feedback enabled! Used if IR_SEND_PIN is defined. Saves program memory.\n */\nvoid IRsend::begin(){\n#  if !defined(NO_LED_FEEDBACK_CODE)\n    setLEDFeedback(USE_DEFAULT_FEEDBACK_LED_PIN, LED_FEEDBACK_ENABLED_FOR_SEND);\n#  endif\n#if defined(_IR_MEASURE_TIMING) && defined(_IR_TIMING_TEST_PIN)\n    pinModeFast(_IR_TIMING_TEST_PIN, OUTPUT);\n#endif\n}\n\n/**\n * Only required to set LED feedback\n * @param aEnableLEDFeedback    If true / ENABLE_LED_FEEDBACK, the feedback LED is activated while receiving or sending a PWM signal /a mark\n * @param aFeedbackLEDPin       If 0 / USE_DEFAULT_FEEDBACK_LED_PIN, then take board specific FEEDBACK_LED_ON() and FEEDBACK_LED_OFF() functions\n */\nvoid IRsend::begin(bool aEnableLEDFeedback, uint_fast8_t aFeedbackLEDPin) {\n#if !defined(NO_LED_FEEDBACK_CODE)\n    uint_fast8_t tEnableLEDFeedback = DO_NOT_ENABLE_LED_FEEDBACK;\n    if(aEnableLEDFeedback) {\n        tEnableLEDFeedback = LED_FEEDBACK_ENABLED_FOR_SEND;\n    }\n    setLEDFeedback(aFeedbackLEDPin, tEnableLEDFeedback);\n#else\n    (void) aEnableLEDFeedback;\n    (void) aFeedbackLEDPin;\n#endif\n}\n\n#else // defined(IR_SEND_PIN)\nIRsend::IRsend(uint_fast8_t aSendPin) { // @suppress(\"Class members should be properly initialized\")\n    sendPin = aSendPin;\n#  if !defined(NO_LED_FEEDBACK_CODE)\n    setLEDFeedback(0, DO_NOT_ENABLE_LED_FEEDBACK);\n#  endif\n}\n\n/**\n * Initializes the send pin and enable LED feedback with board specific FEEDBACK_LED_ON() and FEEDBACK_LED_OFF() functions\n * @param aSendPin The Arduino pin number, where a IR sender diode is connected.\n */\nvoid IRsend::begin(uint_fast8_t aSendPin) {\n    sendPin = aSendPin;\n#  if !defined(NO_LED_FEEDBACK_CODE)\n    setLEDFeedback(USE_DEFAULT_FEEDBACK_LED_PIN, LED_FEEDBACK_ENABLED_FOR_SEND);\n#  endif\n}\n\nvoid IRsend::setSendPin(uint_fast8_t aSendPin) {\n    sendPin = aSendPin;\n}\n\n/**\n * Initializes the send and feedback pin\n * @param aSendPin The Arduino pin number, where a IR sender diode is connected.\n * @param aEnableLEDFeedback    If true the feedback LED is activated while receiving or sending a PWM signal /a mark\n * @param aFeedbackLEDPin       If 0 / USE_DEFAULT_FEEDBACK_LED_PIN, then take board specific FEEDBACK_LED_ON() and FEEDBACK_LED_OFF() functions\n */\nvoid IRsend::begin(uint_fast8_t aSendPin, bool aEnableLEDFeedback, uint_fast8_t aFeedbackLEDPin) {\n#if defined(IR_SEND_PIN)\n    (void) aSendPin; // for backwards compatibility\n#else\n    sendPin = aSendPin;\n#endif\n\n#if !defined(NO_LED_FEEDBACK_CODE)\n    uint_fast8_t tEnableLEDFeedback = DO_NOT_ENABLE_LED_FEEDBACK;\n    if (aEnableLEDFeedback) {\n        tEnableLEDFeedback = LED_FEEDBACK_ENABLED_FOR_SEND;\n    }\n    setLEDFeedback(aFeedbackLEDPin, tEnableLEDFeedback);\n#else\n    (void) aEnableLEDFeedback;\n    (void) aFeedbackLEDPin;\n#endif\n}\n#endif // defined(IR_SEND_PIN)\n\n/**\n * Interprets and sends a IRData structure.\n * @param aIRSendData The values of protocol, address, command and repeat flag are taken for sending.\n * @param aNumberOfRepeats Number of repeats to send after the initial data if data is no repeat.\n * @return 1 if data sent, 0 if no data sent (i.e. for BANG_OLUFSEN, which is currently not supported here)\n */\n/**\n * Interprets and sends a IRData structure.\n * @param aIRSendData The values of protocol, address, command and repeat flag are taken for sending.\n * @param aNumberOfRepeats Number of repeats to send after the initial data if data is no repeat.\n * @return 1 if data sent, 0 if no data sent (i.e. for BANG_OLUFSEN, which is currently not supported here)\n */\nsize_t IRsend::write(IRData *aIRSendData, int_fast8_t aNumberOfRepeats) {\n\n    auto tProtocol = aIRSendData->protocol;\n    auto tAddress = aIRSendData->address;\n    auto tCommand = aIRSendData->command;\n    bool tIsRepeat = (aIRSendData->flags & IRDATA_FLAGS_IS_REPEAT);\n    if (tIsRepeat) {\n        aNumberOfRepeats = -1; // if aNumberOfRepeats < 0 then only a special repeat frame will be sent\n    }\n//    switch (tProtocol) { // 26 bytes bigger than if, else if, else\n//    case NEC:\n//        sendNEC(tAddress, tCommand, aNumberOfRepeats, tSendRepeat);\n//        break;\n//    case SAMSUNG:\n//        sendSamsung(tAddress, tCommand, aNumberOfRepeats);\n//        break;\n//    case SONY:\n//        sendSony(tAddress, tCommand, aNumberOfRepeats, aIRSendData->numberOfBits);\n//        break;\n//    case PANASONIC:\n//        sendPanasonic(tAddress, tCommand, aNumberOfRepeats);\n//        break;\n//    case DENON:\n//        sendDenon(tAddress, tCommand, aNumberOfRepeats);\n//        break;\n//    case SHARP:\n//        sendSharp(tAddress, tCommand, aNumberOfRepeats);\n//        break;\n//    case JVC:\n//        sendJVC((uint8_t) tAddress, (uint8_t) tCommand, aNumberOfRepeats); // casts are required to specify the right function\n//        break;\n//    case RC5:\n//        sendRC5(tAddress, tCommand, aNumberOfRepeats, !tSendRepeat); // No toggle for repeats\n//        break;\n//    case RC6:\n//        // No toggle for repeats//        sendRC6(tAddress, tCommand, aNumberOfRepeats, !tSendRepeat); // No toggle for repeats\n//        break;\n//    default:\n//        break;\n//    }\n\n    /*\n     * Order of protocols is in guessed relevance :-)\n     */\n    if (tProtocol == NEC) {\n        sendNEC(tAddress, tCommand, aNumberOfRepeats);\n\n    } else if (tProtocol == SAMSUNG) {\n        sendSamsung(tAddress, tCommand, aNumberOfRepeats);\n\n    } else if (tProtocol == SAMSUNG48) {\n        sendSamsung48(tAddress, tCommand, aNumberOfRepeats);\n\n    } else if (tProtocol == SAMSUNGLG) {\n        sendSamsungLG(tAddress, tCommand, aNumberOfRepeats);\n\n    } else if (tProtocol == SONY) {\n        sendSony(tAddress, tCommand, aNumberOfRepeats, aIRSendData->numberOfBits);\n\n    } else if (tProtocol == PANASONIC) {\n        sendPanasonic(tAddress, tCommand, aNumberOfRepeats);\n\n    } else if (tProtocol == DENON) {\n        sendDenon(tAddress, tCommand, aNumberOfRepeats);\n\n    } else if (tProtocol == SHARP) {\n        sendSharp(tAddress, tCommand, aNumberOfRepeats);\n\n    } else if (tProtocol == LG) {\n        sendLG(tAddress, tCommand, aNumberOfRepeats);\n\n    } else if (tProtocol == JVC) {\n        sendJVC((uint8_t) tAddress, (uint8_t) tCommand, aNumberOfRepeats); // casts are required to specify the right function\n\n    } else if (tProtocol == RC5) {\n        sendRC5(tAddress, tCommand, aNumberOfRepeats, !tIsRepeat); // No toggle for repeats\n\n    } else if (tProtocol == RC6) {\n        sendRC6(tAddress, tCommand, aNumberOfRepeats, !tIsRepeat); // No toggle for repeats\n\n    } else if (tProtocol == KASEIKYO_JVC) {\n        sendKaseikyo_JVC(tAddress, tCommand, aNumberOfRepeats);\n\n    } else if (tProtocol == KASEIKYO_DENON) {\n        sendKaseikyo_Denon(tAddress, tCommand, aNumberOfRepeats);\n\n    } else if (tProtocol == KASEIKYO_SHARP) {\n        sendKaseikyo_Sharp(tAddress, tCommand, aNumberOfRepeats);\n\n    } else if (tProtocol == KASEIKYO_MITSUBISHI) {\n        sendKaseikyo_Mitsubishi(tAddress, tCommand, aNumberOfRepeats);\n\n    } else if (tProtocol == NEC2) {\n        sendNEC2(tAddress, tCommand, aNumberOfRepeats);\n\n    } else if (tProtocol == ONKYO) {\n        sendOnkyo(tAddress, tCommand, aNumberOfRepeats);\n\n    } else if (tProtocol == APPLE) {\n        sendApple(tAddress, tCommand, aNumberOfRepeats);\n\n#if !defined(EXCLUDE_EXOTIC_PROTOCOLS)\n    } else if (tProtocol == BOSEWAVE) {\n        sendBoseWave(tCommand, aNumberOfRepeats);\n\n    } else if (tProtocol == MAGIQUEST) {\n        // we have a 32 bit ID/address\n        sendMagiQuest(aIRSendData->decodedRawData, tCommand);\n\n    } else if (tProtocol == FAST) {\n        // We have only 8 bit command\n        sendFAST(tCommand, aNumberOfRepeats);\n\n    } else if (tProtocol == LEGO_PF) {\n        sendLegoPowerFunctions(tAddress, tCommand, tCommand >> 4, tIsRepeat); // send 5 autorepeats\n#endif\n\n    } else {\n        return 0; // Not supported by write. E.g for BANG_OLUFSEN\n    }\n    return 1;\n}\n\n/**\n * Simple version of write without support for MAGIQUEST and numberOfBits for SONY protocol\n * @param aNumberOfRepeats  If aNumberOfRepeats < 0 then only a special repeat frame without leading and trailing space\n *                          will be sent by calling NECProtocolConstants.SpecialSendRepeatFunction().\n */\nsize_t IRsend::write(decode_type_t aProtocol, uint16_t aAddress, uint16_t aCommand, int_fast8_t aNumberOfRepeats) {\n\n//    switch (aProtocol) { // 26 bytes bigger than if, else if, else\n//    case NEC:\n//        sendNEC(aAddress, aCommand, aNumberOfRepeats, tSendRepeat);\n//        break;\n//    case SAMSUNG:\n//        sendSamsung(aAddress, aCommand, aNumberOfRepeats);\n//        break;\n//    case SONY:\n//        sendSony(aAddress, aCommand, aNumberOfRepeats, aIRSendData->numberOfBits);\n//        break;\n//    case PANASONIC:\n//        sendPanasonic(aAddress, aCommand, aNumberOfRepeats);\n//        break;\n//    case DENON:\n//        sendDenon(aAddress, aCommand, aNumberOfRepeats);\n//        break;\n//    case SHARP:\n//        sendSharp(aAddress, aCommand, aNumberOfRepeats);\n//        break;\n//    case JVC:\n//        sendJVC((uint8_t) aAddress, (uint8_t) aCommand, aNumberOfRepeats); // casts are required to specify the right function\n//        break;\n//    case RC5:\n//        sendRC5(aAddress, aCommand, aNumberOfRepeats, !tSendRepeat); // No toggle for repeats\n//        break;\n//    case RC6:\n//        // No toggle for repeats//        sendRC6(aAddress, aCommand, aNumberOfRepeats, !tSendRepeat); // No toggle for repeats\n//        break;\n//    default:\n//        break;\n//    }\n\n    /*\n     * Order of protocols is in guessed relevance :-)\n     */\n    if (aProtocol == NEC) {\n        sendNEC(aAddress, aCommand, aNumberOfRepeats);\n\n    } else if (aProtocol == SAMSUNG) {\n        sendSamsung(aAddress, aCommand, aNumberOfRepeats);\n\n    } else if (aProtocol == SAMSUNG48) {\n        sendSamsung48(aAddress, aCommand, aNumberOfRepeats);\n\n    } else if (aProtocol == SAMSUNGLG) {\n        sendSamsungLG(aAddress, aCommand, aNumberOfRepeats);\n\n    } else if (aProtocol == SONY) {\n        sendSony(aAddress, aCommand, aNumberOfRepeats, SIRCS_12_PROTOCOL);\n\n    } else if (aProtocol == PANASONIC) {\n        sendPanasonic(aAddress, aCommand, aNumberOfRepeats);\n\n    } else if (aProtocol == DENON) {\n        sendDenon(aAddress, aCommand, aNumberOfRepeats);\n\n    } else if (aProtocol == SHARP) {\n        sendSharp(aAddress, aCommand, aNumberOfRepeats);\n\n    } else if (aProtocol == LG) {\n        sendLG(aAddress, aCommand, aNumberOfRepeats);\n\n    } else if (aProtocol == JVC) {\n        sendJVC((uint8_t) aAddress, (uint8_t) aCommand, aNumberOfRepeats); // casts are required to specify the right function\n\n    } else if (aProtocol == RC5) {\n        sendRC5(aAddress, aCommand, aNumberOfRepeats, (aNumberOfRepeats > 0)); // No toggle for repeats\n\n    } else if (aProtocol == RC6) {\n        sendRC6(aAddress, aCommand, aNumberOfRepeats, (aNumberOfRepeats > 0)); // No toggle for repeats\n\n    } else if (aProtocol == KASEIKYO_JVC) {\n        sendKaseikyo_JVC(aAddress, aCommand, aNumberOfRepeats);\n\n    } else if (aProtocol == KASEIKYO_DENON) {\n        sendKaseikyo_Denon(aAddress, aCommand, aNumberOfRepeats);\n\n    } else if (aProtocol == KASEIKYO_SHARP) {\n        sendKaseikyo_Sharp(aAddress, aCommand, aNumberOfRepeats);\n\n    } else if (aProtocol == KASEIKYO_MITSUBISHI) {\n        sendKaseikyo_Mitsubishi(aAddress, aCommand, aNumberOfRepeats);\n\n    } else if (aProtocol == NEC2) {\n        sendNEC2(aAddress, aCommand, aNumberOfRepeats);\n\n    } else if (aProtocol == ONKYO) {\n        sendOnkyo(aAddress, aCommand, aNumberOfRepeats);\n\n    } else if (aProtocol == APPLE) {\n        sendApple(aAddress, aCommand, aNumberOfRepeats);\n\n#if !defined(EXCLUDE_EXOTIC_PROTOCOLS)\n    } else if (aProtocol == BOSEWAVE) {\n        sendBoseWave(aCommand, aNumberOfRepeats);\n\n    } else if (aProtocol == FAST) {\n        // We have only 8 bit command\n        sendFAST(aCommand, aNumberOfRepeats);\n\n    } else if (aProtocol == LEGO_PF) {\n        sendLegoPowerFunctions(aAddress, aCommand, aCommand >> 4, (aNumberOfRepeats < 0)); // send 5 autorepeats, except for dedicated repeats\n#endif\n\n    } else {\n        return 0; // Not supported by write. E.g for BANG_OLUFSEN\n    }\n    return 1;\n}\n\n/**\n * Function using an 16 byte microsecond timing array for every purpose.\n * Raw data starts with a Mark. No leading space as in received timing data!\n */\nvoid IRsend::sendRaw(const uint16_t aBufferWithMicroseconds[], uint_fast16_t aLengthOfBuffer, uint_fast8_t aIRFrequencyKilohertz) {\n// Set IR carrier frequency\n    enableIROut(aIRFrequencyKilohertz);\n\n    /*\n     * Raw data starts with a mark.\n     */\n    for (uint_fast16_t i = 0; i < aLengthOfBuffer; i++) {\n        if (i & 1) {\n            // Odd\n            space(aBufferWithMicroseconds[i]);\n        } else {\n            mark(aBufferWithMicroseconds[i]);\n        }\n    }\n}\n\n/**\n * Function using an 8 byte tick timing array to save program memory\n * Raw data starts with a Mark. No leading space as in received timing data!\n */\nvoid IRsend::sendRaw(const uint8_t aBufferWithTicks[], uint_fast16_t aLengthOfBuffer, uint_fast8_t aIRFrequencyKilohertz) {\n// Set IR carrier frequency\n    enableIROut(aIRFrequencyKilohertz);\n\n    for (uint_fast16_t i = 0; i < aLengthOfBuffer; i++) {\n        if (i & 1) {\n            // Odd\n            space(aBufferWithTicks[i] * MICROS_PER_TICK);\n        } else {\n            mark(aBufferWithTicks[i] * MICROS_PER_TICK);\n        }\n    }\n    IRLedOff();  // Always end with the LED off\n}\n\n/**\n * Function using an 16 byte microsecond timing array in FLASH for every purpose.\n * Raw data starts with a Mark. No leading space as in received timing data!\n */\nvoid IRsend::sendRaw_P(const uint16_t aBufferWithMicroseconds[], uint_fast16_t aLengthOfBuffer,\n        uint_fast8_t aIRFrequencyKilohertz) {\n#if !defined(__AVR__)\n    sendRaw(aBufferWithMicroseconds, aLengthOfBuffer, aIRFrequencyKilohertz); // Let the function work for non AVR platforms\n#else\n// Set IR carrier frequency\n    enableIROut(aIRFrequencyKilohertz);\n    /*\n     * Raw data starts with a mark\n     */\n    for (uint_fast16_t i = 0; i < aLengthOfBuffer; i++) {\n        auto duration = pgm_read_word(&aBufferWithMicroseconds[i]);\n        if (i & 1) {\n            // Odd\n            space(duration);\n#  if defined(LOCAL_DEBUG)\n            Serial.print(F(\"S=\"));\n#  endif\n        } else {\n            mark(duration);\n#  if defined(LOCAL_DEBUG)\n            Serial.print(F(\"M=\"));\n#  endif\n        }\n#  if defined(LOCAL_DEBUG)\n        Serial.println(duration);\n#  endif\n    }\n#endif\n}\n\n/**\n * New function using an 8 byte tick (50 us) timing array in FLASH to save program memory\n * Raw data starts with a Mark. No leading space as in received timing data!\n */\nvoid IRsend::sendRaw_P(const uint8_t aBufferWithTicks[], uint_fast16_t aLengthOfBuffer, uint_fast8_t aIRFrequencyKilohertz) {\n#if !defined(__AVR__)\n    sendRaw(aBufferWithTicks, aLengthOfBuffer, aIRFrequencyKilohertz); // Let the function work for non AVR platforms\n#else\n// Set IR carrier frequency\n    enableIROut(aIRFrequencyKilohertz);\n\n    uint_fast16_t duration;\n    for (uint_fast16_t i = 0; i < aLengthOfBuffer; i++) {\n        duration = pgm_read_byte(&aBufferWithTicks[i]) * (uint_fast16_t) MICROS_PER_TICK;\n        if (i & 1) {\n            // Odd\n            space(duration);\n#  if defined(LOCAL_DEBUG)\n            Serial.print(F(\"S=\"));\n#  endif\n        } else {\n            mark(duration);\n#  if defined(LOCAL_DEBUG)\n            Serial.print(F(\"M=\"));\n#  endif\n        }\n    }\n    IRLedOff();  // Always end with the LED off\n#  if defined(LOCAL_DEBUG)\n    Serial.println(duration);\n#  endif\n#endif\n}\n\n/**\n * Sends PulseDistance data from array\n * For LSB First the LSB of array[0] is sent first then all bits until MSB of array[0]. Next is LSB of array[1] and so on.\n * The output always ends with a space\n * Stop bit is always sent\n * @param aFlags    Evaluated flags are PROTOCOL_IS_MSB_FIRST and SUPPRESS_STOP_BIT_FOR_THIS_DATA. Stop bit is otherwise sent for all pulse distance protocols.\n */\nvoid IRsend::sendPulseDistanceWidthFromArray(uint_fast8_t aFrequencyKHz, DistanceWidthTimingInfoStruct *aDistanceWidthTimingInfo,\n        IRRawDataType *aDecodedRawDataArray, uint16_t aNumberOfBits, uint8_t aFlags, uint16_t aRepeatPeriodMillis,\n        int_fast8_t aNumberOfRepeats) {\n    sendPulseDistanceWidthFromArray(aFrequencyKHz, aDistanceWidthTimingInfo->HeaderMarkMicros,\n            aDistanceWidthTimingInfo->HeaderSpaceMicros, aDistanceWidthTimingInfo->OneMarkMicros,\n            aDistanceWidthTimingInfo->OneSpaceMicros, aDistanceWidthTimingInfo->ZeroMarkMicros,\n            aDistanceWidthTimingInfo->ZeroSpaceMicros, aDecodedRawDataArray, aNumberOfBits, aFlags, aRepeatPeriodMillis,\n            aNumberOfRepeats);\n}\nvoid IRsend::sendPulseDistanceWidthFromArray(uint_fast8_t aFrequencyKHz, uint16_t aHeaderMarkMicros, uint16_t aHeaderSpaceMicros,\n        uint16_t aOneMarkMicros, uint16_t aOneSpaceMicros, uint16_t aZeroMarkMicros, uint16_t aZeroSpaceMicros,\n        IRRawDataType *aDecodedRawDataArray, uint16_t aNumberOfBits, uint8_t aFlags, uint16_t aRepeatPeriodMillis,\n        int_fast8_t aNumberOfRepeats) {\n\n    // Set IR carrier frequency\n    enableIROut(aFrequencyKHz);\n\n    uint_fast8_t tNumberOfCommands = aNumberOfRepeats + 1;\n    uint_fast8_t tNumberOf32Or64BitChunks = ((aNumberOfBits - 1) / BITS_IN_RAW_DATA_TYPE) + 1;\n\n#if defined(LOCAL_DEBUG)\n    // fist data\n    Serial.print(F(\"Data[0]=0x\"));\n    Serial.print(aDecodedRawDataArray[0], HEX);\n    if (tNumberOf32Or64BitChunks > 1) {\n        Serial.print(F(\" Data[1]=0x\"));\n        Serial.print(aDecodedRawDataArray[1], HEX);\n    }\n    Serial.print(F(\" #=\"));\n    Serial.println(aNumberOfBits);\n    Serial.flush();\n#endif\n\n    while (tNumberOfCommands > 0) {\n        unsigned long tStartOfFrameMillis = millis();\n\n        // Header\n        mark(aHeaderMarkMicros);\n        space(aHeaderSpaceMicros);\n\n        for (uint_fast8_t i = 0; i < tNumberOf32Or64BitChunks; ++i) {\n            uint8_t tNumberOfBitsForOneSend;\n\n            // Manage stop bit\n            uint8_t tFlags;\n            if (i == (tNumberOf32Or64BitChunks - 1)) {\n                // End of data\n                tNumberOfBitsForOneSend = aNumberOfBits;\n                tFlags = aFlags;\n            } else {\n                // intermediate data\n                tNumberOfBitsForOneSend = BITS_IN_RAW_DATA_TYPE;\n                tFlags = aFlags | SUPPRESS_STOP_BIT_FOR_THIS_DATA; // No stop bit for leading data\n            }\n\n            sendPulseDistanceWidthData(aOneMarkMicros, aOneSpaceMicros, aZeroMarkMicros, aZeroSpaceMicros, aDecodedRawDataArray[i],\n                    tNumberOfBitsForOneSend, tFlags);\n            aNumberOfBits -= BITS_IN_RAW_DATA_TYPE;\n        }\n\n        tNumberOfCommands--;\n        // skip last delay!\n        if (tNumberOfCommands > 0) {\n            /*\n             * Check and fallback for wrong RepeatPeriodMillis parameter. I.e the repeat period must be greater than each frame duration.\n             */\n            auto tFrameDurationMillis = millis() - tStartOfFrameMillis;\n            if (aRepeatPeriodMillis > tFrameDurationMillis) {\n                delay(aRepeatPeriodMillis - tFrameDurationMillis);\n            }\n        }\n    }\n}\n\n/**\n * Sends PulseDistance data from array using PulseDistanceWidthProtocolConstants\n * For LSB First the LSB of array[0] is sent first then all bits until MSB of array[0]. Next is LSB of array[1] and so on.\n * The output always ends with a space\n * Stop bit is always sent\n * @param aNumberOfBits     Number of bits from aDecodedRawDataArray to be actually sent.\n * @param aNumberOfRepeats  If < 0 and a aProtocolConstants->SpecialSendRepeatFunction() is specified\n *                          then it is called without leading and trailing space.\n */\nvoid IRsend::sendPulseDistanceWidthFromArray(PulseDistanceWidthProtocolConstants *aProtocolConstants,\n        IRRawDataType *aDecodedRawDataArray, uint16_t aNumberOfBits, int_fast8_t aNumberOfRepeats) {\n\n// Calling sendPulseDistanceWidthFromArray() costs 68 bytes program memory compared to the implementation below\n//    sendPulseDistanceWidthFromArray(aProtocolConstants->FrequencyKHz, aProtocolConstants->DistanceWidthTimingInfo.HeaderMarkMicros,\n//            aProtocolConstants->DistanceWidthTimingInfo.HeaderSpaceMicros,\n//            aProtocolConstants->DistanceWidthTimingInfo.OneMarkMicros, aProtocolConstants->DistanceWidthTimingInfo.OneSpaceMicros,\n//            aProtocolConstants->DistanceWidthTimingInfo.ZeroMarkMicros, aProtocolConstants->DistanceWidthTimingInfo.ZeroSpaceMicros,\n//            aDecodedRawDataArray, aNumberOfBits, aProtocolConstants->Flags, aProtocolConstants->RepeatPeriodMillis,\n//            aNumberOfRepeats);\n    // Set IR carrier frequency\n    enableIROut(aProtocolConstants->FrequencyKHz);\n\n    uint_fast8_t tNumberOf32Or64BitChunks = ((aNumberOfBits - 1) / BITS_IN_RAW_DATA_TYPE) + 1;\n\n#if defined(LOCAL_DEBUG)\n    // fist data\n    Serial.print(F(\"Data[0]=0x\"));\n    Serial.print(aDecodedRawDataArray[0], HEX);\n    if (tNumberOf32Or64BitChunks > 1) {\n        Serial.print(F(\" Data[1]=0x\"));\n        Serial.print(aDecodedRawDataArray[1], HEX);\n    }\n    Serial.print(F(\" #=\"));\n    Serial.println(aNumberOfBits);\n    Serial.flush();\n#endif\n\n    uint_fast8_t tNumberOfCommands = aNumberOfRepeats + 1;\n    while (tNumberOfCommands > 0) {\n        auto tStartOfFrameMillis = millis();\n        auto tNumberOfBits = aNumberOfBits; // refresh value for repeats\n\n        // Header\n        mark(aProtocolConstants->DistanceWidthTimingInfo.HeaderMarkMicros);\n        space(aProtocolConstants->DistanceWidthTimingInfo.HeaderSpaceMicros);\n        uint8_t tOriginalFlags = aProtocolConstants->Flags;\n\n        for (uint_fast8_t i = 0; i < tNumberOf32Or64BitChunks; ++i) {\n            uint8_t tNumberOfBitsForOneSend;\n\n            uint8_t tFlags;\n            if (i == (tNumberOf32Or64BitChunks - 1)) {\n                // End of data\n                tNumberOfBitsForOneSend = tNumberOfBits;\n                tFlags = tOriginalFlags;\n            } else {\n                // intermediate data\n                tNumberOfBitsForOneSend = BITS_IN_RAW_DATA_TYPE;\n                tFlags = tOriginalFlags | SUPPRESS_STOP_BIT_FOR_THIS_DATA; // No stop bit for leading data\n            }\n\n            sendPulseDistanceWidthData(aProtocolConstants->DistanceWidthTimingInfo.OneMarkMicros,\n                    aProtocolConstants->DistanceWidthTimingInfo.OneSpaceMicros,\n                    aProtocolConstants->DistanceWidthTimingInfo.ZeroMarkMicros,\n                    aProtocolConstants->DistanceWidthTimingInfo.ZeroSpaceMicros, aDecodedRawDataArray[i], tNumberOfBitsForOneSend,\n                    tFlags);\n            tNumberOfBits -= BITS_IN_RAW_DATA_TYPE;\n        }\n\n        tNumberOfCommands--;\n        // skip last delay!\n        if (tNumberOfCommands > 0) {\n            /*\n             * Check and fallback for wrong RepeatPeriodMillis parameter. I.e the repeat period must be greater than each frame duration.\n             */\n            auto tFrameDurationMillis = millis() - tStartOfFrameMillis;\n            if (aProtocolConstants->RepeatPeriodMillis > tFrameDurationMillis) {\n                delay(aProtocolConstants->RepeatPeriodMillis - tFrameDurationMillis);\n            }\n        }\n    }\n}\n\n/**\n * Sends PulseDistance frames and repeats\n * @param aProtocolConstants    The constants to use for sending this protocol.\n * @param aData             uint32 or uint64 holding the bits to be sent.\n * @param aNumberOfBits     Number of bits from aData to be actually sent.\n * @param aNumberOfRepeats  If < 0 and a aProtocolConstants->SpecialSendRepeatFunction() is specified\n *                          then it is called without leading and trailing space.\n */\nvoid IRsend::sendPulseDistanceWidth(PulseDistanceWidthProtocolConstants *aProtocolConstants, IRRawDataType aData,\n        uint_fast8_t aNumberOfBits, int_fast8_t aNumberOfRepeats) {\n\n#if defined(LOCAL_DEBUG)\n    Serial.print(F(\"Data=0x\"));\n    Serial.print(aData, HEX);\n    Serial.print(F(\" #=\"));\n    Serial.println(aNumberOfBits);\n    Serial.flush();\n#endif\n\n    if (aNumberOfRepeats < 0) {\n        if (aProtocolConstants->SpecialSendRepeatFunction != NULL) {\n            /*\n             * Send only a special repeat and return\n             */\n            aProtocolConstants->SpecialSendRepeatFunction();\n            return;\n        } else {\n            // Send only one plain frame (as repeat)\n            aNumberOfRepeats = 0;\n        }\n    }\n\n    // Set IR carrier frequency\n    enableIROut(aProtocolConstants->FrequencyKHz);\n\n    uint_fast8_t tNumberOfCommands = aNumberOfRepeats + 1;\n    while (tNumberOfCommands > 0) {\n        unsigned long tStartOfFrameMillis = millis();\n\n        if (tNumberOfCommands < ((uint_fast8_t) aNumberOfRepeats + 1) && aProtocolConstants->SpecialSendRepeatFunction != NULL) {\n            // send special repeat, if specified and we are not in the first loop\n            aProtocolConstants->SpecialSendRepeatFunction();\n        } else {\n            /*\n             * Send Header and regular frame\n             */\n            mark(aProtocolConstants->DistanceWidthTimingInfo.HeaderMarkMicros);\n            space(aProtocolConstants->DistanceWidthTimingInfo.HeaderSpaceMicros);\n            sendPulseDistanceWidthData(aProtocolConstants, aData, aNumberOfBits);\n        }\n\n        tNumberOfCommands--;\n        // skip last delay!\n        if (tNumberOfCommands > 0) {\n            auto tCurrentFrameDurationMillis = millis() - tStartOfFrameMillis;\n            /*\n             * Check and fallback for wrong RepeatPeriodMillis parameter. I.e the repeat period must be greater than each frame duration.\n             */\n            if (aProtocolConstants->RepeatPeriodMillis > tCurrentFrameDurationMillis) {\n                delay(aProtocolConstants->RepeatPeriodMillis - tCurrentFrameDurationMillis);\n            }\n        }\n    }\n}\n\n/**\n * Sends PulseDistance frames and repeats.\n * @param aFrequencyKHz, aHeaderMarkMicros, aHeaderSpaceMicros, aOneMarkMicros, aOneSpaceMicros, aZeroMarkMicros, aZeroSpaceMicros, aFlags, aRepeatPeriodMillis     Values to use for sending this protocol, also contained in the PulseDistanceWidthProtocolConstants of this protocol.\n * @param aData             uint32 or uint64 holding the bits to be sent.\n * @param aNumberOfBits     Number of bits from aData to be actually sent.\n * @param aFlags            Evaluated flags are PROTOCOL_IS_MSB_FIRST and SUPPRESS_STOP_BIT_FOR_THIS_DATA. Stop bit is otherwise sent for all pulse distance protocols.\n * @param aNumberOfRepeats  If < 0 and a aProtocolConstants->SpecialSendRepeatFunction() is specified\n *                          then it is called without leading and trailing space.\n * @param aSpecialSendRepeatFunction    If NULL, the first frame is repeated completely, otherwise this function is used for sending the repeat frame.\n */\nvoid IRsend::sendPulseDistanceWidth(uint_fast8_t aFrequencyKHz, uint16_t aHeaderMarkMicros, uint16_t aHeaderSpaceMicros,\n        uint16_t aOneMarkMicros, uint16_t aOneSpaceMicros, uint16_t aZeroMarkMicros, uint16_t aZeroSpaceMicros, IRRawDataType aData,\n        uint_fast8_t aNumberOfBits, uint8_t aFlags, uint16_t aRepeatPeriodMillis, int_fast8_t aNumberOfRepeats,\n        void (*aSpecialSendRepeatFunction)()) {\n\n    if (aNumberOfRepeats < 0) {\n        if (aSpecialSendRepeatFunction != NULL) {\n            aSpecialSendRepeatFunction();\n            return;\n        } else {\n            aNumberOfRepeats = 0; // send a plain frame as repeat\n        }\n    }\n\n    // Set IR carrier frequency\n    enableIROut(aFrequencyKHz);\n\n    uint_fast8_t tNumberOfCommands = aNumberOfRepeats + 1;\n    while (tNumberOfCommands > 0) {\n        unsigned long tStartOfFrameMillis = millis();\n\n        if (tNumberOfCommands < ((uint_fast8_t) aNumberOfRepeats + 1) && aSpecialSendRepeatFunction != NULL) {\n            // send special repeat\n            aSpecialSendRepeatFunction();\n        } else {\n            // Header and regular frame\n            mark(aHeaderMarkMicros);\n            space(aHeaderSpaceMicros);\n            sendPulseDistanceWidthData(aOneMarkMicros, aOneSpaceMicros, aZeroMarkMicros, aZeroSpaceMicros, aData, aNumberOfBits,\n                    aFlags);\n        }\n\n        tNumberOfCommands--;\n        // skip last delay!\n        if (tNumberOfCommands > 0) {\n            /*\n             * Check and fallback for wrong RepeatPeriodMillis parameter. I.e the repeat period must be greater than each frame duration.\n             */\n            auto tFrameDurationMillis = millis() - tStartOfFrameMillis;\n            if (aRepeatPeriodMillis > tFrameDurationMillis) {\n                delay(aRepeatPeriodMillis - tFrameDurationMillis);\n            }\n        }\n    }\n}\n\n/**\n * Sends PulseDistance from data contained in parameter using ProtocolConstants structure for timing etc.\n * The output always ends with a space\n * Each additional call costs 16 bytes program memory\n * @param aProtocolConstants    The constants to use for sending this protocol.\n * @param aData                 uint32 or uint64 holding the bits to be sent.\n * @param aNumberOfBits         Number of bits from aData to be actually sent.\n */\nvoid IRsend::sendPulseDistanceWidthData(PulseDistanceWidthProtocolConstants *aProtocolConstants, IRRawDataType aData,\n        uint_fast8_t aNumberOfBits) {\n\n    sendPulseDistanceWidthData(aProtocolConstants->DistanceWidthTimingInfo.OneMarkMicros,\n            aProtocolConstants->DistanceWidthTimingInfo.OneSpaceMicros, aProtocolConstants->DistanceWidthTimingInfo.ZeroMarkMicros,\n            aProtocolConstants->DistanceWidthTimingInfo.ZeroSpaceMicros, aData, aNumberOfBits, aProtocolConstants->Flags);\n}\n\n/**\n * Sends PulseDistance data with timing parameters and flag parameters.\n * The output always ends with a space\n * @param aOneMarkMicros    Timing for sending this protocol.\n * @param aData             uint32 or uint64 holding the bits to be sent.\n * @param aNumberOfBits     Number of bits from aData to be actually sent.\n * @param aFlags            Evaluated flags are PROTOCOL_IS_MSB_FIRST and SUPPRESS_STOP_BIT_FOR_THIS_DATA. Stop bit is otherwise sent for all pulse distance protocols.\n */\nvoid IRsend::sendPulseDistanceWidthData(uint16_t aOneMarkMicros, uint16_t aOneSpaceMicros, uint16_t aZeroMarkMicros,\n        uint16_t aZeroSpaceMicros, IRRawDataType aData, uint_fast8_t aNumberOfBits, uint8_t aFlags) {\n\n#if defined(LOCAL_DEBUG)\n    Serial.print(aData, HEX);\n    Serial.print('|');\n    Serial.println(aNumberOfBits);\n    Serial.flush();\n#endif\n\n    // For MSBFirst, send data from MSB to LSB until mask bit is shifted out\n    IRRawDataType tMask = 1ULL << (aNumberOfBits - 1);\n    for (uint_fast8_t i = aNumberOfBits; i > 0; i--) {\n        if (((aFlags & PROTOCOL_IS_MSB_FIRST) && (aData & tMask)) || (!(aFlags & PROTOCOL_IS_MSB_FIRST) && (aData & 1))) {\n#if defined(LOCAL_TRACE)\n            Serial.print('1');\n#endif\n            mark(aOneMarkMicros);\n            space(aOneSpaceMicros);\n        } else {\n#if defined(LOCAL_TRACE)\n            Serial.print('0');\n#endif\n            mark(aZeroMarkMicros);\n            space(aZeroSpaceMicros);\n        }\n        if (aFlags & PROTOCOL_IS_MSB_FIRST) {\n            tMask >>= 1;\n        } else {\n            aData >>= 1;\n        }\n    }\n    /*\n     * Stop bit is sent for all pulse distance protocols i.e. aOneMarkMicros == aZeroMarkMicros.\n     * Therefore it is not sent for Sony and Magiquest :-)\n     * For sending from an array, no intermediate stop bit must be sent for first data chunk.\n     */\n    if (!(aFlags & SUPPRESS_STOP_BIT_FOR_THIS_DATA) && aOneMarkMicros == aZeroMarkMicros) {\n        // Send stop bit here\n#if defined(LOCAL_TRACE)\n        Serial.print('S');\n#endif\n        mark(aZeroMarkMicros); // Use aZeroMarkMicros for stop bits. This seems to be correct for all protocols :-)\n    }\n#if defined(LOCAL_TRACE)\n    Serial.println();\n#endif\n}\n\n/**\n * Sends Biphase data MSB first\n * Always send start bit, do not send the trailing space of the start bit\n * 0 -> mark+space\n * 1 -> space+mark\n * The output always ends with a space\n * can only send 31 bit data, since we put the start bit as 32th bit on front\n * @param aData             uint32 or uint64 holding the bits to be sent.\n * @param aNumberOfBits     Number of bits from aData to be actually sent.\n */\nvoid IRsend::sendBiphaseData(uint16_t aBiphaseTimeUnit, uint32_t aData, uint_fast8_t aNumberOfBits) {\n\n    IR_TRACE_PRINT(F(\"0x\"));\n    IR_TRACE_PRINT(aData, HEX);\n\n#if defined(LOCAL_TRACE)\n    Serial.print('S');\n#endif\n\n// Data - Biphase code MSB first\n// prepare for start with sending the start bit, which is 1\n    uint32_t tMask = 1UL << aNumberOfBits;    // mask is now set for the virtual start bit\n    uint_fast8_t tLastBitValue = 1;    // Start bit is a 1\n    bool tNextBitIsOne = 1;    // Start bit is a 1\n    for (uint_fast8_t i = aNumberOfBits + 1; i > 0; i--) {\n        bool tCurrentBitIsOne = tNextBitIsOne;\n        tMask >>= 1;\n        tNextBitIsOne = ((aData & tMask) != 0) || (i == 1); // true for last bit to avoid extension of mark\n        if (tCurrentBitIsOne) {\n#if defined(LOCAL_TRACE)\n            Serial.print('1');\n#endif\n            space(aBiphaseTimeUnit);\n            if (tNextBitIsOne) {\n                mark(aBiphaseTimeUnit);\n            } else {\n                // if next bit is 0, extend the current mark in order to generate a continuous signal without short breaks\n                mark(2 * aBiphaseTimeUnit);\n            }\n            tLastBitValue = 1;\n\n        } else {\n#if defined(LOCAL_TRACE)\n            Serial.print('0');\n#endif\n            if (!tLastBitValue) {\n                mark(aBiphaseTimeUnit);\n            }\n            space(aBiphaseTimeUnit);\n            tLastBitValue = 0;\n        }\n    }\n    IR_TRACE_PRINTLN(F(\"\"));\n}\n\n/**\n * Sends an IR mark for the specified number of microseconds.\n * The mark output is modulated at the PWM frequency if USE_NO_SEND_PWM is not defined.\n * The output is guaranteed to be OFF / inactive after after the call of the function.\n * This function may affect the state of feedback LED.\n * Period time is 26 us for 38.46 kHz, 27 us for 37.04 kHz, 25 us for 40 kHz.\n * On time is 8 us for 30% duty cycle\n *\n * The mark() function relies on the correct implementation of:\n * delayMicroseconds() for pulse time, and micros() for pause time.\n * The delayMicroseconds() of pulse time is guarded on AVR CPU's with noInterrupts() / interrupts().\n * At the start of pause time, interrupts are enabled once, the rest of the pause is also guarded on AVR CPU's with noInterrupts() / interrupts().\n * The maximum length of an interrupt during sending should not exceed 26 us - 8 us = 18 us, otherwise timing is disturbed.\n * This disturbance is no problem, if the exceedance is small and does not happen too often.\n */\nvoid IRsend::mark(uint16_t aMarkMicros) {\n\n#if defined(SEND_PWM_BY_TIMER) || defined(USE_NO_SEND_PWM)\n#  if !defined(NO_LED_FEEDBACK_CODE)\n    if (FeedbackLEDControl.LedFeedbackEnabled == LED_FEEDBACK_ENABLED_FOR_SEND) {\n        setFeedbackLED(true);\n    }\n#  endif\n#endif\n\n#if defined(SEND_PWM_BY_TIMER)\n    /*\n     * Generate hardware PWM signal\n     */\n    enableSendPWMByTimer(); // Enable timer or ledcWrite() generated PWM output\n    customDelayMicroseconds(aMarkMicros);\n    IRLedOff(); // disables hardware PWM and manages feedback LED\n    return;\n\n#elif defined(USE_NO_SEND_PWM)\n    /*\n     * Here we generate no carrier PWM, just simulate an active low receiver signal.\n     */\n#  if defined(USE_OPEN_DRAIN_OUTPUT_FOR_SEND_PIN) && !defined(OUTPUT_OPEN_DRAIN)\n    pinModeFast(sendPin, OUTPUT); // active state for mimicking open drain\n#  else\n    digitalWriteFast(sendPin, LOW); // Set output to active low.\n#  endif\n\n    customDelayMicroseconds(aMarkMicros);\n    IRLedOff();\n#  if !defined(NO_LED_FEEDBACK_CODE)\n    if (FeedbackLEDControl.LedFeedbackEnabled == LED_FEEDBACK_ENABLED_FOR_SEND) {\n        setFeedbackLED(false);\n    }\n    return;\n#  endif\n\n#else // defined(SEND_PWM_BY_TIMER)\n    /*\n     * Generate PWM by bit banging\n     */\n    unsigned long tStartMicros = micros();\n    unsigned long tNextPeriodEnding = tStartMicros;\n    unsigned long tMicros;\n#  if !defined(NO_LED_FEEDBACK_CODE)\n    bool FeedbackLedIsActive = false;\n#  endif\n\n    do {\n//        digitalToggleFast(_IR_TIMING_TEST_PIN);\n        /*\n         * Output the PWM pulse\n         */\n        noInterrupts(); // do not let interrupts extend the short on period\n#  if defined(USE_OPEN_DRAIN_OUTPUT_FOR_SEND_PIN)\n#    if defined(OUTPUT_OPEN_DRAIN)\n        digitalWriteFast(sendPin, LOW); // set output with pin mode OUTPUT_OPEN_DRAIN to active low\n#    else\n        pinModeFast(sendPin, OUTPUT); // active state for mimicking open drain\n#    endif\n#  else\n        // 3.5 us from FeedbackLed on to pin setting. 5.7 us from call of mark() to pin setting incl. setting of feedback pin.\n        // 4.3 us from do{ to pin setting if sendPin is no constant\n        digitalWriteFast(sendPin, HIGH);\n#  endif\n        delayMicroseconds (periodOnTimeMicros); // On time is 8 us for 30% duty cycle. This is normally implemented by a blocking wait.\n\n        /*\n         * Output the PWM pause\n         */\n#  if defined(USE_OPEN_DRAIN_OUTPUT_FOR_SEND_PIN) && !defined(OUTPUT_OPEN_DRAIN)\n#    if defined(OUTPUT_OPEN_DRAIN)\n        digitalWriteFast(sendPin, HIGH); // Set output with pin mode OUTPUT_OPEN_DRAIN to inactive high.\n#    else\n        pinModeFast(sendPin, INPUT); // to mimic the open drain inactive state\n#    endif\n\n#  else\n        digitalWriteFast(sendPin, LOW);\n#  endif\n        /*\n         * Enable interrupts at start of the longer off period. Required at least to keep micros correct.\n         * If receive interrupt is still active, it takes 3.4 us from now until receive ISR is active (for 7 us + pop's)\n         */\n        interrupts();\n\n#  if !defined(NO_LED_FEEDBACK_CODE)\n        /*\n         * Delayed call of setFeedbackLED() to get better startup timing, especially required for consecutive marks\n         */\n        if (!FeedbackLedIsActive) {\n            FeedbackLedIsActive = true;\n            if (FeedbackLEDControl.LedFeedbackEnabled == LED_FEEDBACK_ENABLED_FOR_SEND) {\n                setFeedbackLED(true);\n            }\n        }\n#  endif\n        /*\n         * PWM pause timing\n         * Measured delta between pause duration values are 13 us for a 16 MHz Uno (from 13 to 26), if interrupts are disabled below\n         * Measured delta between pause duration values are 20 us for a 16 MHz Uno (from 7.8 to 28), if interrupts are not disabled below\n         * Minimal pause duration is 5.2 us with NO_LED_FEEDBACK_CODE enabled\n         * and 8.1 us with NO_LED_FEEDBACK_CODE disabled.\n         */\n        tNextPeriodEnding += periodTimeMicros;\n#if defined(__AVR__) // micros() for STM sometimes give decreasing values if interrupts are disabled. See https://github.com/stm32duino/Arduino_Core_STM32/issues/1680\n        noInterrupts(); // disable interrupts (especially the 20 us receive interrupts) only at start of the PWM pause. Otherwise it may extend the pause too much.\n#endif\n        do {\n#if defined(_IR_MEASURE_TIMING) && defined(_IR_TIMING_TEST_PIN)\n            digitalWriteFast(_IR_TIMING_TEST_PIN, HIGH); // 2 clock cycles\n#endif\n            /*\n             * For AVR @16MHz we have only 4 us resolution.\n             * The duration of the micros() call itself is 3 us.\n             * It takes 0.9 us from signal going low here.\n             * The rest of the loop takes 1.2 us with NO_LED_FEEDBACK_CODE enabled\n             * and 3 us with NO_LED_FEEDBACK_CODE disabled.\n             */\n#if defined(_IR_MEASURE_TIMING) && defined(_IR_TIMING_TEST_PIN)\n            digitalWriteFast(_IR_TIMING_TEST_PIN, LOW); // 2 clock cycles\n#endif\n            /*\n             * Exit the forever loop if aMarkMicros has reached\n             */\n            tMicros = micros();\n            uint16_t tDeltaMicros = tMicros - tStartMicros;\n#if defined(__AVR__)\n            // reset feedback led in the last pause before end\n//            tDeltaMicros += (160 / CLOCKS_PER_MICRO); // adding this once increases program size, so do it below !\n#  if !defined(NO_LED_FEEDBACK_CODE)\n            if (tDeltaMicros >= aMarkMicros - (30 + (112 / CLOCKS_PER_MICRO))) { // 30 to be constant. Using periodTimeMicros increases program size too much.\n                if (FeedbackLEDControl.LedFeedbackEnabled == LED_FEEDBACK_ENABLED_FOR_SEND) {\n                    setFeedbackLED(false);\n                }\n            }\n#  endif\n            // Just getting variables and check for end condition takes minimal 3.8 us\n            if (tDeltaMicros >= aMarkMicros - (112 / CLOCKS_PER_MICRO)) { // To compensate for call duration - 112 is an empirical value\n#else\n            if (tDeltaMicros >= aMarkMicros) {\n#  if !defined(NO_LED_FEEDBACK_CODE)\n                if (FeedbackLEDControl.LedFeedbackEnabled == LED_FEEDBACK_ENABLED_FOR_SEND) {\n                    setFeedbackLED(false);\n                }\n#  endif\n#endif\n#if defined(__AVR__)\n                interrupts();\n#endif\n                return;\n            }\n        } while (tMicros < tNextPeriodEnding);\n    } while (true);\n#  endif\n}\n\n/**\n * Just switch the IR sending LED off to send an IR space\n * A space is \"no output\", so the PWM output is disabled.\n * This function may affect the state of feedback LED.\n */\nvoid IRsend::IRLedOff() {\n#if defined(SEND_PWM_BY_TIMER)\n    disableSendPWMByTimer(); // Disable PWM output\n#elif defined(USE_NO_SEND_PWM)\n#  if defined(USE_OPEN_DRAIN_OUTPUT_FOR_SEND_PIN) && !defined(OUTPUT_OPEN_DRAIN)\n    digitalWriteFast(sendPin, LOW); // prepare for all next active states.\n    pinModeFast(sendPin, INPUT);// inactive state for open drain\n#  else\n    digitalWriteFast(sendPin, HIGH); // Set output to inactive high.\n#  endif\n#else\n#  if defined(USE_OPEN_DRAIN_OUTPUT_FOR_SEND_PIN)\n#    if defined(OUTPUT_OPEN_DRAIN)\n    digitalWriteFast(sendPin, HIGH); // Set output to inactive high.\n#    else\n    pinModeFast(sendPin, INPUT); // inactive state to mimic open drain\n#    endif\n#  else\n    digitalWriteFast(sendPin, LOW);\n#  endif\n#endif\n\n#if !defined(NO_LED_FEEDBACK_CODE)\n    if (FeedbackLEDControl.LedFeedbackEnabled == LED_FEEDBACK_ENABLED_FOR_SEND) {\n        setFeedbackLED(false);\n    }\n#endif\n}\n\n/**\n * Sends an IR space for the specified number of microseconds.\n * A space is \"no output\", so just wait.\n */\nvoid IRsend::space(uint16_t aSpaceMicros) {\n    customDelayMicroseconds(aSpaceMicros);\n}\n\n/**\n * Custom delay function that circumvents Arduino's delayMicroseconds 16 bit limit\n * and is (mostly) not extended by the duration of interrupt codes like the millis() interrupt\n */\nvoid IRsend::customDelayMicroseconds(unsigned long aMicroseconds) {\n#if defined(ESP32) || defined(ESP8266)\n    // from https://github.com/crankyoldgit/IRremoteESP8266/blob/00b27cc7ea2e7ac1e48e91740723c805a38728e0/src/IRsend.cpp#L123\n    // Invoke a delay(), where possible, to avoid triggering the WDT.\n    // see https://github.com/Arduino-IRremote/Arduino-IRremote/issues/1114 for the reason of checking for > 16383)\n    // delayMicroseconds() is only accurate to 16383 us. Ref: https://www.arduino.cc/en/Reference/delayMicroseconds\n    if (aMicroseconds > 16383) {\n        delay(aMicroseconds / 1000UL);  // Delay for as many whole milliseconds as we can.\n        // Delay the remaining sub-millisecond.\n        delayMicroseconds(static_cast<uint16_t>(aMicroseconds % 1000UL));\n    } else {\n        delayMicroseconds(aMicroseconds);\n    }\n#else\n\n#  if defined(__AVR__)\n    unsigned long start = micros() - (64 / clockCyclesPerMicrosecond()); // - (64 / clockCyclesPerMicrosecond()) for reduced resolution and additional overhead\n#  else\n    unsigned long start = micros();\n#  endif\n// overflow invariant comparison :-)\n    while (micros() - start < aMicroseconds) {\n    }\n#endif\n}\n\n/**\n * Enables IR output. The kHz value controls the modulation frequency in kilohertz.\n * IF PWM should be generated by a timer, it uses the platform specific timerConfigForSend() function,\n * otherwise it computes the delays used by the mark() function.\n * If IR_SEND_PIN is defined, maximum PWM frequency for an AVR @16 MHz is 170 kHz (180 kHz if NO_LED_FEEDBACK_CODE is defined)\n */\nvoid IRsend::enableIROut(uint_fast8_t aFrequencyKHz) {\n#if defined(SEND_PWM_BY_TIMER)\n    timerConfigForSend(aFrequencyKHz); // must set output pin mode and disable receive interrupt if required, e.g. uses the same resource\n\n#elif defined(USE_NO_SEND_PWM)\n    (void) aFrequencyKHz;\n\n#else\n    periodTimeMicros = (1000U + (aFrequencyKHz / 2)) / aFrequencyKHz; // rounded value -> 26 for 38.46 kHz, 27 for 37.04 kHz, 25 for 40 kHz.\n#  if defined(IR_SEND_PIN)\n    periodOnTimeMicros = (((periodTimeMicros * IR_SEND_DUTY_CYCLE_PERCENT) + 50) / 100U); // +50 for rounding -> 830/100 for 30% and 16 MHz\n#  else\n// Heuristics! We require a nanosecond correction for \"slow\" digitalWrite() functions\n    periodOnTimeMicros = (((periodTimeMicros * IR_SEND_DUTY_CYCLE_PERCENT) + 50 - (PULSE_CORRECTION_NANOS / 10)) / 100U); // +50 for rounding -> 530/100 for 30% and 16 MHz\n#  endif\n#endif // defined(SEND_PWM_BY_TIMER)\n\n#if defined(USE_OPEN_DRAIN_OUTPUT_FOR_SEND_PIN) && defined(OUTPUT_OPEN_DRAIN) // the mode INPUT for mimicking open drain is set at IRLedOff()\n#  if defined(IR_SEND_PIN)\n    pinModeFast(IR_SEND_PIN, OUTPUT_OPEN_DRAIN);\n#  else\n    pinModeFast(sendPin, OUTPUT_OPEN_DRAIN);\n#  endif\n#else\n\n// For Non AVR platforms pin mode for SEND_PWM_BY_TIMER must be handled by the timerConfigForSend() function\n// because ESP 2.0.2 ledcWrite does not work if pin mode is set, and RP2040 requires gpio_set_function(IR_SEND_PIN, GPIO_FUNC_PWM);\n#  if defined(__AVR__) || !defined(SEND_PWM_BY_TIMER)\n#    if defined(IR_SEND_PIN)\n    pinModeFast(IR_SEND_PIN, OUTPUT);\n#    else\n    pinModeFast(sendPin, OUTPUT);\n#    endif\n#  endif\n#endif // defined(USE_OPEN_DRAIN_OUTPUT_FOR_SEND_PIN)\n}\n\n#if defined(SEND_PWM_BY_TIMER)\n// Used for Bang&Olufsen\nvoid IRsend::enableHighFrequencyIROut(uint_fast16_t aFrequencyKHz) {\n    timerConfigForSend(aFrequencyKHz); // must set output pin mode and disable receive interrupt if required, e.g. uses the same resource\n    // For Non AVR platforms pin mode for SEND_PWM_BY_TIMER must be handled by the timerConfigForSend() function\n    // because ESP 2.0.2 ledcWrite does not work if pin mode is set, and RP2040 requires gpio_set_function(IR_SEND_PIN, GPIO_FUNC_PWM);\n#  if defined(__AVR__)\n#    if defined(IR_SEND_PIN)\n    pinModeFast(IR_SEND_PIN, OUTPUT);\n#    else\n    pinModeFast(sendPin, OUTPUT);\n#    endif\n#  endif\n}\n#endif\n\nuint16_t IRsend::getPulseCorrectionNanos() {\n    return PULSE_CORRECTION_NANOS;\n}\n\n/** @}*/\n#if defined(_IR_MEASURE_TIMING)\n#undef _IR_MEASURE_TIMING\n#endif\n#if defined(LOCAL_TRACE)\n#undef LOCAL_TRACE\n#endif\n#if defined(LOCAL_DEBUG)\n#undef LOCAL_DEBUG\n#endif\n#endif // _IR_SEND_HPP\n"
    }, {
      filename: "src/LongUnion.h",
      code: "/*\n * LongUnion.h\n *\n *  Copyright (C) 2020-2022  Armin Joachimsmeyer\n *  Email: armin.joachimsmeyer@gmail.com\n *\n *  This file is part of Arduino-Utils https://github.com/ArminJo/Arduino-Utils.\n *\n *  Arduino-Utils is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n *  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program. If not, see <http://www.gnu.org/licenses/gpl.html>.\n *\n */\n\n#if !defined(_WORD_UNION_H) || !defined(_LONG_UNION_H) || !defined(_LONG_LONG_UNION_H)\n\n#include <stdint.h>\n\n#ifndef _WORD_UNION_H\n#define _WORD_UNION_H\n/**\n * Union to specify parts / manifestations of a 16 bit Word without casts and shifts.\n * It also supports the compiler generating small code.\n * Usage: WordUnion tWord;\n *        tWord.UByte.HighByte = 0x12;\n */\nunion WordUnion {\n    struct {\n        uint8_t LowByte;\n        uint8_t HighByte;\n    } UByte;\n    struct {\n        int8_t LowByte;\n        int8_t HighByte;\n    } Byte;\n    uint8_t UBytes[2]; // UBytes[0] is LowByte\n    int8_t Bytes[2];\n    uint16_t UWord;\n    int16_t Word;\n    uint8_t *BytePointer;\n};\n#endif // _WORD_UNION_H\n\n#ifndef _LONG_UNION_H\n#define _LONG_UNION_H\n/**\n * Union to specify parts / manifestations of a 32 bit Long without casts and shifts.\n * It also supports the compiler generating small code.\n */\nunion LongUnion {\n    struct {\n        uint8_t LowByte;\n        uint8_t MidLowByte;\n        uint8_t MidHighByte;\n        uint8_t HighByte;\n    } UByte;\n    struct {\n        int8_t LowByte;\n        int8_t MidLowByte;\n        int8_t MidHighByte;\n        int8_t HighByte;\n    } Byte;\n    /* Does not work for STM32\n    struct {\n        uint8_t LowByte;\n        uint16_t MidWord;\n        uint8_t HighByte;\n    } UByteWord;\n    */\n    struct {\n        uint16_t LowWord;\n        uint16_t HighWord;\n    } UWord;\n    struct {\n        int16_t LowWord;\n        int16_t HighWord;\n    } Word;\n    struct {\n        WordUnion LowWord;\n        WordUnion HighWord;\n    } WordUnion;\n    uint8_t UBytes[4]; // seems to have the same code size as using struct UByte\n    int8_t Bytes[4]; // Bytes[0] is LowByte\n    uint16_t UWords[2];\n    int16_t Words[2];\n    uint32_t ULong;\n    int32_t Long;\n    float Float;\n};\n#endif // _LONG_UNION_H\n\n#ifndef _LONG_LONG_UNION_H\n#define _LONG_LONG_UNION_H\n/**\n * Union to specify parts / manifestations of a 64 bit LongLong without casts and shifts.\n * It also supports the compiler generating small code.\n */\nunion LongLongUnion {\n    struct {\n        uint16_t LowWord;\n        uint16_t MidLowWord;\n        uint16_t MidHighWord;\n        uint16_t HighWord;\n    } UWord;\n    struct {\n        int16_t LowWord;\n        int16_t MidLowWord;\n        int16_t MidHighWord;\n        int16_t HighWord;\n    } Word;\n    struct {\n        WordUnion LowWord;\n        WordUnion MidLowWord;\n        WordUnion MidHighWord;\n        WordUnion HighWord;\n    } WordUnion;\n    struct {\n        uint32_t LowLong;\n        uint32_t HighLong;\n    } ULong;\n    struct {\n        int32_t LowLong;\n        int32_t HighLong;\n    } Long;\n    struct {\n        LongUnion LowLong;\n        LongUnion HighLong;\n    } LongUnion;\n    uint8_t UBytes[8]; // seems to have the same code size as using struct UByte\n    int8_t Bytes[8];\n    uint16_t UWords[4];\n    int16_t Words[4];\n    uint64_t ULongLong;\n    int64_t LongLong;\n#if __DBL_MANT_DIG__== 24\n    float Floats[2]; // 32 bit double, as for AVR\n#else\n    // 64 bit double\n    double Double;\n#endif\n};\n#endif // _LONG_LONG_UNION_H\n\n#endif //  !defined(_WORD_UNION_H) || !defined(_LONG_UNION_H) || !defined(_LONG_LONG_UNION_H)\n"
    }, {
      filename: "src/ir_RC5_RC6.hpp",
      code: "/*\n * ir_RC5_RC6.hpp\n *\n *  Contains functions for receiving and sending RC5, RC5X, RC6 protocols\n *\n *  This file is part of Arduino-IRremote https://github.com/Arduino-IRremote/Arduino-IRremote.\n *\n ************************************************************************************\n * MIT License\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is furnished\n * to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n ************************************************************************************\n */\n#ifndef _IR_RC5_RC6_HPP\n#define _IR_RC5_RC6_HPP\n\n#if defined(DEBUG) && !defined(LOCAL_DEBUG)\n#define LOCAL_DEBUG\n#else\n//#define LOCAL_DEBUG // This enables debug output only for this file\n#endif\n\n/** \\addtogroup Decoder Decoders and encoders for different protocols\n * @{\n */\nuint8_t sLastSendToggleValue = 1; // To start first command with toggle 0\n//uint8_t sLastReceiveToggleValue = 3; // 3 -> start value\n\n//==============================================================================\n//     RRRR    CCCC  55555\n//     R   R  C      5\n//     RRRR   C      5555\n//     R  R   C          5\n//     R   R   CCCC  5555\n//==============================================================================\n/*\n Protocol=RC5 Address=0x11 Command=0x36 Raw-Data=0x1476 13 bits MSB first\n + 900,- 900\n +1800,-1750 +1800,- 850 + 900,- 850 + 900,-1750\n + 950,- 850 + 900,- 850 +1800,-1750 + 950,- 850\n +1800\n Sum: 23100\n\n RC5X with 7.th MSB of command set\n Protocol=RC5 Address=0x11 Command=0x76 Toggle=1 Raw-Data=0xC76 13 bits MSB first\n +1800,-1750\n + 850,- 900 +1800,- 850 + 950,- 850 + 900,-1750\n + 900,- 850 + 950,- 850 +1800,-1750 + 900,- 850\n +1800\n Sum: 23050\n */\n//\n// see: https://www.sbprojects.net/knowledge/ir/rc5.php\n// https://en.wikipedia.org/wiki/Manchester_code\n// https://forum.arduino.cc/t/sending-rc-5-extended-code-using-irsender/1045841/10 - Protocol Maranz Extended\n// mark->space => 0\n// space->mark => 1\n// MSB first 1 start bit, 1 field bit, 1 toggle bit + 5 bit address + 6 bit command, no stop bit\n// Field bit is 1 for RC5 and inverted 7. command bit for RC5X. That way the first 64 commands of RC5X remain compatible with the original RC5.\n// SF TAAA  AACC CCCC\n// IR duty factor is 25%,\n//\n#define RC5_ADDRESS_BITS        5\n#define RC5_COMMAND_BITS        6\n#define RC5_COMMAND_FIELD_BIT   1\n#define RC5_TOGGLE_BIT          1\n\n#define RC5_BITS            (RC5_COMMAND_FIELD_BIT + RC5_TOGGLE_BIT + RC5_ADDRESS_BITS + RC5_COMMAND_BITS) // 13\n\n#define RC5_UNIT            889 // 32 periods of 36 kHz (888.8888)\n\n#define MIN_RC5_MARKS       ((RC5_BITS + 1) / 2) // 7. Divided by 2 to handle the bit sequence of 01010101 which gives one mark and space for each 2 bits\n\n#define RC5_DURATION        (15L * RC5_UNIT) // 13335\n#define RC5_REPEAT_PERIOD   (128L * RC5_UNIT) // 113792\n#define RC5_REPEAT_DISTANCE (RC5_REPEAT_PERIOD - RC5_DURATION) // 100 ms\n#define RC5_MAXIMUM_REPEAT_DISTANCE     (RC5_REPEAT_DISTANCE + (RC5_REPEAT_DISTANCE / 4)) // Just a guess\n\n/************************************\n * Start of send and decode functions\n ************************************/\n\n/**\n * @param aCommand If aCommand is >=0x40 then we switch automatically to RC5X.\n * @param aEnableAutomaticToggle Send toggle bit according to the state of the static sLastSendToggleValue variable.\n */\nvoid IRsend::sendRC5(uint8_t aAddress, uint8_t aCommand, int_fast8_t aNumberOfRepeats, bool aEnableAutomaticToggle) {\n    // Set IR carrier frequency\n    enableIROut (RC5_RC6_KHZ);\n\n    uint16_t tIRData = ((aAddress & 0x1F) << RC5_COMMAND_BITS);\n\n    if (aCommand < 0x40) {\n        // Auto discovery of RC5X, set field bit to 1\n        tIRData |= 1 << (RC5_TOGGLE_BIT + RC5_ADDRESS_BITS + RC5_COMMAND_BITS);\n    } else {\n        // Mask bit 7 of command and let field bit 0\n        aCommand &= 0x3F;\n    }\n    tIRData |= aCommand;\n\n    if (aEnableAutomaticToggle) {\n        if (sLastSendToggleValue == 0) {\n            sLastSendToggleValue = 1;\n            // set toggled bit\n            tIRData |= 1 << (RC5_ADDRESS_BITS + RC5_COMMAND_BITS);\n        } else {\n            sLastSendToggleValue = 0;\n        }\n    }\n\n    uint_fast8_t tNumberOfCommands = aNumberOfRepeats + 1;\n    while (tNumberOfCommands > 0) {\n\n        // start bit is sent by sendBiphaseData\n        sendBiphaseData(RC5_UNIT, tIRData, RC5_BITS);\n\n        tNumberOfCommands--;\n        // skip last delay!\n        if (tNumberOfCommands > 0) {\n            // send repeated command in a fixed raster\n            delay(RC5_REPEAT_DISTANCE / MICROS_IN_ONE_MILLI);\n        }\n    }\n}\n\n/**\n * Try to decode data as RC5 protocol\n *                             _   _   _   _   _   _   _   _   _   _   _   _   _\n * Clock                 _____| |_| |_| |_| |_| |_| |_| |_| |_| |_| |_| |_| |_| |\n *                                ^   ^   ^   ^   ^   ^   ^   ^   ^   ^   ^   ^    End of each data bit period\n *                               _   _     - Mark\n * 2 Start bits for RC5    _____| |_| ...  - Data starts with a space->mark bit\n *                                         - Space\n *                               _\n * 1 Start bit for RC5X    _____| ...\n *\n */\nbool IRrecv::decodeRC5() {\n    uint8_t tBitIndex;\n    uint32_t tDecodedRawData = 0;\n\n    // Set Biphase decoding start values\n    initBiphaselevel(1, RC5_UNIT); // Skip gap space\n\n    // Check we have the right amount of data (11 to 26). The +2 is for initial gap and start bit mark.\n    if (decodedIRData.rawlen < ((RC5_BITS + 1) / 2) + 2 && (RC5_BITS + 2) < decodedIRData.rawlen) {\n        // no debug output, since this check is mainly to determine the received protocol\n        IR_DEBUG_PRINT(F(\"RC5: \"));\n        IR_DEBUG_PRINT(F(\"Data length=\"));\n        IR_DEBUG_PRINT(decodedIRData.rawlen);\n        IR_DEBUG_PRINTLN(F(\" is not between 9 and 15\"));\n        return false;\n    }\n\n// Check start bit, the first space is included in the gap\n    if (getBiphaselevel() != MARK) {\n        IR_DEBUG_PRINT(F(\"RC5: \"));\n        IR_DEBUG_PRINTLN(F(\"first getBiphaselevel() is not MARK\"));\n        return false;\n    }\n\n    /*\n     * Get data bits - MSB first\n     */\n    for (tBitIndex = 0; sBiphaseDecodeRawbuffOffset < decodedIRData.rawlen; tBitIndex++) {\n        // get next 2 levels and check for transition\n        uint8_t tStartLevel = getBiphaselevel();\n        uint8_t tEndLevel = getBiphaselevel();\n\n        if ((tStartLevel == SPACE) && (tEndLevel == MARK)) {\n            // we have a space to mark transition here\n            tDecodedRawData = (tDecodedRawData << 1) | 1;\n        } else if ((tStartLevel == MARK) && (tEndLevel == SPACE)) {\n            // we have a mark to space transition here\n            tDecodedRawData = (tDecodedRawData << 1) | 0;\n        } else {\n#if defined(LOCAL_DEBUG)\n            Serial.print(F(\"RC5: \"));\n            Serial.println(F(\"no transition found, decode failed\"));\n#endif\n            return false;\n        }\n    }\n\n    // Success\n    decodedIRData.numberOfBits = tBitIndex; // must be RC5_BITS\n\n    LongUnion tValue;\n    tValue.ULong = tDecodedRawData;\n    decodedIRData.decodedRawData = tDecodedRawData;\n    decodedIRData.command = tValue.UByte.LowByte & 0x3F;\n    decodedIRData.address = (tValue.UWord.LowWord >> RC5_COMMAND_BITS) & 0x1F;\n\n    // Get the inverted 7. command bit for RC5X, the inverted value is always 1 for RC5 and serves as a second start bit.\n    if ((tValue.UWord.LowWord & (1 << (RC5_TOGGLE_BIT + RC5_ADDRESS_BITS + RC5_COMMAND_BITS))) == 0) {\n        decodedIRData.command += 0x40;\n    }\n\n    decodedIRData.flags = IRDATA_FLAGS_IS_MSB_FIRST;\n    if (tValue.UByte.MidLowByte & 0x8) {\n        decodedIRData.flags = IRDATA_FLAGS_TOGGLE_BIT | IRDATA_FLAGS_IS_MSB_FIRST;\n    }\n    decodedIRData.protocol = RC5;\n\n    // check for repeat\n    checkForRepeatSpaceTicksAndSetFlag(RC5_MAXIMUM_REPEAT_DISTANCE / MICROS_PER_TICK);\n\n    return true;\n}\n\n//+=============================================================================\n// RRRR    CCCC   6666\n// R   R  C      6\n// RRRR   C      6666\n// R  R   C      6   6\n// R   R   CCCC   666\n//+=============================================================================\n//\n/*\n Protocol=RC6 Address=0xF1 Command=0x76 Raw-Data=0xF176 20 bits MSB first\n +2650,- 850\n + 500,- 850 + 500,- 400 + 450,- 450 + 450,- 850\n +1400,- 400 + 450,- 450 + 450,- 450 + 450,- 900\n + 450,- 450 + 450,- 400 + 950,- 850 + 900,- 450\n + 450,- 450 + 450,- 850 + 950,- 400 + 450,- 900\n + 450\n Sum: 23150\n */\n// Frame RC6:   1 start bit + 1 Bit \"1\" + 3 mode bits (000) + 1 toggle bit + 8 address + 8 command bits + 2666us pause\n// Frame RC6A:  1 start bit + 1 Bit \"1\" + 3 mode bits (110) + 1 toggle bit + \"1\" + 14 customer bits + 8 system bits + 8 command bits (=31bits) + 2666us pause\n// !!! toggle bit has another timing :-( !!!\n// mark->space => 1\n// space->mark => 0\n// https://www.sbprojects.net/knowledge/ir/rc6.php\n// https://www.mikrocontroller.net/articles/IRMP_-_english#RC6_.2B_RC6A\n// https://en.wikipedia.org/wiki/Manchester_code\n#define MIN_RC6_SAMPLES         1\n\n#define RC6_RPT_LENGTH      46000\n\n#define RC6_LEADING_BIT         1\n#define RC6_MODE_BITS           3 // never seen others than all 0 for Philips TV\n#define RC6_TOGGLE_BIT          1 // toggles at every key press. Can be used to distinguish repeats from 2 key presses and has another timing :-(.\n#define RC6_TOGGLE_BIT_INDEX    RC6_MODE_BITS //  fourth position, index = 3\n#define RC6_ADDRESS_BITS        8\n#define RC6_COMMAND_BITS        8\n\n#define RC6_BITS            (RC6_LEADING_BIT + RC6_MODE_BITS + RC6_TOGGLE_BIT + RC6_ADDRESS_BITS + RC6_COMMAND_BITS) // 21\n\n#define RC6_UNIT            444 // 16 periods of 36 kHz (444.4444)\n\n#define RC6_HEADER_MARK     (6 * RC6_UNIT) // 2666\n#define RC6_HEADER_SPACE    (2 * RC6_UNIT) // 889\n\n#define RC6_TRAILING_SPACE  (6 * RC6_UNIT) // 2666\n#define MIN_RC6_MARKS       4 + ((RC6_ADDRESS_BITS + RC6_COMMAND_BITS) / 2) // 12, 4 are for preamble\n\n#define RC6_REPEAT_DISTANCE 107000 // just a guess but > 2.666ms\n#define RC6_MAXIMUM_REPEAT_DISTANCE     (RC6_REPEAT_DISTANCE + (RC6_REPEAT_DISTANCE / 4)) // Just a guess\n\n/**\n * Main RC6 send function\n */\nvoid IRsend::sendRC6(uint32_t aRawData, uint8_t aNumberOfBitsToSend) {\n    sendRC6Raw(aRawData, aNumberOfBitsToSend);\n}\nvoid IRsend::sendRC6Raw(uint32_t aRawData, uint8_t aNumberOfBitsToSend) {\n// Set IR carrier frequency\n    enableIROut (RC5_RC6_KHZ);\n\n// Header\n    mark(RC6_HEADER_MARK);\n    space(RC6_HEADER_SPACE);\n\n// Start bit\n    mark(RC6_UNIT);\n    space(RC6_UNIT);\n\n// Data MSB first\n    uint32_t mask = 1UL << (aNumberOfBitsToSend - 1);\n    for (uint_fast8_t i = 1; mask; i++, mask >>= 1) {\n        // The fourth bit we send is the \"double width toggle bit\"\n        unsigned int t = (i == (RC6_TOGGLE_BIT_INDEX + 1)) ? (RC6_UNIT * 2) : (RC6_UNIT);\n        if (aRawData & mask) {\n            mark(t);\n            space(t);\n        } else {\n            space(t);\n            mark(t);\n        }\n    }\n}\n\n/**\n * Send RC6 64 bit raw data\n * Can be used to send RC6A with ?31? data bits\n */\nvoid IRsend::sendRC6(uint64_t aRawData, uint8_t aNumberOfBitsToSend) {\n    sendRC6Raw(aRawData, aNumberOfBitsToSend);\n}\nvoid IRsend::sendRC6Raw(uint64_t aRawData, uint8_t aNumberOfBitsToSend) {\n// Set IR carrier frequency\n    enableIROut (RC5_RC6_KHZ);\n\n// Header\n    mark(RC6_HEADER_MARK);\n    space(RC6_HEADER_SPACE);\n\n// Start bit\n    mark(RC6_UNIT);\n    space(RC6_UNIT);\n\n// Data MSB first\n    uint64_t mask = 1ULL << (aNumberOfBitsToSend - 1);\n    for (uint_fast8_t i = 1; mask; i++, mask >>= 1) {\n        // The fourth bit we send is the \"double width toggle bit\"\n        unsigned int t = (i == (RC6_TOGGLE_BIT_INDEX + 1)) ? (RC6_UNIT * 2) : (RC6_UNIT);\n        if (aRawData & mask) {\n            mark(t);\n            space(t);\n        } else {\n            space(t);\n            mark(t);\n        }\n    }\n}\n\n/**\n * Assemble raw data for RC6 from parameters and toggle state and send\n * We do not wait for the minimal trailing space of 2666 us\n * @param aEnableAutomaticToggle Send toggle bit according to the state of the static sLastSendToggleValue variable.\n */\nvoid IRsend::sendRC6(uint8_t aAddress, uint8_t aCommand, int_fast8_t aNumberOfRepeats, bool aEnableAutomaticToggle) {\n\n    LongUnion tIRRawData;\n    tIRRawData.UByte.LowByte = aCommand;\n    tIRRawData.UByte.MidLowByte = aAddress;\n\n    tIRRawData.UWord.HighWord = 0; // must clear high word\n    if (aEnableAutomaticToggle) {\n        if (sLastSendToggleValue == 0) {\n            sLastSendToggleValue = 1;\n            // set toggled bit\n            IR_DEBUG_PRINT(F(\"Set Toggle \"));\n            tIRRawData.UByte.MidHighByte = 1; // 3 Mode bits are 0\n        } else {\n            sLastSendToggleValue = 0;\n        }\n    }\n\n#if defined(LOCAL_DEBUG)\n    Serial.print(F(\"RC6: \"));\n    Serial.print(F(\"sLastSendToggleValue=\"));\n    Serial.print (sLastSendToggleValue);\n    Serial.print(F(\" RawData=\"));\n    Serial.println(tIRRawData.ULong, HEX);\n#endif\n\n    uint_fast8_t tNumberOfCommands = aNumberOfRepeats + 1;\n    while (tNumberOfCommands > 0) {\n\n        // start and leading bits are sent by sendRC6\n        sendRC6Raw(tIRRawData.ULong, RC6_BITS - 1); // -1 since the leading bit is additionally sent by sendRC6\n\n        tNumberOfCommands--;\n        // skip last delay!\n        if (tNumberOfCommands > 0) {\n            // send repeated command in a fixed raster\n            delay(RC6_REPEAT_DISTANCE / MICROS_IN_ONE_MILLI);\n        }\n    }\n}\n\n/**\n * Try to decode data as RC6 protocol\n */\nbool IRrecv::decodeRC6() {\n    uint8_t tBitIndex;\n    uint32_t tDecodedRawData = 0;\n\n    // Check we have the right amount of data (). The +3 for initial gap, start bit mark and space\n    if (decodedIRData.rawlen < MIN_RC6_MARKS + 3 && (RC6_BITS + 3) < decodedIRData.rawlen) {\n        IR_DEBUG_PRINT(F(\"RC6: \"));\n        IR_DEBUG_PRINT(F(\"Data length=\"));\n        IR_DEBUG_PRINT(decodedIRData.rawlen);\n        IR_DEBUG_PRINTLN(F(\" is not between 15 and 25\"));\n        return false;\n    }\n\n    // Check header \"mark\" and \"space\", this must be done for repeat and data\n    if (!matchMark(decodedIRData.rawDataPtr->rawbuf[1], RC6_HEADER_MARK)\n            || !matchSpace(decodedIRData.rawDataPtr->rawbuf[2], RC6_HEADER_SPACE)) {\n        // no debug output, since this check is mainly to determine the received protocol\n        IR_DEBUG_PRINT(F(\"RC6: \"));\n        IR_DEBUG_PRINTLN(F(\"Header mark or space length is wrong\"));\n        return false;\n    }\n\n    // Set Biphase decoding start values\n    initBiphaselevel(3, RC6_UNIT); // Skip gap-space and start-bit mark + space\n\n// Process first bit, which is known to be a 1 (mark->space)\n    if (getBiphaselevel() != MARK) {\n        IR_DEBUG_PRINT(F(\"RC6: \"));\n        IR_DEBUG_PRINTLN(F(\"first getBiphaselevel() is not MARK\"));\n        return false;\n    }\n    if (getBiphaselevel() != SPACE) {\n        IR_DEBUG_PRINT(F(\"RC6: \"));\n        IR_DEBUG_PRINTLN(F(\"second getBiphaselevel() is not SPACE\"));\n        return false;\n    }\n\n    for (tBitIndex = 0; sBiphaseDecodeRawbuffOffset < decodedIRData.rawlen; tBitIndex++) {\n        uint8_t tStartLevel; // start level of coded bit\n        uint8_t tEndLevel;   // end level of coded bit\n\n        tStartLevel = getBiphaselevel();\n        if (tBitIndex == RC6_TOGGLE_BIT_INDEX) {\n            // Toggle bit is double wide; make sure second half is equal first half\n            if (tStartLevel != getBiphaselevel()) {\n#if defined(LOCAL_DEBUG)\n                Serial.print(F(\"RC6: \"));\n                Serial.println(F(\"Toggle mark or space length is wrong\"));\n#endif\n                return false;\n            }\n        }\n\n        tEndLevel = getBiphaselevel();\n        if (tBitIndex == RC6_TOGGLE_BIT_INDEX) {\n            // Toggle bit is double wide; make sure second half matches\n            if (tEndLevel != getBiphaselevel()) {\n#if defined(LOCAL_DEBUG)\n                Serial.print(F(\"RC6: \"));\n                Serial.println(F(\"Toggle mark or space length is wrong\"));\n#endif\n                return false;\n            }\n        }\n\n        /*\n         * Determine tDecodedRawData bit value by checking the transition type\n         */\n        if ((tStartLevel == MARK) && (tEndLevel == SPACE)) {\n            // we have a mark to space transition here\n            tDecodedRawData = (tDecodedRawData << 1) | 1;  // inverted compared to RC5\n        } else if ((tStartLevel == SPACE) && (tEndLevel == MARK)) {\n            // we have a space to mark transition here\n            tDecodedRawData = (tDecodedRawData << 1) | 0;\n        } else {\n#if defined(LOCAL_DEBUG)\n            Serial.print(F(\"RC6: \"));\n            Serial.println(F(\"Decode failed\"));\n#endif\n            // we have no transition here or one level is -1 -> error\n            return false;            // Error\n        }\n    }\n\n// Success\n    decodedIRData.numberOfBits = tBitIndex;\n\n    LongUnion tValue;\n    tValue.ULong = tDecodedRawData;\n    decodedIRData.decodedRawData = tDecodedRawData;\n\n    if (tBitIndex < 36) {\n        // RC6 8 address bits, 8 command bits\n        decodedIRData.flags = IRDATA_FLAGS_IS_MSB_FIRST;\n        decodedIRData.command = tValue.UByte.LowByte;\n        decodedIRData.address = tValue.UByte.MidLowByte;\n        // Check for toggle flag\n        if ((tValue.UByte.MidHighByte & 1) != 0) {\n            decodedIRData.flags = IRDATA_FLAGS_TOGGLE_BIT | IRDATA_FLAGS_IS_MSB_FIRST;\n        }\n        if (tBitIndex > 20) {\n            decodedIRData.flags |= IRDATA_FLAGS_EXTRA_INFO;\n        }\n    } else {\n        // RC6A - 32 bits\n        decodedIRData.flags = IRDATA_FLAGS_IS_MSB_FIRST;\n        if ((tValue.UByte.MidLowByte & 0x80) != 0) {\n            decodedIRData.flags = IRDATA_FLAGS_TOGGLE_BIT | IRDATA_FLAGS_IS_MSB_FIRST;\n        }\n        tValue.UByte.MidLowByte &= 0x87F; // mask toggle bit\n        decodedIRData.command = tValue.UByte.LowByte;\n        decodedIRData.address = tValue.UByte.MidLowByte;\n    }\n\n    // check for repeat, do not check toggle bit yet\n    checkForRepeatSpaceTicksAndSetFlag(RC6_MAXIMUM_REPEAT_DISTANCE / MICROS_PER_TICK);\n\n    decodedIRData.protocol = RC6;\n    return true;\n}\n\n/*********************************************************************************\n * Old deprecated functions, kept for backward compatibility to old 2.0 tutorials\n *********************************************************************************/\n\n/**\n * Old version with 32 bit data\n */\nvoid IRsend::sendRC5(uint32_t data, uint8_t nbits) {\n    // Set IR carrier frequency\n    enableIROut (RC5_RC6_KHZ);\n\n    // Start\n    mark(RC5_UNIT);\n    space(RC5_UNIT);\n    mark(RC5_UNIT);\n\n    // Data - Biphase code MSB first\n    for (uint32_t mask = 1UL << (nbits - 1); mask; mask >>= 1) {\n        if (data & mask) {\n            space(RC5_UNIT); // 1 is space, then mark\n            mark(RC5_UNIT);\n        } else {\n            mark(RC5_UNIT);\n            space(RC5_UNIT);\n        }\n    }\n}\n\n/*\n * Not longer required, use sendRC5(uint8_t aAddress, uint8_t aCommand, int_fast8_t aNumberOfRepeats, bool aEnableAutomaticToggle) instead\n */\nvoid IRsend::sendRC5ext(uint8_t addr, uint8_t cmd, bool toggle) {\n// Set IR carrier frequency\n    enableIROut (RC5_RC6_KHZ);\n\n    uint8_t addressBits = 5;\n    uint8_t commandBits = 7;\n//    unsigned long nbits = addressBits + commandBits;\n\n// Start\n    mark(RC5_UNIT);\n\n// Bit #6 of the command part, but inverted!\n    uint8_t cmdBit6 = (1UL << (commandBits - 1)) & cmd;\n    if (cmdBit6) {\n        // Inverted (1 -> 0 = mark-to-space)\n        mark(RC5_UNIT);\n        space(RC5_UNIT);\n    } else {\n        space(RC5_UNIT);\n        mark(RC5_UNIT);\n    }\n    commandBits--;\n\n// Toggle bit\n    static int toggleBit = 1;\n    if (toggle) {\n        if (toggleBit == 0) {\n            toggleBit = 1;\n        } else {\n            toggleBit = 0;\n        }\n    }\n    if (toggleBit) {\n        space(RC5_UNIT);\n        mark(RC5_UNIT);\n    } else {\n        mark(RC5_UNIT);\n        space(RC5_UNIT);\n    }\n\n// Address\n    for (uint_fast8_t mask = 1UL << (addressBits - 1); mask; mask >>= 1) {\n        if (addr & mask) {\n            space(RC5_UNIT); // 1 is space, then mark\n            mark(RC5_UNIT);\n        } else {\n            mark(RC5_UNIT);\n            space(RC5_UNIT);\n        }\n    }\n\n// Command\n    for (uint_fast8_t mask = 1UL << (commandBits - 1); mask; mask >>= 1) {\n        if (cmd & mask) {\n            space(RC5_UNIT); // 1 is space, then mark\n            mark(RC5_UNIT);\n        } else {\n            mark(RC5_UNIT);\n            space(RC5_UNIT);\n        }\n    }\n}\n\n/** @}*/\n#if defined(LOCAL_DEBUG)\n#undef LOCAL_DEBUG\n#endif\n#endif // _IR_RC5_RC6_HPP\n"
    }, {
      filename: "src/IRremoteInt.h",
      code: "/**\n * @file IRremoteInt.h\n * @brief Contains all declarations required for the interface to IRremote.\n * Could not be named IRremote.h, since this has another semantic (it must include all *.hpp files) for old example code found in the wild.\n *\n * This file is part of Arduino-IRremote https://github.com/Arduino-IRremote/Arduino-IRremote.\n *\n *\n ************************************************************************************\n * MIT License\n *\n * Copyright (c) 2015-2023 Ken Shirriff http://www.righto.com, Rafi Khan, Armin Joachimsmeyer\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is furnished\n * to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n ************************************************************************************\n */\n#ifndef _IR_REMOTE_INT_H\n#define _IR_REMOTE_INT_H\n\n#include <Arduino.h>\n\n#define MARK   1\n#define SPACE  0\n\n#if defined(PARTICLE)\n#define F_CPU 16000000 // definition for a board for which F_CPU is not defined\n#endif\n#if defined(F_CPU) // F_CPU is used to generate the receive send timings in some CPU's\n#define CLOCKS_PER_MICRO (F_CPU / MICROS_IN_ONE_SECOND)\n#endif\n\n/*\n * For backwards compatibility\n */\n#if defined(SYSCLOCK) // allow for processor specific code to define F_CPU\n#undef F_CPU\n#define F_CPU SYSCLOCK // Clock frequency to be used for timing.\n#endif\n\n//#define DEBUG // Activate this for lots of lovely debug output from the IRremote core and all protocol decoders.\n//#define TRACE // Activate this for more debug output.\n\n/**\n * For better readability of code\n */\n#define DISABLE_LED_FEEDBACK            false\n#define ENABLE_LED_FEEDBACK             true\n#define USE_DEFAULT_FEEDBACK_LED_PIN    0\n\n/**\n * The length of the buffer where the IR timing data is stored before decoding\n * 100 is sufficient for most standard protocols, but air conditioners often send a longer protocol data stream\n */\n#if !defined(RAW_BUFFER_LENGTH)\n#  if defined(DECODE_MAGIQUEST)\n#define RAW_BUFFER_LENGTH  112  // MagiQuest requires 112 bytes.\n#  else\n#define RAW_BUFFER_LENGTH  100  ///< Length of raw duration buffer. Must be even. 100 supports up to 48 bit codings inclusive 1 start and 1 stop bit.\n//#define RAW_BUFFER_LENGTH  750  // 750 (600 if we have only 2k RAM) is the value for air condition remotes.\n#  endif\n#endif\n#if RAW_BUFFER_LENGTH % 2 == 1\n#error RAW_BUFFER_LENGTH must be even, since the array consists of space / mark pairs.\n#endif\n\n#if RAW_BUFFER_LENGTH <= 254    // saves around 75 bytes program memory and speeds up ISR\ntypedef uint_fast8_t IRRawlenType;\n#else\ntypedef unsigned int IRRawlenType;\n#endif\n/****************************************************\n * Declarations for the receiver Interrupt Service Routine\n ****************************************************/\n// ISR State-Machine : Receiver States\n#define IR_REC_STATE_IDLE      0 // Counting the gap time and waiting for the start bit to arrive\n#define IR_REC_STATE_MARK      1 // A mark was received and we are counting the duration of it.\n#define IR_REC_STATE_SPACE     2 // A space was received and we are counting the duration of it. If space is too long, we assume end of frame.\n#define IR_REC_STATE_STOP      3 // Stopped until set to IR_REC_STATE_IDLE which can only be done by resume()\n\n/**\n * This struct contains the data and control used for receiver static functions and the ISR (interrupt service routine)\n * Only StateForISR needs to be volatile. All the other fields are not written by ISR after data available and before start/resume.\n */\nstruct irparams_struct {\n    // The fields are ordered to reduce memory over caused by struct-padding\n    volatile uint8_t StateForISR;       ///< State Machine state\n    uint_fast8_t IRReceivePin;          ///< Pin connected to IR data from detector\n#if defined(__AVR__)\n    volatile uint8_t *IRReceivePinPortInputRegister;\n    uint8_t IRReceivePinMask;\n#endif\n    volatile uint_fast16_t TickCounterForISR; ///< Counts 50uS ticks. The value is copied into the rawbuf array on every transition. Counting is independent of state or resume().\n#if !IR_REMOTE_DISABLE_RECEIVE_COMPLETE_CALLBACK\n    void (*ReceiveCompleteCallbackFunction)(void); ///< The function to call if a protocol message has arrived, i.e. StateForISR changed to IR_REC_STATE_STOP\n#endif\n    bool OverflowFlag;                  ///< Raw buffer OverflowFlag occurred\n    IRRawlenType rawlen;               ///< counter of entries in rawbuf\n    uint16_t rawbuf[RAW_BUFFER_LENGTH]; ///< raw data / tick counts per mark/space, first entry is the length of the gap between previous and current command\n};\n\n#if (__INT_WIDTH__ < 32)\ntypedef uint32_t IRRawDataType;\n#define BITS_IN_RAW_DATA_TYPE   32\n#else\ntypedef uint64_t IRRawDataType;\n#define BITS_IN_RAW_DATA_TYPE   64\n#endif\n#include \"IRProtocol.h\"\n\n/*\n * Debug directives\n * Outputs with IR_DEBUG_PRINT can only be activated by defining DEBUG!\n * If LOCAL_DEBUG is defined in one file, all outputs with IR_DEBUG_PRINT are still suppressed.\n */\n#if defined(DEBUG) || defined(TRACE)\n#  define IR_DEBUG_PRINT(...)    Serial.print(__VA_ARGS__)\n#  define IR_DEBUG_PRINTLN(...)  Serial.println(__VA_ARGS__)\n#else\n/**\n * If DEBUG, print the arguments, otherwise do nothing.\n */\n#  define IR_DEBUG_PRINT(...) void()\n/**\n * If DEBUG, print the arguments as a line, otherwise do nothing.\n */\n#  define IR_DEBUG_PRINTLN(...) void()\n#endif\n\n#if defined(TRACE)\n#  define IR_TRACE_PRINT(...)    Serial.print(__VA_ARGS__)\n#  define IR_TRACE_PRINTLN(...)  Serial.println(__VA_ARGS__)\n#else\n#  define IR_TRACE_PRINT(...) void()\n#  define IR_TRACE_PRINTLN(...) void()\n#endif\n\n/****************************************************\n *                     RECEIVING\n ****************************************************/\n\n/**\n * Results returned from old decoders !!!deprecated!!!\n */\nstruct decode_results {\n    decode_type_t decode_type;  // deprecated, moved to decodedIRData.protocol ///< UNKNOWN, NEC, SONY, RC5, ...\n    uint16_t address;           // Used by Panasonic & Sharp [16-bits]\n    uint32_t value;             // deprecated, moved to decodedIRData.decodedRawData ///< Decoded value / command [max 32-bits]\n    uint8_t bits;               // deprecated, moved to decodedIRData.numberOfBits ///< Number of bits in decoded value\n    uint16_t magnitude;         // deprecated, moved to decodedIRData.extra ///< Used by MagiQuest [16-bits]\n    bool isRepeat;              // deprecated, moved to decodedIRData.flags ///< True if repeat of value is detected\n\n// next 3 values are copies of irparams_struct values - see above\n    uint16_t *rawbuf;       // deprecated, moved to decodedIRData.rawDataPtr->rawbuf ///< Raw intervals in 50uS ticks\n    uint_fast8_t rawlen;        // deprecated, moved to decodedIRData.rawDataPtr->rawlen ///< Number of records in rawbuf\n    bool overflow;              // deprecated, moved to decodedIRData.flags ///< true if IR raw code too long\n};\n\n/**\n * Main class for receiving IR signals\n */\nclass IRrecv {\npublic:\n\n    IRrecv();\n    IRrecv(uint_fast8_t aReceivePin);\n    IRrecv(uint_fast8_t aReceivePin, uint_fast8_t aFeedbackLEDPin);\n    void setReceivePin(uint_fast8_t aReceivePinNumber);\n    void registerReceiveCompleteCallback(void (*aReceiveCompleteCallbackFunction)(void));\n    /*\n     * Stream like API\n     */\n    void begin(uint_fast8_t aReceivePin, bool aEnableLEDFeedback = false, uint_fast8_t aFeedbackLEDPin =\n    USE_DEFAULT_FEEDBACK_LED_PIN);\n    void restartTimer();\n    void start();\n    void enableIRIn(); // alias for start\n    void start(uint32_t aMicrosecondsToAddToGapCounter);\n    void restartTimer(uint32_t aMicrosecondsToAddToGapCounter);\n    void startWithTicksToAdd(uint16_t aTicksToAddToGapCounter);\n    void restartTimerWithTicksToAdd(uint16_t aTicksToAddToGapCounter);\n    void restartAfterSend();\n\n    void addTicksToInternalTickCounter(uint16_t aTicksToAddToInternalTickCounter);\n    void addMicrosToInternalTickCounter(uint16_t aMicrosecondsToAddToInternalTickCounter);\n\n    bool available();\n    IRData* read(); // returns decoded data\n    // write is a method of class IRsend below\n    // size_t write(IRData *aIRSendData, int_fast8_t aNumberOfRepeats = NO_REPEATS);\n    void stopTimer();\n    void stop();\n    void disableIRIn(); // alias for stop\n    void end(); // alias for stop\n\n    bool isIdle();\n\n    /*\n     * The main functions\n     */\n    bool decode();  // Check if available and try to decode\n    void resume();  // Enable receiving of the next value\n\n    /*\n     * Useful info and print functions\n     */\n    void printIRResultMinimal(Print *aSerial);\n    void printIRResultRawFormatted(Print *aSerial, bool aOutputMicrosecondsInsteadOfTicks = true);\n    void printIRResultAsCVariables(Print *aSerial);\n    uint32_t getTotalDurationOfRawData();\n\n    /*\n     * Next 4 functions are also available as non member functions\n     */\n    bool printIRResultShort(Print *aSerial, bool aPrintRepeatGap = true, bool aCheckForRecordGapsMicros = true);\n    void printDistanceWidthTimingInfo(Print *aSerial, DistanceWidthTimingInfoStruct *aDistanceWidthTimingInfo);\n    void printIRSendUsage(Print *aSerial);\n#if defined(__AVR__)\n    const __FlashStringHelper* getProtocolString();\n#else\n    const char* getProtocolString();\n#endif\n    static void printActiveIRProtocols(Print *aSerial);\n\n    void compensateAndPrintIRResultAsCArray(Print *aSerial, bool aOutputMicrosecondsInsteadOfTicks = true);\n    void compensateAndPrintIRResultAsPronto(Print *aSerial, uint16_t frequency = 38000U);\n\n    /*\n     * Store the data for further processing\n     */\n    void compensateAndStoreIRResultInArray(uint8_t *aArrayPtr);\n    size_t compensateAndStorePronto(String *aString, uint16_t frequency = 38000U);\n\n    /*\n     * The main decoding functions used by the individual decoders\n     */\n    bool decodePulseDistanceWidthData(PulseDistanceWidthProtocolConstants *aProtocolConstants, uint_fast8_t aNumberOfBits,\n            IRRawlenType aStartOffset = 3);\n\n    bool decodePulseDistanceWidthData(uint_fast8_t aNumberOfBits, IRRawlenType aStartOffset, uint16_t aOneMarkMicros,\n            uint16_t aZeroMarkMicros, uint16_t aOneSpaceMicros, uint16_t aZeroSpaceMicros, bool aMSBfirst);\n\n    bool decodeBiPhaseData(uint_fast8_t aNumberOfBits, IRRawlenType aStartOffset, uint_fast8_t aStartClockCount,\n            uint_fast8_t aValueOfSpaceToMarkTransition, uint16_t aBiphaseTimeUnit);\n\n    void initBiphaselevel(uint_fast8_t aRCDecodeRawbuffOffset, uint16_t aBiphaseTimeUnit);\n    uint_fast8_t getBiphaselevel();\n\n    /*\n     * All standard (decode address + command) protocol decoders\n     */\n    bool decodeBangOlufsen();\n    bool decodeBoseWave();\n    bool decodeDenon();\n    bool decodeFAST();\n    bool decodeJVC();\n    bool decodeKaseikyo();\n    bool decodeLegoPowerFunctions();\n    bool decodeLG();\n    bool decodeMagiQuest(); // not completely standard\n    bool decodeNEC();\n    bool decodeRC5();\n    bool decodeRC6();\n    bool decodeSamsung();\n    bool decodeSharp(); // redirected to decodeDenon()\n    bool decodeSony();\n    bool decodeWhynter();\n\n    bool decodeDistanceWidth();\n\n    bool decodeHash();\n\n    // Template function :-)\n    bool decodeShuzu();\n\n    /*\n     * Old functions\n     */\n    bool decodeDenonOld(decode_results *aResults);\n    bool decodeJVCMSB(decode_results *aResults);\n    bool decodeLGMSB(decode_results *aResults);\n    bool decodeNECMSB(decode_results *aResults);\n    bool decodePanasonicMSB(decode_results *aResults);\n    bool decodeSonyMSB(decode_results *aResults);\n    bool decodeSAMSUNG(decode_results *aResults);\n    bool decodeHashOld(decode_results *aResults);\n\n    bool decode_old(decode_results *aResults);\n\n    bool decode(\n            decode_results *aResults)\n                    __attribute__ ((deprecated (\"Please use IrReceiver.decode() without a parameter and IrReceiver.decodedIRData.<fieldname> .\")));\n\n    // for backward compatibility. Now in IRFeedbackLED.hpp\n    void blink13(uint8_t aEnableLEDFeedback)\n            __attribute__ ((deprecated (\"Please use setLEDFeedback() or enableLEDFeedback() / disableLEDFeedback().\")));\n\n    /*\n     * Internal functions\n     */\n    void initDecodedIRData();\n    uint_fast8_t compare(uint16_t oldval, uint16_t newval);\n    bool checkHeader(PulseDistanceWidthProtocolConstants *aProtocolConstants);\n    void checkForRepeatSpaceTicksAndSetFlag(uint16_t aMaximumRepeatSpaceTicks);\n    bool checkForRecordGapsMicros(Print *aSerial);\n\n    IRData decodedIRData;       // Decoded IR data for the application\n\n    // Last decoded IR data for repeat detection and parity for Denon autorepeat\n    decode_type_t lastDecodedProtocol;\n    uint32_t lastDecodedAddress;\n    uint32_t lastDecodedCommand;\n\n    uint8_t repeatCount;        // Used e.g. for Denon decode for autorepeat decoding.\n};\n\nextern uint_fast8_t sBiphaseDecodeRawbuffOffset; //\n\n/*\n * Mark & Space matching functions\n */\nbool matchTicks(uint16_t aMeasuredTicks, uint16_t aMatchValueMicros);\nbool matchMark(uint16_t aMeasuredTicks, uint16_t aMatchValueMicros);\nbool matchSpace(uint16_t aMeasuredTicks, uint16_t aMatchValueMicros);\n\n/*\n * Old function names\n */\nbool MATCH(uint16_t measured, uint16_t desired);\nbool MATCH_MARK(uint16_t measured_ticks, uint16_t desired_us);\nbool MATCH_SPACE(uint16_t measured_ticks, uint16_t desired_us);\n\nint getMarkExcessMicros();\n\nvoid printActiveIRProtocols(Print *aSerial);\n\n/****************************************************\n * Feedback LED related functions\n ****************************************************/\n#define DO_NOT_ENABLE_LED_FEEDBACK          0x00\n#define LED_FEEDBACK_DISABLED_COMPLETELY    0x00\n#define LED_FEEDBACK_ENABLED_FOR_RECEIVE    0x01\n#define LED_FEEDBACK_ENABLED_FOR_SEND       0x02\nvoid setFeedbackLED(bool aSwitchLedOn);\nvoid setLEDFeedback(uint8_t aFeedbackLEDPin, uint8_t aEnableLEDFeedback); // if aFeedbackLEDPin == 0, then take board BLINKLED_ON() and BLINKLED_OFF() functions\nvoid setLEDFeedback(bool aEnableLEDFeedback); // Direct replacement for blink13()\nvoid enableLEDFeedback();\nconstexpr auto enableLEDFeedbackForReceive = enableLEDFeedback; // alias for enableLEDFeedback\nvoid disableLEDFeedback();\nconstexpr auto disableLEDFeedbackForReceive = disableLEDFeedback; // alias for enableLEDFeedback\nvoid enableLEDFeedbackForSend();\nvoid disableLEDFeedbackForSend();\n\nvoid setBlinkPin(uint8_t aFeedbackLEDPin) __attribute__ ((deprecated (\"Please use setLEDFeedback().\"))); // deprecated\n\n/*\n * Pulse parms are ((X*50)-MARK_EXCESS_MICROS) for the Mark and ((X*50)+MARK_EXCESS_MICROS) for the Space.\n * First MARK is the one after the long gap\n * Pulse parameters in microseconds\n */\n#if !defined(TOLERANCE_FOR_DECODERS_MARK_OR_SPACE_MATCHING)\n#define TOLERANCE_FOR_DECODERS_MARK_OR_SPACE_MATCHING    25 // Relative tolerance (in percent) for matchTicks(), matchMark() and matchSpace() functions used for protocol decoding.\n#endif\n\n/** Lower tolerance for comparison of measured data */\n//#define LTOL            (1.0 - (TOLERANCE/100.))\n#define LTOL            (100 - TOLERANCE_FOR_DECODERS_MARK_OR_SPACE_MATCHING)\n/** Upper tolerance for comparison of measured data */\n//#define UTOL            (1.0 + (TOLERANCE/100.))\n#define UTOL            (100 + TOLERANCE_FOR_DECODERS_MARK_OR_SPACE_MATCHING)\n\n//#define TICKS_LOW(us)   ((int)(((us)*LTOL/MICROS_PER_TICK)))\n//#define TICKS_HIGH(us)  ((int)(((us)*UTOL/MICROS_PER_TICK + 1)))\n#if MICROS_PER_TICK == 50 && TOLERANCE_FOR_DECODERS_MARK_OR_SPACE_MATCHING == 25           // Defaults\n#define TICKS_LOW(us)   ((us)/67 )     // (us) / ((MICROS_PER_TICK:50 / LTOL:75 ) * 100)\n#define TICKS_HIGH(us)  (((us)/40) + 1)  // (us) / ((MICROS_PER_TICK:50 / UTOL:125) * 100) + 1\n#else\n#define TICKS_LOW(us)   ((uint16_t ) ((long) (us) * LTOL / (MICROS_PER_TICK * 100) ))\n#define TICKS_HIGH(us)  ((uint16_t ) ((long) (us) * UTOL / (MICROS_PER_TICK * 100) + 1))\n#endif\n\n/*\n * The receiver instance\n */\nextern IRrecv IrReceiver;\n\n/*\n * The receiver interrupt handler for timer interrupt\n */\nvoid IRReceiveTimerInterruptHandler();\n\n/****************************************************\n *                     SENDING\n ****************************************************/\n\n/**\n * Just for better readability of code\n */\n#define NO_REPEATS  0\n#define SEND_REPEAT_COMMAND true ///< used for e.g. NEC, where a repeat is different from just repeating the data.\n\n/**\n * Main class for sending IR signals\n */\nclass IRsend {\npublic:\n    IRsend();\n\n    /*\n     * IR_SEND_PIN is defined or fixed by timer, value of IR_SEND_PIN is then \"DeterminedByTimer\"\n     */\n#if defined(IR_SEND_PIN)\n    void begin();\n    // The default parameter allowed to specify IrSender.begin(7); without errors, if IR_SEND_PIN was defined. But the semantics is not the one the user expect.\n    void begin(bool aEnableLEDFeedback, uint_fast8_t aFeedbackLEDPin); // 4.3.1 Removed default value USE_DEFAULT_FEEDBACK_LED_PIN for last parameter\n    // The next function is a dummy to avoid acceptance of pre 4.3 calls to begin(DISABLE_LED_FEEDBACK);\n    void begin(uint8_t aSendPin)\n#  if !defined (DOXYGEN)\n            __attribute__ ((deprecated (\"Error: IR_SEND_PIN is still defined, therefore the function begin(aSendPin) is NOT available. You must disable '#define IR_SEND_PIN' to enable this function.\")));\n#  endif\n\n    // The next function is a dummy to avoid acceptance of pre 4.0 calls to begin(IR_SEND_PIN, DISABLE_LED_FEEDBACK);\n    void begin(uint_fast8_t aSendPin, bool aEnableLEDFeedback)\n#  if !defined (DOXYGEN)\n            __attribute__ ((deprecated (\"You must use begin() and enableLEDFeedback() or disableLEDFeedback() since version 4.3.\")));\n#  endif\n#else\n    IRsend(uint_fast8_t aSendPin);\n    void begin(uint_fast8_t aSendPin);\n    void setSendPin(uint_fast8_t aSendPin); // required if we use IRsend() as constructor\n    // Since 4.0 guarded and without default parameter\n    void begin(uint_fast8_t aSendPin, bool aEnableLEDFeedback, uint_fast8_t aFeedbackLEDPin); // aFeedbackLEDPin can be USE_DEFAULT_FEEDBACK_LED_PIN\n#endif\n\n    size_t write(IRData *aIRSendData, int_fast8_t aNumberOfRepeats = NO_REPEATS);\n    size_t write(decode_type_t aProtocol, uint16_t aAddress, uint16_t aCommand, int_fast8_t aNumberOfRepeats = NO_REPEATS);\n\n    void enableIROut(uint_fast8_t aFrequencyKHz);\n#if defined(SEND_PWM_BY_TIMER)\n    void enableHighFrequencyIROut(uint_fast16_t aFrequencyKHz); // Used for Bang&Olufsen\n#endif\n\n    void sendPulseDistanceWidthFromArray(uint_fast8_t aFrequencyKHz, uint16_t aHeaderMarkMicros, uint16_t aHeaderSpaceMicros,\n            uint16_t aOneMarkMicros, uint16_t aOneSpaceMicros, uint16_t aZeroMarkMicros, uint16_t aZeroSpaceMicros,\n            IRRawDataType *aDecodedRawDataArray, uint16_t aNumberOfBits, uint8_t aFlags, uint16_t aRepeatPeriodMillis,\n            int_fast8_t aNumberOfRepeats);\n    void sendPulseDistanceWidthFromArray(PulseDistanceWidthProtocolConstants *aProtocolConstants,\n            IRRawDataType *aDecodedRawDataArray, uint16_t aNumberOfBits, int_fast8_t aNumberOfRepeats);\n    void sendPulseDistanceWidthFromArray(uint_fast8_t aFrequencyKHz, DistanceWidthTimingInfoStruct *aDistanceWidthTimingInfo,\n            IRRawDataType *aDecodedRawDataArray, uint16_t aNumberOfBits, uint8_t aFlags, uint16_t aRepeatPeriodMillis,\n            int_fast8_t aNumberOfRepeats);\n\n    void sendPulseDistanceWidth(PulseDistanceWidthProtocolConstants *aProtocolConstants, IRRawDataType aData,\n            uint_fast8_t aNumberOfBits, int_fast8_t aNumberOfRepeats);\n    void sendPulseDistanceWidthData(PulseDistanceWidthProtocolConstants *aProtocolConstants, IRRawDataType aData,\n            uint_fast8_t aNumberOfBits);\n    void sendPulseDistanceWidth(uint_fast8_t aFrequencyKHz, uint16_t aHeaderMarkMicros, uint16_t aHeaderSpaceMicros,\n            uint16_t aOneMarkMicros, uint16_t aOneSpaceMicros, uint16_t aZeroMarkMicros, uint16_t aZeroSpaceMicros,\n            IRRawDataType aData, uint_fast8_t aNumberOfBits, uint8_t aFlags, uint16_t aRepeatPeriodMillis,\n            int_fast8_t aNumberOfRepeats, void (*aSpecialSendRepeatFunction)() = NULL);\n    void sendPulseDistanceWidth(uint_fast8_t aFrequencyKHz, uint16_t aHeaderMarkMicros, uint16_t aHeaderSpaceMicros,\n            uint16_t aOneMarkMicros, uint16_t aOneSpaceMicros, uint16_t aZeroMarkMicros, uint16_t aZeroSpaceMicros,\n            IRRawDataType aData, uint_fast8_t aNumberOfBits, bool aMSBFirst, bool aSendStopBit, uint16_t aRepeatPeriodMillis,\n            int_fast8_t aNumberOfRepeats, void (*aSpecialSendRepeatFunction)() = NULL)\n                    __attribute__ ((deprecated (\"Since version 4.1.0 parameter aSendStopBit is not longer required.\")));\n    void sendPulseDistanceWidthData(uint16_t aOneMarkMicros, uint16_t aOneSpaceMicros, uint16_t aZeroMarkMicros,\n            uint16_t aZeroSpaceMicros, IRRawDataType aData, uint_fast8_t aNumberOfBits, uint8_t aFlags);\n    void sendBiphaseData(uint16_t aBiphaseTimeUnit, uint32_t aData, uint_fast8_t aNumberOfBits);\n\n    void mark(uint16_t aMarkMicros);\n    static void space(uint16_t aSpaceMicros);\n    void IRLedOff();\n\n// 8 Bit array\n    void sendRaw(const uint8_t aBufferWithTicks[], uint_fast16_t aLengthOfBuffer, uint_fast8_t aIRFrequencyKilohertz);\n    void sendRaw_P(const uint8_t aBufferWithTicks[], uint_fast16_t aLengthOfBuffer, uint_fast8_t aIRFrequencyKilohertz);\n\n// 16 Bit array\n    void sendRaw(const uint16_t aBufferWithMicroseconds[], uint_fast16_t aLengthOfBuffer, uint_fast8_t aIRFrequencyKilohertz);\n    void sendRaw_P(const uint16_t aBufferWithMicroseconds[], uint_fast16_t aLengthOfBuffer, uint_fast8_t aIRFrequencyKilohertz);\n\n    /*\n     * New send functions\n     */\n    void sendBangOlufsen(uint16_t aHeader, uint8_t aData, int_fast8_t aNumberOfRepeats = NO_REPEATS,\n            int8_t aNumberOfHeaderBits = 8);\n    void sendBangOlufsenDataLink(uint32_t aHeader, uint8_t aData, int_fast8_t aNumberOfRepeats = NO_REPEATS,\n            int8_t aNumberOfHeaderBits = 8);\n    void sendBangOlufsenRaw(uint32_t aRawData, int_fast8_t aBits, bool aBackToBack = false);\n    void sendBangOlufsenRawDataLink(uint64_t aRawData, int_fast8_t aBits, bool aBackToBack = false,\n            bool aUseDatalinkTiming = false);\n    void sendBoseWave(uint8_t aCommand, int_fast8_t aNumberOfRepeats = NO_REPEATS);\n    void sendDenon(uint8_t aAddress, uint8_t aCommand, int_fast8_t aNumberOfRepeats, bool aSendSharp = false);\n    void sendDenonRaw(uint16_t aRawData, int_fast8_t aNumberOfRepeats = NO_REPEATS)\n#if !defined (DOXYGEN)\n            __attribute__ ((deprecated (\"Please use sendDenon(aAddress, aCommand, aNumberOfRepeats).\")));\n#endif\n    void sendFAST(uint8_t aCommand, int_fast8_t aNumberOfRepeats);\n    void sendJVC(uint8_t aAddress, uint8_t aCommand, int_fast8_t aNumberOfRepeats);\n\n    void sendLG2Repeat();\n    uint32_t computeLGRawDataAndChecksum(uint8_t aAddress, uint16_t aCommand);\n    void sendLG(uint8_t aAddress, uint16_t aCommand, int_fast8_t aNumberOfRepeats);\n    void sendLG2(uint8_t aAddress, uint16_t aCommand, int_fast8_t aNumberOfRepeats);\n    void sendLGRaw(uint32_t aRawData, int_fast8_t aNumberOfRepeats = NO_REPEATS);\n\n    void sendNECRepeat();\n    uint32_t computeNECRawDataAndChecksum(uint16_t aAddress, uint16_t aCommand);\n    void sendNEC(uint16_t aAddress, uint8_t aCommand, int_fast8_t aNumberOfRepeats);\n    void sendNEC2(uint16_t aAddress, uint8_t aCommand, int_fast8_t aNumberOfRepeats);\n    void sendNECRaw(uint32_t aRawData, int_fast8_t aNumberOfRepeats = NO_REPEATS);\n    // NEC variants\n    void sendOnkyo(uint16_t aAddress, uint16_t aCommand, int_fast8_t aNumberOfRepeats);\n    void sendApple(uint8_t aAddress, uint8_t aCommand, int_fast8_t aNumberOfRepeats);\n\n    void sendKaseikyo(uint16_t aAddress, uint8_t aData, int_fast8_t aNumberOfRepeats, uint16_t aVendorCode); // LSB first\n    void sendPanasonic(uint16_t aAddress, uint8_t aData, int_fast8_t aNumberOfRepeats); // LSB first\n    void sendKaseikyo_Denon(uint16_t aAddress, uint8_t aData, int_fast8_t aNumberOfRepeats); // LSB first\n    void sendKaseikyo_Mitsubishi(uint16_t aAddress, uint8_t aData, int_fast8_t aNumberOfRepeats); // LSB first\n    void sendKaseikyo_Sharp(uint16_t aAddress, uint8_t aData, int_fast8_t aNumberOfRepeats); // LSB first\n    void sendKaseikyo_JVC(uint16_t aAddress, uint8_t aData, int_fast8_t aNumberOfRepeats); // LSB first\n\n    void sendRC5(uint8_t aAddress, uint8_t aCommand, int_fast8_t aNumberOfRepeats, bool aEnableAutomaticToggle = true);\n    void sendRC6(uint8_t aAddress, uint8_t aCommand, int_fast8_t aNumberOfRepeats, bool aEnableAutomaticToggle = true);\n    void sendSamsungLGRepeat();\n    void sendSamsung(uint16_t aAddress, uint16_t aCommand, int_fast8_t aNumberOfRepeats);\n    void sendSamsung16BitAddressAndCommand(uint16_t aAddress, uint16_t aCommand, int_fast8_t aNumberOfRepeats);\n    void sendSamsung48(uint16_t aAddress, uint32_t aCommand, int_fast8_t aNumberOfRepeats);\n    void sendSamsungLG(uint16_t aAddress, uint16_t aCommand, int_fast8_t aNumberOfRepeats);\n    void sendSharp(uint8_t aAddress, uint8_t aCommand, int_fast8_t aNumberOfRepeats); // redirected to sendDenon\n    void sendSony(uint16_t aAddress, uint8_t aCommand, int_fast8_t aNumberOfRepeats, uint8_t numberOfBits = 12); // SIRCS_12_PROTOCOL\n\n    void sendLegoPowerFunctions(uint8_t aChannel, uint8_t tCommand, uint8_t aMode, bool aDoSend5Times = true);\n    void sendLegoPowerFunctions(uint16_t aRawData, bool aDoSend5Times = true);\n    void sendLegoPowerFunctions(uint16_t aRawData, uint8_t aChannel, bool aDoSend5Times = true);\n\n    void sendMagiQuest(uint32_t aWandId, uint16_t aMagnitude);\n\n    void sendPronto(const __FlashStringHelper *str, int_fast8_t aNumberOfRepeats = NO_REPEATS);\n    void sendPronto(const char *prontoHexString, int_fast8_t aNumberOfRepeats = NO_REPEATS);\n    void sendPronto(const uint16_t *data, uint16_t length, int_fast8_t aNumberOfRepeats = NO_REPEATS);\n\n#if defined(__AVR__)\n    void sendPronto_PF(uint_farptr_t str, int_fast8_t aNumberOfRepeats = NO_REPEATS);\n    void sendPronto_P(const char *str, int_fast8_t aNumberOfRepeats);\n#endif\n\n// Template protocol :-)\n    void sendShuzu(uint16_t aAddress, uint8_t aCommand, int_fast8_t aNumberOfRepeats);\n\n    /*\n     * OLD send functions\n     */\n    void sendDenon(unsigned long data,\n            int nbits)\n                    __attribute__ ((deprecated (\"The function sendDenon(data, nbits) is deprecated and may not work as expected! Use sendDenonRaw(data, NumberOfRepeats) or better sendDenon(Address, Command, NumberOfRepeats).\")));\n    void sendDish(uint16_t aData);\n    void sendJVC(unsigned long data, int nbits,\n            bool repeat)\n                    __attribute__ ((deprecated (\"This old function sends MSB first! Please use sendJVC(aAddress, aCommand, aNumberOfRepeats).\"))) {\n        sendJVCMSB(data, nbits, repeat);\n    }\n    void sendJVCMSB(unsigned long data, int nbits, bool repeat = false);\n\n    void sendLG(unsigned long data,\n            int nbits)\n                    __attribute__ ((deprecated (\"The function sendLG(data, nbits) is deprecated and may not work as expected! Use sendLGRaw(data, NumberOfRepeats) or better sendLG(Address, Command, NumberOfRepeats).\")));\n\n    void sendNEC(uint32_t aRawData,\n            uint8_t nbits)\n                    __attribute__ ((deprecated (\"This old function sends MSB first! Please use sendNECMSB() or sendNEC(aAddress, aCommand, aNumberOfRepeats).\"))) {\n        sendNECMSB(aRawData, nbits);\n    }\n    void sendNECMSB(uint32_t data, uint8_t nbits, bool repeat = false);\n    void sendRC5(uint32_t data, uint8_t nbits);\n    void sendRC5ext(uint8_t addr, uint8_t cmd, bool toggle);\n    void sendRC6Raw(uint32_t data, uint8_t nbits);\n    void sendRC6(uint32_t data, uint8_t nbits) __attribute__ ((deprecated (\"Please use sendRC6Raw().\")));\n    void sendRC6Raw(uint64_t data, uint8_t nbits);\n    void sendRC6(uint64_t data, uint8_t nbits) __attribute__ ((deprecated (\"Please use sendRC6Raw().\")));\n    ;\n    void sendSharpRaw(unsigned long data, int nbits);\n    void sendSharp(uint16_t address, uint16_t command);\n    void sendSAMSUNG(unsigned long data, int nbits);\n    __attribute__ ((deprecated (\"This old function sends MSB first! Please use sendSamsung().\")));\n    void sendSony(unsigned long data,\n            int nbits)\n                    __attribute__ ((deprecated (\"This old function sends MSB first! Please use sendSony(aAddress, aCommand, aNumberOfRepeats).\")));\n    ;\n    void sendWhynter(uint32_t aData, uint8_t aNumberOfBitsToSend);\n\n#if !defined(IR_SEND_PIN)\n    uint8_t sendPin;\n#endif\n    uint16_t periodTimeMicros;\n    uint16_t periodOnTimeMicros; // compensated with PULSE_CORRECTION_NANOS for duration of digitalWrite. Around 8 microseconds for 38 kHz.\n    uint16_t getPulseCorrectionNanos();\n\n    static void customDelayMicroseconds(unsigned long aMicroseconds);\n};\n\n/*\n * The sender instance\n */\nextern IRsend IrSender;\n\nvoid sendNECSpecialRepeat();\nvoid sendLG2SpecialRepeat();\nvoid sendSamsungLGSpecialRepeat();\n\n#endif // _IR_REMOTE_INT_H\n"
    }, {
      filename: "src/ir_Others.hpp",
      code: "/*\n * ir_Others.hpp\n *\n *  Contains functions for miscellaneous protocols\n *\n *  This file is part of Arduino-IRremote https://github.com/Arduino-IRremote/Arduino-IRremote.\n *\n ************************************************************************************\n * MIT License\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is furnished\n * to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n ************************************************************************************\n */\n\n/** \\addtogroup Decoder Decoders and encoders for different protocols\n * @{\n */\n\n#ifndef _IR_OTHERS_HPP\n#define _IR_OTHERS_HPP\n//==============================================================================\n//                       DDDD   IIIII   SSSS  H   H\n//                        D  D    I    S      H   H\n//                        D  D    I     SSS   HHHHH\n//                        D  D    I        S  H   H\n//                       DDDD   IIIII  SSSS   H   H\n//==============================================================================\n\n// DISH support by Todd Treece\n//\n// The send function needs to be repeated 4 times\n// Only send the last for characters of the hex.\n// I.E.  Use 0x1C10 instead of 0x0000000000001C10 as listed in the LIRC file.\n// Here is the LIRC file I found that seems to match the remote codes from the\n// oscilloscope: DISH NETWORK (echostar 301):\n//   http://lirc.sourceforge.net/remotes/echostar/301_501_3100_5100_58xx_59xx\n#define DISH_BITS             16\n#define DISH_HEADER_MARK     400\n#define DISH_HEADER_SPACE   6100\n#define DISH_BIT_MARK        400\n#define DISH_ONE_SPACE      1700\n#define DISH_ZERO_SPACE     2800\n#define DISH_REPEAT_SPACE   6200 // really?\n\nstruct PulseDistanceWidthProtocolConstants DishProtocolConstants = { UNKNOWN, 56, DISH_HEADER_MARK, DISH_HEADER_SPACE,\nDISH_BIT_MARK, DISH_ONE_SPACE, DISH_BIT_MARK, DISH_ZERO_SPACE, PROTOCOL_IS_MSB_FIRST, 40, NULL };\n\nvoid IRsend::sendDish(uint16_t aData) {\n    sendPulseDistanceWidth(&DishProtocolConstants, aData, DISH_BITS, 4);\n}\n\n//==============================================================================\n//               W   W  H   H  Y   Y N   N TTTTT EEEEE  RRRRR\n//               W   W  H   H   Y Y  NN  N   T   E      R   R\n//               W W W  HHHHH    Y   N N N   T   EEE    RRRR\n//               W W W  H   H    Y   N  NN   T   E      R  R\n//                WWW   H   H    Y   N   N   T   EEEEE  R   R\n//==============================================================================\n// Whynter A/C ARC-110WD added by Francesco Meschia\n// see https://docs.google.com/spreadsheets/d/1dsr4Jh-nzC6xvSKGpLlPBF0NRwvlpyw-ozg8eZU813w/edit#gid=0\n// Looking at the code table the protocol is LSB first with start and stop bit.\n// 4 bit checksum, constant address 0xAA00, 8 bit Command and 4 bit Command group\n// but we use MSB first to be backwards compatible\n#define WHYNTER_BITS            32\n#define WHYNTER_HEADER_MARK   2850\n#define WHYNTER_HEADER_SPACE  2850\n#define WHYNTER_BIT_MARK       750\n#define WHYNTER_ONE_SPACE     2150\n#define WHYNTER_ZERO_SPACE     750\n\nstruct PulseDistanceWidthProtocolConstants WhynterProtocolConstants = { WHYNTER, 38, WHYNTER_HEADER_MARK, WHYNTER_HEADER_SPACE,\nWHYNTER_BIT_MARK, WHYNTER_ONE_SPACE, WHYNTER_BIT_MARK, WHYNTER_ZERO_SPACE, PROTOCOL_IS_MSB_FIRST, 110, NULL };\n\nvoid IRsend::sendWhynter(uint32_t aData, uint8_t aNumberOfBitsToSend) {\n    sendPulseDistanceWidth(&WhynterProtocolConstants, aData, NEC_BITS, aNumberOfBitsToSend);\n}\n\nbool IRrecv::decodeWhynter() {\n    // Check we have the right amount of data (68). The +4 is for initial gap, start bit mark and space + stop bit mark.\n    if (decodedIRData.rawlen != (2 * WHYNTER_BITS) + 4) {\n        return false;\n    }\n    if (!checkHeader(&WhynterProtocolConstants)) {\n        return false;\n    }\n    if (!decodePulseDistanceWidthData(&WhynterProtocolConstants, WHYNTER_BITS)) {\n        return false;\n    }\n    // Success\n    decodedIRData.flags = IRDATA_FLAGS_IS_MSB_FIRST;\n    decodedIRData.numberOfBits = WHYNTER_BITS;\n    decodedIRData.protocol = WHYNTER;\n    return true;\n}\n\n/** @}*/\n#endif // _IR_OTHERS_HPP\n"
    }, {
      filename: "src/TinyIRReceiver.hpp",
      code: "/*\n *  TinyIRReceiver.hpp\n *\n *  Receives IR protocol data of NEC protocol using pin change interrupts.\n *  NEC is the protocol of most cheap remote controls for Arduino.\n *\n *  Parity check is done for address and data.\n *  On a completely received IR command, the user function handleReceivedIRData(uint8_t aAddress, uint8_t aCommand, uint8_t aFlags)\n *  is called in interrupt context but with interrupts being enabled to enable use of delay() etc.\n *  !!!!!!!!!!!!!!!!!!!!!!\n *  Functions called in interrupt context should be running as short as possible,\n *  so if you require longer action, save the data (address + command) and handle them in the main loop.\n *  !!!!!!!!!!!!!!!!!!!!!\n *  aFlags can contain one of IRDATA_FLAGS_EMPTY, IRDATA_FLAGS_IS_REPEAT and IRDATA_FLAGS_PARITY_FAILED bits\n *\n * The FAST protocol is a proprietary modified JVC protocol without address, with parity and with a shorter header.\n *  FAST Protocol characteristics:\n * - Bit timing is like NEC or JVC\n * - The header is shorter, 3156 vs. 12500\n * - No address and 16 bit data, interpreted as 8 bit command and 8 bit inverted command,\n *     leading to a fixed protocol length of (6 + (16 * 3) + 1) * 526 = 55 * 526 = 28930 microseconds or 29 ms.\n * - Repeats are sent as complete frames but in a 50 ms period / with a 21 ms distance.\n *\n *\n *  This file is part of IRMP https://github.com/IRMP-org/IRMP.\n *  This file is part of Arduino-IRremote https://github.com/Arduino-IRremote/Arduino-IRremote.\n *\n ************************************************************************************\n * MIT License\n *\n * Copyright (c) 2022-2024 Armin Joachimsmeyer\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is furnished\n * to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n ************************************************************************************\n */\n\n/*\n * This library can be configured at compile time by the following options / macros:\n * For more details see: https://github.com/Arduino-IRremote/Arduino-IRremote#compile-options--macros-for-this-library (scroll down)\n *\n * - IR_RECEIVE_PIN         The pin number for TinyIRReceiver IR input.\n * - IR_FEEDBACK_LED_PIN    The pin number for TinyIRReceiver feedback LED.\n * - NO_LED_FEEDBACK_CODE   Disables the feedback LED function. Saves 14 bytes program memory.\n * - DISABLE_PARITY_CHECKS  Disable parity checks. Saves 48 bytes of program memory.\n * - USE_EXTENDED_NEC_PROTOCOL Like NEC, but take the 16 bit address as one 16 bit value and not as 8 bit normal and 8 bit inverted value.\n * - USE_ONKYO_PROTOCOL     Like NEC, but take the 16 bit address and command each as one 16 bit value and not as 8 bit normal and 8 bit inverted value.\n * - USE_FAST_PROTOCOL      Use FAST protocol (no address and 16 bit data, interpreted as 8 bit command and 8 bit inverted command) instead of NEC.\n * - ENABLE_NEC2_REPEATS    Instead of sending / receiving the NEC special repeat code, send / receive the original frame for repeat.\n * - USE_CALLBACK_FOR_TINY_RECEIVER   Call the fixed function \"void handleReceivedTinyIRData()\" each time a frame or repeat is received.\n */\n\n#ifndef _TINY_IR_RECEIVER_HPP\n#define _TINY_IR_RECEIVER_HPP\n\n#include <Arduino.h>\n\n#if defined(DEBUG) && !defined(LOCAL_DEBUG)\n#define LOCAL_DEBUG\n#else\n//#define LOCAL_DEBUG // This enables debug output only for this file\n#endif\n\n/*\n * Protocol selection\n */\n//#define DISABLE_PARITY_CHECKS // Disable parity checks. Saves 48 bytes of program memory.\n//#define USE_EXTENDED_NEC_PROTOCOL // Like NEC, but take the 16 bit address as one 16 bit value and not as 8 bit normal and 8 bit inverted value.\n//#define USE_ONKYO_PROTOCOL    // Like NEC, but take the 16 bit address and command each as one 16 bit value and not as 8 bit normal and 8 bit inverted value.\n//#define USE_FAST_PROTOCOL     // Use FAST protocol instead of NEC / ONKYO.\n//#define ENABLE_NEC2_REPEATS // Instead of sending / receiving the NEC special repeat code, send / receive the original frame for repeat.\n\n#include \"TinyIR.h\" // If not defined, it defines IR_RECEIVE_PIN, IR_FEEDBACK_LED_PIN and TINY_RECEIVER_USE_ARDUINO_ATTACH_INTERRUPT\n\n#include \"digitalWriteFast.h\"\n/** \\addtogroup TinyReceiver Minimal receiver for NEC and FAST protocol\n * @{\n */\n\n#if defined(DEBUG)\n#define LOCAL_DEBUG_ATTACH_INTERRUPT\n#else\n//#define LOCAL_DEBUG_ATTACH_INTERRUPT  // to see if attachInterrupt() or static interrupt (by register tweaking) is used\n#endif\n#if defined(TRACE)\n#define LOCAL_TRACE_STATE_MACHINE\n#else\n//#define LOCAL_TRACE_STATE_MACHINE  // to see the state of the ISR (Interrupt Service Routine) state machine\n#endif\n\n//#define _IR_MEASURE_TIMING        // Activate this if you want to enable internal hardware timing measurement.\n//#define _IR_TIMING_TEST_PIN 7\nTinyIRReceiverStruct TinyIRReceiverControl;\nvolatile TinyIRReceiverCallbackDataStruct TinyIRReceiverData;\n\n/*\n * Set input pin and output pin definitions etc.\n */\n#if defined(IR_INPUT_PIN)\n#warning \"IR_INPUT_PIN is deprecated, use IR_RECEIVE_PIN\"\n#define IR_RECEIVE_PIN  IR_INPUT_PIN\n#endif\n#if !defined(IR_RECEIVE_PIN)\n#if defined(__AVR_ATtiny1616__) || defined(__AVR_ATtiny3216__) || defined(__AVR_ATtiny3217__)\n#warning \"IR_RECEIVE_PIN is not defined, so it is set to 10\"\n#define IR_RECEIVE_PIN    10\n#elif defined(__AVR_ATtiny816__)\n#warning \"IR_RECEIVE_PIN is not defined, so it is set to 14\"\n#define IR_RECEIVE_PIN    14\n#else\n#warning \"IR_RECEIVE_PIN is not defined, so it is set to 2\"\n#define IR_RECEIVE_PIN    2\n#endif\n#endif\n\n#if !defined(IR_FEEDBACK_LED_PIN) && defined(LED_BUILTIN)\n#define IR_FEEDBACK_LED_PIN    LED_BUILTIN\n#endif\n\n#if !( \\\n   (defined(__AVR_ATtiny25__) || defined(__AVR_ATtiny45__) || defined(__AVR_ATtiny85__)) /* ATtinyX5 */ \\\n|| defined(__AVR_ATtiny88__) /* MH-ET LIVE Tiny88 */ \\\n|| defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__) \\\n|| defined(__AVR_ATmega16U4__) || defined(__AVR_ATmega32U4__) \\\n|| defined(__AVR_ATmega8__) || defined(__AVR_ATmega48__) || defined(__AVR_ATmega48P__) || defined(__AVR_ATmega48PB__) || defined(__AVR_ATmega88P__) || defined(__AVR_ATmega88PB__) \\\n|| defined(__AVR_ATmega168__) || defined(__AVR_ATmega168PA__) || defined(__AVR_ATmega168PB__) || defined(__AVR_ATmega328__) || defined(__AVR_ATmega328P__) || defined(__AVR_ATmega328PB__) \\\n  /* ATmegas with ports 0,1,2 above and ATtiny167 only 2 pins below */ \\\n|| ( (defined(__AVR_ATtiny87__) || defined(__AVR_ATtiny167__)) && ( (defined(ARDUINO_AVR_DIGISPARKPRO) && ((IR_RECEIVE_PIN == 3) || (IR_RECEIVE_PIN == 9))) /*ATtinyX7(digisparkpro) and pin 3 or 9 */\\\n        || (! defined(ARDUINO_AVR_DIGISPARKPRO) && ((IR_RECEIVE_PIN == 3) || (IR_RECEIVE_PIN == 14)))) ) /*ATtinyX7(ATTinyCore) and pin 3 or 14 */ \\\n)\n#define TINY_RECEIVER_USE_ARDUINO_ATTACH_INTERRUPT // Cannot use any static ISR vector here. In other cases we have code provided for generating interrupt on pin change.\n#endif\n\n/**\n * Declaration of the callback function provided by the user application.\n * It is called every time a complete IR command or repeat was received.\n */\nextern void handleTinyReceivedIRData();\n\n#if defined(LOCAL_DEBUG)\nuint32_t sMicrosOfGap; // The length of the gap before the start bit\n#endif\n/**\n * The ISR (Interrupt Service Routine) of TinyIRRreceiver.\n * It handles the NEC protocol decoding and calls the user callback function on complete.\n * 5 us + 3 us for push + pop for a 16MHz ATmega\n */\n#if defined(ESP8266) || defined(ESP32)\nIRAM_ATTR\n#endif\nvoid IRPinChangeInterruptHandler(void) {\n#if defined(_IR_MEASURE_TIMING) && defined(_IR_TIMING_TEST_PIN)\n    digitalWriteFast(_IR_TIMING_TEST_PIN, HIGH); // 2 clock cycles\n#endif\n    /*\n     * Save IR input level\n     * Negative logic, true / HIGH means inactive / IR space, LOW / false means IR mark.\n     */\n    uint_fast8_t tIRLevel = digitalReadFast(IR_RECEIVE_PIN);\n\n#if !defined(NO_LED_FEEDBACK_CODE) && defined(IR_FEEDBACK_LED_PIN)\n    digitalWriteFast(IR_FEEDBACK_LED_PIN, !tIRLevel);\n#endif\n\n    /*\n     * 1. compute microseconds after last change\n     */\n    // Repeats can be sent after a pause, which is longer than 64000 microseconds, so we need a 32 bit value for check of repeats\n    uint32_t tCurrentMicros = micros();\n    uint32_t tMicrosOfMarkOrSpace32 = tCurrentMicros - TinyIRReceiverControl.LastChangeMicros;\n    uint16_t tMicrosOfMarkOrSpace = tMicrosOfMarkOrSpace32;\n\n    TinyIRReceiverControl.LastChangeMicros = tCurrentMicros;\n\n    uint8_t tState = TinyIRReceiverControl.IRReceiverState;\n\n#if defined(LOCAL_TRACE_STATE_MACHINE)\n    Serial.print(tState);\n    Serial.print(F(\" D=\"));\n    Serial.print(tMicrosOfMarkOrSpace);\n//    Serial.print(F(\" I=\"));\n//    Serial.print(tIRLevel);\n    Serial.print('|');\n#endif\n\n    if (tIRLevel == LOW) {\n        /*\n         * We have a mark here\n         */\n        if (tMicrosOfMarkOrSpace > 2 * TINY_RECEIVER_HEADER_MARK) {\n            // timeout -> must reset state machine\n            tState = IR_RECEIVER_STATE_WAITING_FOR_START_MARK;\n        }\n        if (tState == IR_RECEIVER_STATE_WAITING_FOR_START_MARK) {\n            // We are at the beginning of the header mark, check timing at the next transition\n            tState = IR_RECEIVER_STATE_WAITING_FOR_START_SPACE;\n            TinyIRReceiverControl.Flags = IRDATA_FLAGS_EMPTY; // If we do it here, it saves 4 bytes\n#if defined(LOCAL_TRACE)\n            sMicrosOfGap = tMicrosOfMarkOrSpace32;\n#endif\n#if defined(ENABLE_NEC2_REPEATS)\n            // Check for repeat, where full frame is sent again after TINY_RECEIVER_REPEAT_PERIOD ms\n            // Not required for NEC, where repeats are detected by a special header space duration\n            // Must use 32 bit arithmetic here!\n            if (tMicrosOfMarkOrSpace32 < TINY_RECEIVER_MAXIMUM_REPEAT_DISTANCE) {\n                TinyIRReceiverControl.Flags = IRDATA_FLAGS_IS_REPEAT;\n            }\n#endif\n        }\n\n        else if (tState == IR_RECEIVER_STATE_WAITING_FOR_FIRST_DATA_MARK) {\n            if (tMicrosOfMarkOrSpace >= lowerValue25Percent(TINY_RECEIVER_HEADER_SPACE)\n                    && tMicrosOfMarkOrSpace <= upperValue25Percent(TINY_RECEIVER_HEADER_SPACE)) {\n                /*\n                 * We have a valid data header space here -> initialize data\n                 */\n                TinyIRReceiverControl.IRRawDataBitCounter = 0;\n#if (TINY_RECEIVER_BITS > 16)\n                TinyIRReceiverControl.IRRawData.ULong = 0;\n#else\n                TinyIRReceiverControl.IRRawData.UWord = 0;\n#endif\n                TinyIRReceiverControl.IRRawDataMask = 1;\n                tState = IR_RECEIVER_STATE_WAITING_FOR_DATA_SPACE;\n#if !defined(ENABLE_NEC2_REPEATS)\n                // Check for NEC repeat header\n            } else if (tMicrosOfMarkOrSpace >= lowerValue25Percent(NEC_REPEAT_HEADER_SPACE)\n                    && tMicrosOfMarkOrSpace <= upperValue25Percent(NEC_REPEAT_HEADER_SPACE)\n                    && TinyIRReceiverControl.IRRawDataBitCounter >= TINY_RECEIVER_BITS) {\n                /*\n                 * We have a repeat header here and no broken receive before -> set repeat flag\n                 */\n                TinyIRReceiverControl.Flags = IRDATA_FLAGS_IS_REPEAT;\n                tState = IR_RECEIVER_STATE_WAITING_FOR_DATA_SPACE;\n#endif\n            } else {\n                // This parts are optimized by the compiler into jumps to one code :-)\n                // Wrong length -> reset state\n                tState = IR_RECEIVER_STATE_WAITING_FOR_START_MARK;\n            }\n        }\n\n        else if (tState == IR_RECEIVER_STATE_WAITING_FOR_DATA_MARK) {\n            // Check data space length\n            if (tMicrosOfMarkOrSpace >= lowerValue50Percent(TINY_RECEIVER_ZERO_SPACE)\n                    && tMicrosOfMarkOrSpace <= upperValue50Percent(TINY_RECEIVER_ONE_SPACE)) {\n                // We have a valid bit here\n                tState = IR_RECEIVER_STATE_WAITING_FOR_DATA_SPACE;\n                if (tMicrosOfMarkOrSpace >= 2 * TINY_RECEIVER_UNIT) {\n                    // we received a 1\n#if (TINY_RECEIVER_BITS > 16)\n                    TinyIRReceiverControl.IRRawData.ULong |= TinyIRReceiverControl.IRRawDataMask;\n#else\n                    TinyIRReceiverControl.IRRawData.UWord |= TinyIRReceiverControl.IRRawDataMask;\n#endif\n                } else {\n                    // we received a 0 - empty code for documentation\n                }\n                // prepare for next bit\n                TinyIRReceiverControl.IRRawDataMask = TinyIRReceiverControl.IRRawDataMask << 1;\n                TinyIRReceiverControl.IRRawDataBitCounter++;\n            } else {\n                // Wrong length -> reset state\n                tState = IR_RECEIVER_STATE_WAITING_FOR_START_MARK;\n            }\n        } else {\n            // error wrong state for the received level, e.g. if we missed one change interrupt -> reset state\n            tState = IR_RECEIVER_STATE_WAITING_FOR_START_MARK;\n        }\n    }\n\n    else {\n        /*\n         * We have a space here\n         */\n        if (tState == IR_RECEIVER_STATE_WAITING_FOR_START_SPACE) {\n            /*\n             * Check length of header mark here\n             */\n            if (tMicrosOfMarkOrSpace >= lowerValue25Percent(TINY_RECEIVER_HEADER_MARK)\n                    && tMicrosOfMarkOrSpace <= upperValue25Percent(TINY_RECEIVER_HEADER_MARK)) {\n                tState = IR_RECEIVER_STATE_WAITING_FOR_FIRST_DATA_MARK;\n            } else {\n                // Wrong length of header mark -> reset state\n                tState = IR_RECEIVER_STATE_WAITING_FOR_START_MARK;\n            }\n        }\n\n        else if (tState == IR_RECEIVER_STATE_WAITING_FOR_DATA_SPACE) {\n            // Check data mark length\n            if (tMicrosOfMarkOrSpace >= lowerValue50Percent(TINY_RECEIVER_BIT_MARK)\n                    && tMicrosOfMarkOrSpace <= upperValue50Percent(TINY_RECEIVER_BIT_MARK)) {\n                /*\n                 * We have a valid mark here, check for transmission complete, i.e. the mark of the stop bit\n                 */\n                if (TinyIRReceiverControl.IRRawDataBitCounter >= TINY_RECEIVER_BITS\n#if !defined(ENABLE_NEC2_REPEATS)\n                        || (TinyIRReceiverControl.Flags & IRDATA_FLAGS_IS_REPEAT) // Do not check for full length received, if we have a short repeat frame\n#endif\n                        ) {\n                    /*\n                     * Code complete -> optionally check parity\n                     */\n                    // Reset state for new start\n                    tState = IR_RECEIVER_STATE_WAITING_FOR_START_MARK;\n\n#if !defined(DISABLE_PARITY_CHECKS) && (TINY_RECEIVER_ADDRESS_BITS == 16) && TINY_RECEIVER_ADDRESS_HAS_8_BIT_PARITY\n                    /*\n                     * Check address parity\n                     * Address is sent first and contained in the lower word\n                     */\n                    if (TinyIRReceiverControl.IRRawData.UBytes[0] != (uint8_t) (~TinyIRReceiverControl.IRRawData.UBytes[1])) {\n#if defined(ENABLE_NEC2_REPEATS)\n                    TinyIRReceiverControl.Flags |= IRDATA_FLAGS_PARITY_FAILED; // here we can have the repeat flag already set\n#else\n                        TinyIRReceiverControl.Flags = IRDATA_FLAGS_PARITY_FAILED; // here we do not check anything, if we have a repeat\n#endif\n                    }\n#endif\n#if !defined(DISABLE_PARITY_CHECKS) && (TINY_RECEIVER_COMMAND_BITS == 16) && TINY_RECEIVER_COMMAND_HAS_8_BIT_PARITY\n                    /*\n                     * Check command parity\n                     */\n#if (TINY_RECEIVER_ADDRESS_BITS > 0)\n                    if (TinyIRReceiverControl.IRRawData.UBytes[2] != (uint8_t) (~TinyIRReceiverControl.IRRawData.UBytes[3])) {\n#if defined(ENABLE_NEC2_REPEATS)\n                    TinyIRReceiverControl.Flags |= IRDATA_FLAGS_PARITY_FAILED;\n#else\n                        TinyIRReceiverControl.Flags = IRDATA_FLAGS_PARITY_FAILED;\n#endif\n#  if defined(LOCAL_DEBUG)\n                    Serial.print(F(\"Parity check for command failed. Command=\"));\n                    Serial.print(TinyIRReceiverControl.IRRawData.UBytes[2], HEX);\n                    Serial.print(F(\" parity=\"));\n                    Serial.println(TinyIRReceiverControl.IRRawData.UBytes[3], HEX);\n#  endif\n#else\n                    // No address, so command and parity are in the lowest bytes\n                    if (TinyIRReceiverControl.IRRawData.UBytes[0] != (uint8_t) (~TinyIRReceiverControl.IRRawData.UBytes[1])) {\n                        TinyIRReceiverControl.Flags |= IRDATA_FLAGS_PARITY_FAILED;\n#  if defined(LOCAL_DEBUG)\n                        Serial.print(F(\"Parity check for command failed. Command=\"));\n                        Serial.print(TinyIRReceiverControl.IRRawData.UBytes[0], HEX);\n                        Serial.print(F(\" parity=\"));\n                        Serial.println(TinyIRReceiverControl.IRRawData.UBytes[1], HEX);\n#  endif\n#endif\n                    }\n#endif\n                    /*\n                     * Call user provided callback here\n                     * The parameter size is dependent of the code variant used in order to save program memory.\n                     * We have 6 cases: 0, 8 bit or 16 bit address, each with 8 or 16 bit command\n                     */\n#if !defined(ARDUINO_ARCH_MBED) && !defined(ESP32) // no Serial etc. in callback for ESP -> no interrupt required, WDT is running!\n                    interrupts(); // enable interrupts, so delay() etc. works in callback\n#endif\n                    TinyIRReceiverData.justWritten = true;\n                    TinyIRReceiverData.Flags = TinyIRReceiverControl.Flags;\n#if (TINY_RECEIVER_ADDRESS_BITS > 0)\n#  if TINY_RECEIVER_ADDRESS_HAS_8_BIT_PARITY\n                    // Here we have 8 bit address\n                    TinyIRReceiverData.Address = TinyIRReceiverControl.IRRawData.UBytes[0];\n#  else\n                    // Here we have 16 bit address\n                    TinyIRReceiverData.Address = TinyIRReceiverControl.IRRawData.UWord.LowWord;\n#  endif\n#  if TINY_RECEIVER_COMMAND_HAS_8_BIT_PARITY\n                    // Here we have 8 bit command\n                    TinyIRReceiverData.Command = TinyIRReceiverControl.IRRawData.UBytes[2];\n#  else\n                            // Here we have 16 bit command\n                    TinyIRReceiverData.Command = TinyIRReceiverControl.IRRawData.UWord.HighWord;\n#  endif\n\n#else\n                    // Here we have NO address\n#  if TINY_RECEIVER_COMMAND_HAS_8_BIT_PARITY\n                    // Here we have 8 bit command\n                    TinyIRReceiverData.Command = TinyIRReceiverControl.IRRawData.UBytes[0];\n#  else\n                    // Here we have 16 bit command\n                    TinyIRReceiverData.Command = TinyIRReceiverControl.IRRawData.UWord;\n#  endif\n#endif\n#if defined(USE_CALLBACK_FOR_TINY_RECEIVER)\n                    handleReceivedTinyIRData();\n#endif\n\n                } else {\n                    // not finished yet\n                    tState = IR_RECEIVER_STATE_WAITING_FOR_DATA_MARK;\n                }\n            } else {\n                // Wrong length -> reset state\n                tState = IR_RECEIVER_STATE_WAITING_FOR_START_MARK;\n            }\n        } else {\n            // error wrong state for the received level, e.g. if we missed one change interrupt -> reset state\n            tState = IR_RECEIVER_STATE_WAITING_FOR_START_MARK;\n        }\n    }\n\n    TinyIRReceiverControl.IRReceiverState = tState;\n#ifdef _IR_MEASURE_TIMING\n    digitalWriteFast(_IR_TIMING_TEST_PIN, LOW); // 2 clock cycles\n#endif\n}\n\nbool isTinyReceiverIdle() {\n    return (TinyIRReceiverControl.IRReceiverState == IR_RECEIVER_STATE_WAITING_FOR_START_MARK);\n}\n\n/*\n * Checks if IR_RECEIVE_PIN is connected and high\n * @return true, if IR Receiver is attached\n */\nbool isIRReceiverAttachedForTinyReceiver() {\n    pinModeFast(IR_RECEIVE_PIN, OUTPUT);\n    digitalWriteFast(IR_RECEIVE_PIN, LOW); // discharge pin capacity\n    pinModeFast(IR_RECEIVE_PIN, INPUT);\n    return digitalRead(IR_RECEIVE_PIN); // use slow digitalRead here, since the pin capacity is not fully charged again if we use digitalReadFast.\n}\n\n/**\n * Sets IR_RECEIVE_PIN mode to INPUT, and if IR_FEEDBACK_LED_PIN is defined, sets feedback LED output mode.\n * Then call enablePCIInterruptForTinyReceiver()\n */\nbool initPCIInterruptForTinyReceiver() {\n    pinModeFast(IR_RECEIVE_PIN, INPUT);\n\n#if !defined(NO_LED_FEEDBACK_CODE) && defined(IR_FEEDBACK_LED_PIN)\n    pinModeFast(IR_FEEDBACK_LED_PIN, OUTPUT);\n#endif\n    return enablePCIInterruptForTinyReceiver();\n}\n\nvoid printTinyReceiverResultMinimal(Print *aSerial) {\n// Print only very short output, since we are in an interrupt context and do not want to miss the next interrupts of the repeats coming soon\n    // Print only very short output, since we are in an interrupt context and do not want to miss the next interrupts of the repeats coming soon\n#if defined(USE_FAST_PROTOCOL)\n    aSerial->print(F(\"C=0x\"));\n#else\n    aSerial->print(F(\"A=0x\"));\n    aSerial->print(TinyIRReceiverData.Address, HEX);\n    aSerial->print(F(\" C=0x\"));\n#endif\n    aSerial->print(TinyIRReceiverData.Command, HEX);\n    if (TinyIRReceiverData.Flags == IRDATA_FLAGS_IS_REPEAT) {\n        aSerial->print(F(\" R\"));\n    }\n#if !defined(DISABLE_PARITY_CHECKS)\n    if (TinyIRReceiverData.Flags == IRDATA_FLAGS_PARITY_FAILED) {\n        aSerial->print(F(\" P\"));\n    }\n#endif\n    aSerial->println();\n}\n\n#if defined (LOCAL_DEBUG_ATTACH_INTERRUPT) && !defined(STR)\n// Helper macro for getting a macro definition as string\n#define STR_HELPER(x) #x\n#define STR(x) STR_HELPER(x)\n#endif\n\n/**************************************************\n * Pin to interrupt mapping for different platforms\n **************************************************/\n#if defined(__AVR_ATtiny816__) || defined(__AVR_ATtiny1616__) || defined(__AVR_ATtiny3216__) || defined(__AVR_ATtiny3217__)\n#define USE_ATTACH_INTERRUPT_DIRECT\n\n#elif !defined(__AVR__) || defined(TINY_RECEIVER_USE_ARDUINO_ATTACH_INTERRUPT)\n// Default for all NON AVR platforms\n#define USE_ATTACH_INTERRUPT\n\n#else\n#  if defined(__AVR_ATtiny25__) || defined(__AVR_ATtiny45__) || defined(__AVR_ATtiny85__)\n#define USE_PCIE\n\n#  elif defined(__AVR_ATtiny87__) || defined(__AVR_ATtiny167__)\n#    if defined(ARDUINO_AVR_DIGISPARKPRO)\n#      if (IR_RECEIVE_PIN == 3)\n#define USE_INT0\n#      elif (IR_RECEIVE_PIN == 9)\n#define USE_INT1\n#      else\n#        error \"IR_RECEIVE_PIN must be 9 or 3.\"\n#      endif // if (IR_RECEIVE_PIN == 9)\n#    else // defined(ARDUINO_AVR_DIGISPARKPRO)\n#      if (IR_RECEIVE_PIN == 14)\n#define USE_INT0\n#      elif (IR_RECEIVE_PIN == 3)\n#define USE_INT1\n#      else\n#        error \"IR_RECEIVE_PIN must be 14 or 3.\"\n#      endif // if (IR_RECEIVE_PIN == 14)\n#    endif\n\n#  elif (defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__))\n#    if (IR_RECEIVE_PIN == 21)\n#define USE_INT0\n#    elif (IR_RECEIVE_PIN == 20)\n#define USE_INT1\n#    else\n#warning \"No pin mapping for IR_RECEIVE_PIN to interrupt found -> attachInterrupt() is used now.\"\n#define USE_ATTACH_INTERRUPT\n#    endif\n\n#  else // defined(__AVR_ATtiny25__)\n/*\n * ATmegas + ATtiny88 here\n */\n#    if (IR_RECEIVE_PIN == 2)\n#define USE_INT0\n#    elif (IR_RECEIVE_PIN == 3)\n#define USE_INT1\n\n#    elif IR_RECEIVE_PIN == 4 || IR_RECEIVE_PIN == 5 || IR_RECEIVE_PIN == 6 || IR_RECEIVE_PIN == 7\n    //ATmega328 (Uno, Nano ) etc. Enable pin change interrupt 20 to 23 for port PD4 to PD7 (Arduino pin 4 to 7)\n#define USE_PCINT2\n#    elif IR_RECEIVE_PIN == 8 || IR_RECEIVE_PIN == 9 || IR_RECEIVE_PIN == 10 || IR_RECEIVE_PIN == 11 || IR_RECEIVE_PIN == 12 || IR_RECEIVE_PIN == 13\n    //ATmega328 (Uno, Nano ) etc. Enable pin change interrupt 0 to 5 for port PB0 to PB5 (Arduino pin 8 to 13)\n#define USE_PCINT0\n#    elif IR_RECEIVE_PIN == A0 || IR_RECEIVE_PIN == A1 || IR_RECEIVE_PIN == A2 || IR_RECEIVE_PIN == A3 || IR_RECEIVE_PIN == A4 || IR_RECEIVE_PIN == A5\n    //ATmega328 (Uno, Nano ) etc. Enable pin change interrupt 8 to 13 for port PC0 to PC5 (Arduino pin A0 to A5)\n#define USE_PCINT1\n\n#    else\n#warning \"No pin mapping for IR_RECEIVE_PIN to interrupt found -> attachInterrupt() is used now.\"\n#define USE_ATTACH_INTERRUPT\n#    endif // if (IR_RECEIVE_PIN == 2)\n#  endif // defined(__AVR_ATtiny25__)\n#endif // ! defined(__AVR__) || defined(TINY_RECEIVER_USE_ARDUINO_ATTACH_INTERRUPT)\n\n/**\n * Initializes hardware interrupt generation according to IR_RECEIVE_PIN or use attachInterrupt() function.\n * @return true if interrupt was successfully enabled\n */\nbool enablePCIInterruptForTinyReceiver() {\n#if defined(_IR_MEASURE_TIMING) && defined(_IR_TIMING_TEST_PIN)\n    pinModeFast(_IR_TIMING_TEST_PIN, OUTPUT);\n#endif\n\n#if defined(USE_ATTACH_INTERRUPT) || defined(USE_ATTACH_INTERRUPT_DIRECT)\n#  if defined(USE_ATTACH_INTERRUPT)\n#if defined(NOT_AN_INTERRUPT)\n    if(digitalPinToInterrupt(IR_RECEIVE_PIN) == NOT_AN_INTERRUPT){\n        return false;\n    }\n#endif\n    // costs 112 bytes program memory + 4 bytes RAM\n    attachInterrupt(digitalPinToInterrupt(IR_RECEIVE_PIN), IRPinChangeInterruptHandler, CHANGE);\n#  else\n    // 2.2 us more than version configured with macros and not compatible\n    attachInterrupt(IR_RECEIVE_PIN, IRPinChangeInterruptHandler, CHANGE); // no extra pin mapping here\n#  endif\n\n#  if defined(LOCAL_DEBUG_ATTACH_INTERRUPT)\n    Serial.println(F(\"Use attachInterrupt for pin=\" STR(IR_RECEIVE_PIN)));\n#  endif\n\n#else\n#  if defined(LOCAL_DEBUG_ATTACH_INTERRUPT)\n    Serial.println(F(\"Use static interrupt for pin=\" STR(IR_RECEIVE_PIN)));\n#  endif\n#  if defined(USE_INT0)\n    // interrupt on any logical change\n    EICRA |= _BV(ISC00);\n    // clear interrupt bit\n    EIFR |= 1 << INTF0;\n    // enable interrupt on next change\n    EIMSK |= 1 << INT0;\n\n#  elif defined(USE_INT1)\n    EICRA |= _BV(ISC10);\n// clear interrupt bit\n    EIFR |= 1 << INTF1;\n// enable interrupt on next change\n    EIMSK |= 1 << INT1;\n\n#  elif defined(USE_PCIE) // For ATtiny85 etc.\n    // use PinChangeInterrupt no INT0 for pin PB2\n    PCMSK = _BV(IR_RECEIVE_PIN);\n    // clear interrupt bit\n    GIFR |= 1 << PCIF;\n    // enable interrupt on next change\n    GIMSK |= 1 << PCIE;\n\n#  elif defined(USE_PCINT0)\n    PCICR |= _BV(PCIE0);\n    PCMSK0 = digitalPinToBitMask(IR_RECEIVE_PIN);\n#  elif defined(USE_PCINT1)\n    PCICR |= _BV(PCIE1);\n    PCMSK1 = digitalPinToBitMask(IR_RECEIVE_PIN);\n#  elif defined(USE_PCINT2)\n    PCICR |= _BV(PCIE2);\n    PCMSK2 = digitalPinToBitMask(IR_RECEIVE_PIN);\n#  else\n    return false;\n#  endif\n#endif // defined(USE_ATTACH_INTERRUPT)\n    return true;\n}\n\nvoid disablePCIInterruptForTinyReceiver() {\n#if defined(_IR_MEASURE_TIMING) && defined(_IR_TIMING_TEST_PIN)\n    pinModeFast(_IR_TIMING_TEST_PIN, OUTPUT);\n#endif\n\n#if defined(USE_ATTACH_INTERRUPT) || defined(USE_ATTACH_INTERRUPT_DIRECT)\n#  if defined(USE_ATTACH_INTERRUPT)\n    detachInterrupt(digitalPinToInterrupt(IR_RECEIVE_PIN));\n#  else\n    detachInterrupt(IR_RECEIVE_PIN);\n#  endif\n\n#else\n#  if defined(USE_INT0)\n    // clear interrupt bit\n    EIFR |= 1 << INTF0;\n    // disable interrupt on next change\n    EIMSK &= ~(1 << INT0);\n\n#  elif defined(USE_INT1)\n    // clear interrupt bit\n    EIFR |= 1 << INTF1;\n    // disable interrupt on next change\n    EIMSK &= ~(1 << INT1);\n\n#  elif defined(USE_PCIE) // For ATtiny85 etc.\n    // clear interrupt bit\n    GIFR |= 1 << PCIF;\n    // disable interrupt on next change\n    GIMSK &= ~(1 << PCIE);\n\n#  elif defined(USE_PCINT0)\n    PCICR &= ~(_BV(PCIE0));\n#  elif defined(USE_PCINT1)\n    PCICR &= ~(_BV(PCIE1));\n#  elif defined(USE_PCINT2)\n    PCICR &= ~(_BV(PCIE2));\n\n#  endif\n#endif // defined(USE_ATTACH_INTERRUPT)\n}\n\n/*\n * Specify the right INT0, INT1 or PCINT0 interrupt vector according to different pins and cores.\n * The default value of TINY_RECEIVER_USE_ARDUINO_ATTACH_INTERRUPT is set in TinyIRReceiver.h\n */\n#if !(defined(USE_ATTACH_INTERRUPT) || defined(USE_ATTACH_INTERRUPT_DIRECT))\n#  if defined(USE_INT0)\nISR(INT0_vect)\n\n#  elif defined(USE_INT1)\nISR(INT1_vect)\n\n#  elif defined(USE_PCIE) // For ATtiny85 etc.\n// on ATtinyX5 we do not have a INT1_vect but we can use the PCINT0_vect\nISR(PCINT0_vect)\n\n#  elif defined(USE_PCINT0)\nISR(PCINT0_vect)\n#  elif defined(USE_PCINT1)\nISR(PCINT1_vect)\n#  elif defined(USE_PCINT2)\nISR(PCINT2_vect)\n#  else\nvoid dummyFunctionToAvoidCompilerErrors()\n#  endif\n{\n    IRPinChangeInterruptHandler();\n}\n#endif // !(defined(USE_ATTACH_INTERRUPT) || defined(USE_ATTACH_INTERRUPT_DIRECT))\n\n/** @}*/\n\n#if defined(LOCAL_DEBUG_ATTACH_INTERRUPT)\n#undef LOCAL_DEBUG_ATTACH_INTERRUPT\n#endif\n#if defined(LOCAL_TRACE_STATE_MACHINE)\n#undef LOCAL_TRACE_STATE_MACHINE\n#endif\n\n#if defined(LOCAL_DEBUG)\n#undef LOCAL_DEBUG\n#endif\n#endif // _TINY_IR_RECEIVER_HPP\n"
    }, {
      filename: "src/ir_Denon.hpp",
      code: "/*\n * ir_Denon.cpp\n *\n *  Contains functions for receiving and sending Denon/Sharp IR Protocol\n *\n *  This file is part of Arduino-IRremote https://github.com/Arduino-IRremote/Arduino-IRremote.\n *\n ************************************************************************************\n * MIT License\n *\n * Copyright (c) 2020-2023 Armin Joachimsmeyer\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is furnished\n * to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n ************************************************************************************\n */\n#ifndef _IR_DENON_HPP\n#define _IR_DENON_HPP\n\n#if defined(DEBUG) && !defined(LOCAL_DEBUG)\n#define LOCAL_DEBUG\n#else\n//#define LOCAL_DEBUG // This enables debug output only for this file\n#endif\n\n/** \\addtogroup Decoder Decoders and encoders for different protocols\n * @{\n */\n//==============================================================================\n//                    DDDD   EEEEE  N   N   OOO   N   N\n//                     D  D  E      NN  N  O   O  NN  N\n//                     D  D  EEE    N N N  O   O  N N N\n//                     D  D  E      N  NN  O   O  N  NN\n//                    DDDD   EEEEE  N   N   OOO   N   N\n//==============================================================================\n//                       SSSS  H   H   AAA   RRRR   PPPP\n//                      S      H   H  A   A  R   R  P   P\n//                       SSS   HHHHH  AAAAA  RRRR   PPPP\n//                          S  H   H  A   A  R  R   P\n//                      SSSS   H   H  A   A  R   R  P\n//==============================================================================\n/*\n Protocol=Denon Address=0x11 Command=0x76 Raw-Data=0xED1 15 bits LSB first\n + 200,-1800 + 300,- 750 + 300,- 800 + 200,- 800\n + 250,-1800 + 250,- 800 + 250,-1800 + 300,-1750\n + 300,- 750 + 300,-1800 + 250,-1800 + 250,-1850\n + 250,- 750 + 300,- 800 + 250,- 800 + 250\n Sum: 23050\n\n Denon/Sharp variant\n Protocol=Denon Address=0x11 Command=0x76 Raw-Data=0x4ED1 15 bits LSB first\n + 200,-1800 + 300,- 750 + 250,- 800 + 250,- 750\n + 300,-1800 + 250,- 800 + 250,-1800 + 300,-1750\n + 300,- 750 + 300,-1800 + 250,-1800 + 250,-1800\n + 300,- 750 + 300,- 750 + 300,-1800 + 250\n Sum: 23050\n */\n/*\n * https://www.mikrocontroller.net/articles/IRMP_-_english#DENON\n * Denon published all their IR codes:\n * http://assets.denon.com/documentmaster/us/denon%20master%20ir%20hex.xls\n * Example:\n * 0000 006D 0000 0020 000A 001E 000A 0046 000A 001E 000A 001E 000A 001E // 5 address bits\n *                     000A 001E 000A 001E 000A 0046 000A 0046 000A 0046 000A 001E 000A 0046 000A 0046 // 8 command bits\n *                     000A 001E 000A 001E 000A 0679 // 2 frame bits 0,0 + stop bit + space for AutoRepeat\n *                     000A 001E 000A 0046 000A 001E 000A 001E 000A 001E // 5 address bits\n *                     000A 0046 000A 0046 000A 001E 000A 001E 000A 001E 000A 0046 000A 001E 000A 001E // 8 inverted command bits\n *                     000A 0046 000A 0046 000A 0679 // 2 frame bits 1,1 + stop bit + space for Repeat\n * From analyzing the codes for Tuner preset 1 to 8 in tab Main Zone ID#1 it is obvious, that the protocol is LSB first at least for command.\n * All Denon codes with 32 as 3. value use the Kaseyikyo Denon variant.\n */\n// LSB first, no start bit, 5 address + 8 command + 2 frame (0,0) + 1 stop bit - each frame 2 times\n// Every frame is auto repeated with a space period of 45 ms and the command and frame inverted to (1,1) or (0,1) for SHARP.\n//\n#define DENON_ADDRESS_BITS      5\n#define DENON_COMMAND_BITS      8\n#define DENON_FRAME_BITS        2 // 00/10 for 1. frame Denon/Sharp, inverted for autorepeat frame\n\n#define DENON_BITS              (DENON_ADDRESS_BITS + DENON_COMMAND_BITS + DENON_FRAME_BITS) // 15 - The number of bits in the command\n#define DENON_UNIT              260\n\n#define DENON_BIT_MARK          DENON_UNIT  // The length of a Bit:Mark\n#define DENON_ONE_SPACE         (7 * DENON_UNIT) // 1820 // The length of a Bit:Space for 1's\n#define DENON_ZERO_SPACE        (3 * DENON_UNIT) // 780 // The length of a Bit:Space for 0's\n\n#define DENON_AUTO_REPEAT_DISTANCE  45000 // Every frame is auto repeated with a space period of 45 ms and the command and frame inverted.\n#define DENON_REPEAT_PERIOD        110000 // Commands are repeated every 110 ms (measured from start to start) for as long as the key on the remote control is held down.\n\n// for old decoder\n#define DENON_HEADER_MARK       DENON_UNIT // The length of the Header:Mark\n#define DENON_HEADER_SPACE      (3 * DENON_UNIT) // 780 // The length of the Header:Space\n\nstruct PulseDistanceWidthProtocolConstants DenonProtocolConstants = { DENON, DENON_KHZ, DENON_HEADER_MARK, DENON_HEADER_SPACE,\nDENON_BIT_MARK, DENON_ONE_SPACE, DENON_BIT_MARK, DENON_ZERO_SPACE, PROTOCOL_IS_LSB_FIRST,\n        (DENON_REPEAT_PERIOD / MICROS_IN_ONE_MILLI), NULL };\n\n/************************************\n * Start of send and decode functions\n ************************************/\n\nvoid IRsend::sendSharp(uint8_t aAddress, uint8_t aCommand, int_fast8_t aNumberOfRepeats) {\n    sendDenon(aAddress, aCommand, aNumberOfRepeats, true);\n}\n\nvoid IRsend::sendDenon(uint8_t aAddress, uint8_t aCommand, int_fast8_t aNumberOfRepeats, bool aSendSharp) {\n    // Set IR carrier frequency\n    enableIROut (DENON_KHZ); // 38 kHz\n\n    // Add frame marker for sharp\n    uint16_t tCommand = aCommand;\n    if (aSendSharp) {\n        tCommand |= 0x0200; // the 2 upper bits are 00 for Denon and 10 for Sharp\n    }\n    uint16_t tData = aAddress | ((uint16_t) tCommand << DENON_ADDRESS_BITS);\n    uint16_t tInvertedData = (tData ^ 0x7FE0); // Command and frame (upper 10 bits) are inverted\n\n    uint_fast8_t tNumberOfCommands = aNumberOfRepeats + 1;\n    while (tNumberOfCommands > 0) {\n\n        // Data\n        sendPulseDistanceWidthData(&DenonProtocolConstants, tData, DENON_BITS);\n\n        // Inverted autorepeat frame\n        delay(DENON_AUTO_REPEAT_DISTANCE / MICROS_IN_ONE_MILLI);\n        sendPulseDistanceWidthData(&DenonProtocolConstants, tInvertedData, DENON_BITS);\n\n        tNumberOfCommands--;\n        // skip last delay!\n        if (tNumberOfCommands > 0) {\n            // send repeated command with a fixed space gap\n            delay( DENON_AUTO_REPEAT_DISTANCE / MICROS_IN_ONE_MILLI);\n        }\n    }\n}\n\nbool IRrecv::decodeSharp() {\n    return decodeDenon();\n}\n\nbool IRrecv::decodeDenon() {\n\n    // we have no start bit, so check for the exact amount of data bits\n    // Check we have the right amount of data (32). The + 2 is for initial gap + stop bit mark\n    if (decodedIRData.rawlen != (2 * DENON_BITS) + 2) {\n        IR_DEBUG_PRINT(F(\"Denon: \"));\n        IR_DEBUG_PRINT(F(\"Data length=\"));\n        IR_DEBUG_PRINT(decodedIRData.rawlen);\n        IR_DEBUG_PRINTLN(F(\" is not 32\"));\n        return false;\n    }\n\n    // Try to decode as Denon protocol\n    if (!decodePulseDistanceWidthData(&DenonProtocolConstants, DENON_BITS, 1)) {\n#if defined(LOCAL_DEBUG)\n        Serial.print(F(\"Denon: \"));\n        Serial.println(F(\"Decode failed\"));\n#endif\n        return false;\n    }\n\n    // Check for stop mark\n    if (!matchMark(decodedIRData.rawDataPtr->rawbuf[(2 * DENON_BITS) + 1], DENON_HEADER_MARK)) {\n#if defined(LOCAL_DEBUG)\n        Serial.print(F(\"Denon: \"));\n        Serial.println(F(\"Stop bit mark length is wrong\"));\n#endif\n        return false;\n    }\n\n    // Success\n    decodedIRData.address = decodedIRData.decodedRawData & 0x1F;\n    decodedIRData.command = decodedIRData.decodedRawData >> DENON_ADDRESS_BITS;\n    uint8_t tFrameBits = (decodedIRData.command >> 8) & 0x03;\n    decodedIRData.command &= 0xFF;\n\n    // Check for (auto) repeat\n    if (decodedIRData.initialGap < ((DENON_AUTO_REPEAT_DISTANCE + (DENON_AUTO_REPEAT_DISTANCE / 4)) / MICROS_PER_TICK)) {\n        repeatCount++;\n        if (repeatCount > 1) { // skip first auto repeat\n            decodedIRData.flags = IRDATA_FLAGS_IS_REPEAT;\n        }\n\n        if (tFrameBits & 0x01) {\n            /*\n             * Here we are in the auto repeated frame with the inverted command\n             */\n#if defined(LOCAL_DEBUG)\n                Serial.print(F(\"Denon: \"));\n                Serial.println(F(\"Autorepeat received=\"));\n#endif\n            decodedIRData.flags |= IRDATA_FLAGS_IS_AUTO_REPEAT;\n            // Check parity of consecutive received commands. There is no parity in one data set.\n            if ((uint8_t) lastDecodedCommand != (uint8_t)(~decodedIRData.command)) {\n                decodedIRData.flags |= IRDATA_FLAGS_PARITY_FAILED;\n#if defined(LOCAL_DEBUG)\n                Serial.print(F(\"Denon: \"));\n                Serial.print(F(\"Parity check for repeat failed. Last command=\"));\n                Serial.print(lastDecodedCommand, HEX);\n                Serial.print(F(\" current=\"));\n                Serial.println(~decodedIRData.command, HEX);\n#endif\n            }\n            // always take non inverted command\n            decodedIRData.command = lastDecodedCommand;\n        }\n\n        // repeated command here\n        if (tFrameBits == 1 || tFrameBits == 2) {\n            decodedIRData.protocol = SHARP;\n        } else {\n            decodedIRData.protocol = DENON;\n        }\n    } else {\n        repeatCount = 0;\n        // first command here\n        if (tFrameBits == 2) {\n            decodedIRData.protocol = SHARP;\n        } else {\n            decodedIRData.protocol = DENON;\n        }\n    }\n\n    decodedIRData.numberOfBits = DENON_BITS;\n\n    return true;\n}\n\n/*********************************************************************************\n * Old deprecated functions, kept for backward compatibility to old 2.0 tutorials\n *********************************************************************************/\n/*\n * Only for backwards compatibility\n */\nvoid IRsend::sendDenonRaw(uint16_t aRawData, int_fast8_t aNumberOfRepeats) {\n    sendDenon(aRawData >> (DENON_COMMAND_BITS + DENON_FRAME_BITS), (aRawData >> DENON_FRAME_BITS) & 0xFF, aNumberOfRepeats);\n}\n\n/*\n * Old function with parameter data\n */\nvoid IRsend::sendDenon(unsigned long data, int nbits) {\n    // Set IR carrier frequency\n    enableIROut (DENON_KHZ);\n#if !(defined(__AVR_ATtiny25__) || defined(__AVR_ATtiny45__) || defined(__AVR_ATtiny85__) || defined(__AVR_ATtiny87__) || defined(__AVR_ATtiny167__))\n//    Serial.println(\n//            \"The function sendDenon(data, nbits) is deprecated and may not work as expected! Use sendDenonRaw(data, NumberOfRepeats) or better sendDenon(Address, Command, NumberOfRepeats).\");\n#endif\n\n    // Header\n    mark(DENON_HEADER_MARK);\n    space(DENON_HEADER_SPACE);\n\n    // Data\n    sendPulseDistanceWidthData(DENON_BIT_MARK, DENON_ONE_SPACE, DENON_BIT_MARK, DENON_ZERO_SPACE, data, nbits,\n            PROTOCOL_IS_MSB_FIRST);\n}\n\n/*\n * Old function without parameter aNumberOfRepeats\n */\nvoid IRsend::sendSharp(uint16_t aAddress, uint16_t aCommand) {\n    sendDenon(aAddress, aCommand, true, 0);\n}\n\nbool IRrecv::decodeDenonOld(decode_results *aResults) {\n\n    // Check we have the right amount of data\n    if (decodedIRData.rawlen != 1 + 2 + (2 * DENON_BITS) + 1) {\n        return false;\n    }\n\n    // Check initial Mark+Space match\n    if (!matchMark(aResults->rawbuf[1], DENON_HEADER_MARK)) {\n        return false;\n    }\n\n    if (!matchSpace(aResults->rawbuf[2], DENON_HEADER_SPACE)) {\n        return false;\n    }\n\n    // Try to decode as Denon protocol\n    if (!decodePulseDistanceWidthData(DENON_BITS, 3, DENON_BIT_MARK, 0, DENON_ONE_SPACE, DENON_ZERO_SPACE, PROTOCOL_IS_MSB_FIRST)) {\n        return false;\n    }\n\n    // Success\n    aResults->value = decodedIRData.decodedRawData;\n    aResults->bits = DENON_BITS;\n    aResults->decode_type = DENON;\n    decodedIRData.protocol = DENON;\n    return true;\n}\n\n/** @}*/\n#if defined(LOCAL_DEBUG)\n#undef LOCAL_DEBUG\n#endif\n#endif // _IR_DENON_HPP\n"
    }, {
      filename: "src/ir_BangOlufsen.hpp",
      code: "/*\n * ir_BangOlufsen.hpp\n *\n *  Contains functions for receiving and sending Bang & Olufsen IR and Datalink '86 protocols\n *  To receive B&O and ENABLE_BEO_WITHOUT_FRAME_GAP is NOT defined, you must set RECORD_GAP_MICROS to\n *  at least 16000 to accommodate the unusually long 3. start space.\n *\n *  This file is part of Arduino-IRremote https://github.com/Arduino-IRremote/Arduino-IRremote.\n *\n ************************************************************************************\n * MIT License\n *\n * Copyright (c) 2022-2023 Daniel Wallner and Armin Joachimsmeyer\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is furnished\n * to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n ************************************************************************************\n */\n#ifndef _IR_BANG_OLUFSEN_HPP\n#define _IR_BANG_OLUFSEN_HPP\n\n//==============================================================================\n//\n//\n//                              Bang & Olufsen\n//\n//\n//==============================================================================\n// https://www.mikrocontroller.net/attachment/33137/datalink.pdf\n// https://www.mikrocontroller.net/articles/IRMP_-_english#B&O\n\n// This protocol is unusual in two ways:\n\n// 1. The carrier frequency is 455 kHz\n\n// You can build your own receiver as Bang & Olufsen did (check old schematics) or use a TSOP7000\n// Vishay stopped producing TSOP7000 since 2009 so you will probably only find counterfeits:\n// https://www.vishay.com/files/whatsnew/doc/ff_FastFacts_CounterfeitTSOP7000_Dec72018.pdf\n// It is also likely that you will need an oscilloscope to debug a counterfeit TSOP7000\n// The specimen used to test this code was very noisy and had a very low output current\n// A somewhat working fix was to put a 4n7 capacitor across the output and ground followed by a pnp emitter follower\n// Other examples may require a different treatment\n// This particular receiver also did receive lower frequencies but rather poorly and with a lower delay than usual\n// If you need to parallel a receiver with another one you may need to delay the signal to get in phase with the other receiver\n\n// 2. A stream of messages can be sent back to back with a new message immediately following the previous stop space\n\n// It might be that this only happens over IR and not on the datalink protocol\n// You can choose to support this or not:\n\n// Alt 1: Mode with gaps between frames\n// Set RECORD_GAP_MICROS to at least 16000 to accommodate the unusually long 3. start space\n// Can only receive single messages and back to back repeats will result in overflow\n\n// Alt 2: Break at start mode\n// Define ENABLE_BEO_WITHOUT_FRAME_GAP and set RECORD_GAP_MICROS to 13000 to treat the 3. start space as a gap between messages\n// The start of a transmission will result in a dummy decode with 0 bits data followed by the actual messages\n// If the receiver is not resumed within a ms or so, partial messages will be decoded\n// Debug printing in the wrong place is very likely to break reception\n// Make sure to check the number of bits to filter dummy and incomplete messages\n\n// !!! We assume that the real implementations never set the official first header bit to anything other than 0 !!!\n// !!! We therefore use 4 start bits instead of the specified 3 and in turn ignore the first header bit of the specification !!!\n\n// IR messages are 16 bits long. Datalink messages have different lengths.\n// This implementation supports up to 40 bits total length split into 8 bit data/command and a header/address of variable length\n// Header data with more than 16 bits is stored in decodedIRData.extra\n\n// B&O is a pulse distance protocol, but it has 3 bit values 0, 1 and (equal/repeat) as well as a special start and trailing bit.\n// MSB first, 4 start bits + 8 to 16? bit address + 8 bit command + 1 special trailing bit + 1 stop bit.\n// Address can be longer than 8 bit.\n\n/*\n * Options for this decoder\n *\n */\n#define ENABLE_BEO_WITHOUT_FRAME_GAP // Requires additional 30 bytes program memory. Enabled by default, see https://github.com/Arduino-IRremote/Arduino-IRremote/discussions/1181\n//#define SUPPORT_BEO_DATALINK_TIMING_FOR_DECODE // This also supports headers up to 32 bit. Requires additional 150 bytes program memory.\n#if defined(DECODE_BEO)\n#  if defined(ENABLE_BEO_WITHOUT_FRAME_GAP)\n#    if RECORD_GAP_MICROS > 13000\n#warning If defined ENABLE_BEO_WITHOUT_FRAME_GAP, RECORD_GAP_MICROS must be set to 1300 by \"#define RECORD_GAP_MICROS 13000\"\n#    endif\n#  else\n#    if RECORD_GAP_MICROS < 16000\n#error If not defined ENABLE_BEO_WITHOUT_FRAME_GAP, RECORD_GAP_MICROS must be set to a value >= 1600 by \"#define RECORD_GAP_MICROS 16000\"\n#    endif\n#  endif\n#endif\n\n#define BEO_DATA_BITS         8                // Command or character\n\n#define BEO_UNIT              3125             // All timings are in microseconds\n\n#define BEO_IR_MARK           200              // The length of a mark in the IR protocol\n#define BEO_DATALINK_MARK     (BEO_UNIT / 2)   // The length of a mark in the Datalink protocol\n\n#define BEO_PULSE_LENGTH_ZERO           BEO_UNIT      // The length of a one to zero transition\n#define BEO_PULSE_LENGTH_EQUAL          (2 * BEO_UNIT)   // 6250 The length of an equal bit\n#define BEO_PULSE_LENGTH_ONE            (3 * BEO_UNIT)   // 9375 The length of a zero to one transition\n#define BEO_PULSE_LENGTH_TRAILING_BIT   (4 * BEO_UNIT)   // 12500 The length of the stop bit\n#define BEO_PULSE_LENGTH_START_BIT      (5 * BEO_UNIT)   // 15625 The length of the start bit\n// It is not allowed to send two ones or zeros, you must send a one or zero and a equal instead.\n\n//#define BEO_LOCAL_DEBUG\n//#define BEO_LOCAL_TRACE\n\n#ifdef BEO_LOCAL_DEBUG\n#  define BEO_DEBUG_PRINT(...)    Serial.print(__VA_ARGS__)\n#  define BEO_DEBUG_PRINTLN(...)  Serial.println(__VA_ARGS__)\n#else\n#  define BEO_DEBUG_PRINT(...) void()\n#  define BEO_DEBUG_PRINTLN(...) void()\n#endif\n\n#ifdef BEO_LOCAL_TRACE\n#  undef BEO_TRACE_PRINT\n#  undef BEO_TRACE_PRINTLN\n#  define BEO_TRACE_PRINT(...)    Serial.print(__VA_ARGS__)\n#  define BEO_TRACE_PRINTLN(...)  Serial.println(__VA_ARGS__)\n#else\n#  define BEO_TRACE_PRINT(...) void()\n#  define BEO_TRACE_PRINTLN(...) void()\n#endif\n\n/************************************\n * Start of send and decode functions\n ************************************/\n\n/*\n * TODO aNumberOfRepeats are handled not correctly if ENABLE_BEO_WITHOUT_FRAME_GAP is defined\n */\nvoid IRsend::sendBangOlufsen(uint16_t aHeader, uint8_t aData, int_fast8_t aNumberOfRepeats, int8_t aNumberOfHeaderBits) {\n    for (int_fast8_t i = 0; i < aNumberOfRepeats + 1; ++i) {\n        sendBangOlufsenRaw((uint32_t(aHeader) << 8) | aData, aNumberOfHeaderBits + 8, i != 0);\n    }\n}\n\nvoid IRsend::sendBangOlufsenDataLink(uint32_t aHeader, uint8_t aData, int_fast8_t aNumberOfRepeats, int8_t aNumberOfHeaderBits) {\n    for (int_fast8_t i = 0; i < aNumberOfRepeats + 1; ++i) {\n        sendBangOlufsenRawDataLink((uint64_t(aHeader) << 8) | aData, aNumberOfHeaderBits + 8, i != 0, true);\n    }\n}\n\n/*\n * @param aBackToBack   If true send data back to back, which cannot be decoded if ENABLE_BEO_WITHOUT_FRAME_GAP is NOT defined\n */\nvoid IRsend::sendBangOlufsenRaw(uint32_t aRawData, int_fast8_t aBits, bool aBackToBack) {\n#if defined(USE_NO_SEND_PWM) || defined(SEND_PWM_BY_TIMER) || BEO_KHZ == 38 // BEO_KHZ == 38 is for unit test which runs the B&O protocol with 38 kHz\n\n    /*\n     * 455 kHz PWM is currently only supported with SEND_PWM_BY_TIMER defined, otherwise maximum is 180 kHz\n     */\n#  if !defined(USE_NO_SEND_PWM)\n#    if defined(SEND_PWM_BY_TIMER)\n    enableHighFrequencyIROut (BEO_KHZ);\n#    elif (BEO_KHZ == 38)\n    enableIROut (BEO_KHZ); // currently only for unit test\n#    endif\n#  endif\n\n// AGC / Start - 3 bits + first constant 0 header bit described in the official documentation\n    if (!aBackToBack) {\n        mark(BEO_IR_MARK);\n    }\n    space(BEO_PULSE_LENGTH_ZERO - BEO_IR_MARK);\n    mark(BEO_IR_MARK);\n    space(BEO_PULSE_LENGTH_ZERO - BEO_IR_MARK);\n    mark(BEO_IR_MARK);\n    space(BEO_PULSE_LENGTH_START_BIT - BEO_IR_MARK);\n\n// First bit of header is assumed to be a constant 0 to have a fixed state to begin with the equal decisions.\n// So this first 0 is treated as the last bit of AGC\n    mark(BEO_IR_MARK);\n    space(BEO_PULSE_LENGTH_ZERO - BEO_IR_MARK);\n    bool tLastBitValueWasOne = false;\n\n// Header / Data\n    uint32_t mask = 1UL << (aBits - 1);\n    for (; mask; mask >>= 1) {\n        if (tLastBitValueWasOne && !(aRawData & mask)) {\n            mark(BEO_IR_MARK);\n            space(BEO_PULSE_LENGTH_ZERO - BEO_IR_MARK);\n            tLastBitValueWasOne = false;\n        } else if (!tLastBitValueWasOne && (aRawData & mask)) {\n            mark(BEO_IR_MARK);\n            space(BEO_PULSE_LENGTH_ONE - BEO_IR_MARK);\n            tLastBitValueWasOne = true;\n        } else {\n            mark(BEO_IR_MARK);\n            space(BEO_PULSE_LENGTH_EQUAL - BEO_IR_MARK);\n        }\n    }\n\n// Stop\n    mark(BEO_IR_MARK);\n    space(BEO_PULSE_LENGTH_TRAILING_BIT - BEO_IR_MARK);\n    mark(BEO_IR_MARK);\n\n#else\n    (void) aRawData;\n    (void) aBits;\n    (void) aBackToBack;\n#endif\n}\n\n/*\n * Version with 64 bit aRawData, which can send both timings, but costs more program memory\n * @param aBackToBack   If true send data back to back, which cannot be decoded if ENABLE_BEO_WITHOUT_FRAME_GAP is NOT defined\n * @param aUseDatalinkTiming    if false it does the same as sendBangOlufsenRaw()\n */\nvoid IRsend::sendBangOlufsenRawDataLink(uint64_t aRawData, int_fast8_t aBits, bool aBackToBack, bool aUseDatalinkTiming) {\n#if defined(USE_NO_SEND_PWM) || BEO_KHZ == 38 // BEO_KHZ == 38 is for unit test which runs the B&O protocol with 38 kHz instead 0f 455 kHz\n    uint16_t tSendBEOMarkLength = aUseDatalinkTiming ? BEO_DATALINK_MARK : BEO_IR_MARK;\n\n    /*\n     * 455 kHz PWM is currently not supported, maximum is 180 kHz\n     */\n#if !defined(USE_NO_SEND_PWM)\n    enableIROut (BEO_KHZ);\n#endif\n\n// AGC / Start - 3 bits + first constant 0 header bit described in the official documentation\n    if (!aBackToBack) {\n        mark(tSendBEOMarkLength);\n    }\n    space(BEO_PULSE_LENGTH_ZERO - tSendBEOMarkLength);\n    mark(tSendBEOMarkLength);\n    space(BEO_PULSE_LENGTH_ZERO - tSendBEOMarkLength);\n    mark(tSendBEOMarkLength);\n    space(BEO_PULSE_LENGTH_START_BIT - tSendBEOMarkLength);\n\n// First bit of header is assumed to be a constant 0 to have a fixed state to begin with the equal decisions.\n// So this first 0 is treated as the last bit of AGC\n    mark(tSendBEOMarkLength);\n    space(BEO_PULSE_LENGTH_ZERO - tSendBEOMarkLength);\n    bool tLastBitValueWasOne = false;\n\n// Header / Data\n    uint32_t mask = 1UL << (aBits - 1);\n    for (; mask; mask >>= 1) {\n        if (tLastBitValueWasOne && !(aRawData & mask)) {\n            mark(tSendBEOMarkLength);\n            space(BEO_PULSE_LENGTH_ZERO - tSendBEOMarkLength);\n            tLastBitValueWasOne = false;\n        } else if (!tLastBitValueWasOne && (aRawData & mask)) {\n            mark(tSendBEOMarkLength);\n            space(BEO_PULSE_LENGTH_ONE - tSendBEOMarkLength);\n            tLastBitValueWasOne = true;\n        } else {\n            mark(tSendBEOMarkLength);\n            space(BEO_PULSE_LENGTH_EQUAL - tSendBEOMarkLength);\n        }\n    }\n\n// Stop\n    mark(tSendBEOMarkLength);\n    space(BEO_PULSE_LENGTH_TRAILING_BIT - tSendBEOMarkLength);\n    mark(tSendBEOMarkLength);\n\n#else\n    (void) aRawData;\n    (void) aBits;\n    (void) aUseDatalinkTiming;\n    (void) aBackToBack;\n#endif\n}\n\n#define BEO_MATCH_DELTA (BEO_UNIT / 2 - MICROS_PER_TICK)\nstatic bool matchBeoLength(uint16_t aMeasuredTicks, uint16_t aMatchValueMicros) {\n    const uint16_t tMeasuredMicros = aMeasuredTicks * MICROS_PER_TICK;\n    return aMatchValueMicros - BEO_MATCH_DELTA < tMeasuredMicros && tMeasuredMicros < aMatchValueMicros + BEO_MATCH_DELTA;\n}\n\nbool IRrecv::decodeBangOlufsen() {\n#if defined(ENABLE_BEO_WITHOUT_FRAME_GAP)\n    if (decodedIRData.rawlen != 6 && decodedIRData.rawlen < 36) { // 16 bits minimum\n#else\n    if (decodedIRData.rawlen < 44) { // 16 bits minimum\n#endif\n        return false;\n    }\n\n#if defined(SUPPORT_BEO_DATALINK_TIMING_FOR_DECODE)\n    uint16_t protocolMarkLength = 0; // contains BEO_IR_MARK or BEO_DATALINK_MARK depending of 4. mark received\n    uint64_t tDecodedRawData = 0;\n#else\n    uint32_t tDecodedRawData = 0;\n#endif\n    uint8_t tLastDecodedBitValue = 0; // the last start bit is assumed to be zero\n    uint8_t tPulseNumber = 0;\n    uint8_t tBitNumber = 0;\n\n    BEO_TRACE_PRINT(F(\"Pre gap: \"));\n    BEO_TRACE_PRINT(decodedIRData.initialGap * 50);\n    BEO_TRACE_PRINT(F(\" raw len: \"));\n    BEO_TRACE_PRINTLN(decodedIRData.rawlen);\n\n#if defined(ENABLE_BEO_WITHOUT_FRAME_GAP)\n    /*\n     * Check if we have the AGC part of the first frame in a row\n     */\n    if (decodedIRData.rawlen == 6) {\n        if ((matchMark(decodedIRData.rawDataPtr->rawbuf[3], BEO_IR_MARK)\n                || matchMark(decodedIRData.rawDataPtr->rawbuf[3], BEO_DATALINK_MARK))\n                && (matchSpace(decodedIRData.rawDataPtr->rawbuf[4], BEO_PULSE_LENGTH_ZERO - BEO_IR_MARK)\n                        || matchSpace(decodedIRData.rawDataPtr->rawbuf[4], BEO_PULSE_LENGTH_ZERO - BEO_DATALINK_MARK))) {\n            BEO_TRACE_PRINT(::getProtocolString(BANG_OLUFSEN));\n            BEO_TRACE_PRINTLN(F(\"B&O: AGC only part detected\"));\n        } else {\n            return false; // no B&O protocol\n        }\n    } else {\n        /*\n         * Check if leading gap is trailing bit of first frame\n         */\n        if (!matchSpace(decodedIRData.initialGap, BEO_PULSE_LENGTH_START_BIT)) {\n            BEO_TRACE_PRINT(::getProtocolString(BANG_OLUFSEN));\n            BEO_TRACE_PRINTLN(F(\": Leading gap is wrong\")); // Leading gap is trailing bit of first frame\n            return false; // no B&O protocol\n        }\n\n        if (matchMark(decodedIRData.rawDataPtr->rawbuf[1], BEO_IR_MARK)) {\n#if defined(SUPPORT_BEO_DATALINK_TIMING_FOR_DECODE)\n            protocolMarkLength = BEO_IR_MARK;\n        } else if (matchMark(decodedIRData.rawDataPtr->rawbuf[1], BEO_DATALINK_MARK)) {\n            protocolMarkLength = BEO_DATALINK_MARK;\n#endif\n        } else {\n            BEO_TRACE_PRINT(::getProtocolString(BANG_OLUFSEN));\n            BEO_TRACE_PRINTLN(F(\": mark length is wrong\"));\n            return false;\n        }\n\n        // skip first zero header bit\n        for (uint8_t tRawBufferMarkIndex = 3; tRawBufferMarkIndex < decodedIRData.rawlen; tRawBufferMarkIndex += 2) {\n#else\n    for (uint8_t tRawBufferMarkIndex = 1; tRawBufferMarkIndex < decodedIRData.rawlen; tRawBufferMarkIndex += 2) {\n#endif\n\n            uint16_t markLength = decodedIRData.rawDataPtr->rawbuf[tRawBufferMarkIndex];\n            uint16_t spaceLength = decodedIRData.rawDataPtr->rawbuf[tRawBufferMarkIndex + 1];\n\n            BEO_TRACE_PRINT(tPulseNumber);\n            BEO_TRACE_PRINT(' ');\n            BEO_TRACE_PRINT(markLength * MICROS_PER_TICK);\n            BEO_TRACE_PRINT(' ');\n            BEO_TRACE_PRINT(spaceLength * MICROS_PER_TICK);\n            BEO_TRACE_PRINT(F(\" (\"));\n            BEO_TRACE_PRINT((markLength + spaceLength) * MICROS_PER_TICK);\n            BEO_TRACE_PRINTLN(F(\") \"));\n\n#if !defined(ENABLE_BEO_WITHOUT_FRAME_GAP)\n        /*\n         * Handle the first 4 start bits\n         * Check if the 3. bit is the long start bit. If we see the long start bit earlier, synchronize bit counter.\n         */\n        if (tPulseNumber < 4) {\n            if (tPulseNumber < 2) {\n                // bit 0 and 1\n                if (matchSpace(spaceLength, BEO_PULSE_LENGTH_START_BIT - BEO_IR_MARK)) {\n                    BEO_TRACE_PRINTLN(F(\": detected long start bit -> synchronize state now\"));\n                    tPulseNumber = 2;\n                }\n            } else {\n                if (tPulseNumber == 3) {\n                    if (matchMark(markLength, BEO_IR_MARK)) {\n#if defined(SUPPORT_BEO_DATALINK_TIMING_FOR_DECODE)\n                        protocolMarkLength = BEO_IR_MARK;\n                        } else if (matchMark(markLength, BEO_DATALINK_MARK)) {\n                            protocolMarkLength = BEO_DATALINK_MARK;\n#endif\n                    } else {\n                        BEO_DEBUG_PRINT(::getProtocolString(BANG_OLUFSEN));\n                        BEO_DEBUG_PRINTLN(F(\": 4. (start) mark length is wrong\"));\n                        return false;\n                    }\n                }\n                // bit 2 and 3\n                if (!matchBeoLength(markLength + spaceLength,\n                        (tPulseNumber == 2) ? BEO_PULSE_LENGTH_START_BIT : BEO_PULSE_LENGTH_ZERO)) {\n                    BEO_DEBUG_PRINT(::getProtocolString(BANG_OLUFSEN));\n                    BEO_DEBUG_PRINTLN(F(\": Start length is wrong\"));\n                    return false;\n                }\n            }\n        } else {\n#endif\n\n            /*\n             * Decode header / data\n             * First check for length of mark\n             */\n#if defined(SUPPORT_BEO_DATALINK_TIMING_FOR_DECODE)\n            if (!matchMark(markLength, protocolMarkLength)) {\n#else\n            if (!matchMark(markLength, BEO_IR_MARK)) {\n#endif\n                BEO_DEBUG_PRINT(::getProtocolString(BANG_OLUFSEN));\n                BEO_DEBUG_PRINTLN(F(\": Mark length is wrong\"));\n                return false;\n            }\n\n            /*\n             * Check for stop after receiving at least 8 bits for data and 4 bits for header\n             */\n            if (tBitNumber > BEO_DATA_BITS + 4) {\n                if (matchBeoLength(markLength + spaceLength, BEO_PULSE_LENGTH_TRAILING_BIT)) {\n                    BEO_DEBUG_PRINT(::getProtocolString(BANG_OLUFSEN));\n                    BEO_DEBUG_PRINTLN(F(\": Trailing bit detected\"));\n                    break;\n                }\n#if !defined(ENABLE_BEO_WITHOUT_FRAME_GAP)\n                if (tRawBufferMarkIndex >= decodedIRData.rawlen - 3) { // (rawlen - 3) is index of trailing bit mark\n                    BEO_DEBUG_PRINT(::getProtocolString(BANG_OLUFSEN));\n                    BEO_DEBUG_PRINTLN(F(\": End of buffer, but no trailing bit detected\"));\n                    return false;\n                }\n#endif\n            }\n\n            /*\n             * Decode bit\n             */\n            if (tLastDecodedBitValue == 0 && matchBeoLength(markLength + spaceLength, BEO_PULSE_LENGTH_ONE)) {\n                tLastDecodedBitValue = 1;\n            } else if (tLastDecodedBitValue == 1 && matchBeoLength(markLength + spaceLength, BEO_PULSE_LENGTH_ZERO)) {\n                tLastDecodedBitValue = 0;\n            } else if (!matchBeoLength(markLength + spaceLength, BEO_PULSE_LENGTH_EQUAL)) {\n                BEO_DEBUG_PRINT(::getProtocolString(BANG_OLUFSEN));\n                BEO_DEBUG_PRINT(F(\": Index=\"));\n                BEO_DEBUG_PRINT(tRawBufferMarkIndex);\n                BEO_DEBUG_PRINT(F(\" Length \"));\n                BEO_DEBUG_PRINT((markLength + spaceLength) * MICROS_PER_TICK);\n                BEO_DEBUG_PRINTLN(F(\" is wrong\"));\n                return false;\n            }\n            tDecodedRawData <<= 1;\n            tDecodedRawData |= tLastDecodedBitValue;\n            ++tBitNumber;\n            BEO_TRACE_PRINT(F(\"Bits \"));\n            BEO_TRACE_PRINT(tBitNumber);\n            BEO_TRACE_PRINT(F(\" \"));\n            BEO_TRACE_PRINT(uint32_t(tDecodedRawData >> BEO_DATA_BITS), HEX);\n            BEO_TRACE_PRINT(F(\" \"));\n            BEO_TRACE_PRINTLN(uint8_t(tDecodedRawData & ((1 << BEO_DATA_BITS) - 1)), HEX);\n            // End of bit decode\n#if !defined(ENABLE_BEO_WITHOUT_FRAME_GAP)\n        }\n\n#else\n            /*\n             * Check for last bit after decoding it\n             */\n            if (tRawBufferMarkIndex >= decodedIRData.rawlen - 3) { // (rawlen - 3) is index of last bit mark\n                BEO_TRACE_PRINT(::getProtocolString(BANG_OLUFSEN));\n                BEO_TRACE_PRINTLN(F(\": Last bit reached\"));\n                break;\n            }\n#endif\n\n            ++tPulseNumber;\n        }\n#if defined(ENABLE_BEO_WITHOUT_FRAME_GAP)\n    }\n#endif\n\n    decodedIRData.protocol = BANG_OLUFSEN;\n    decodedIRData.address = tDecodedRawData >> BEO_DATA_BITS;              // lower header tBitNumber\n    decodedIRData.command = tDecodedRawData & ((1 << BEO_DATA_BITS) - 1);  // lower 8 tBitNumber\n    decodedIRData.extra = tDecodedRawData >> (BEO_DATA_BITS + 16);         // upper header tBitNumber\n    decodedIRData.numberOfBits = tBitNumber;\n    decodedIRData.flags = IRDATA_FLAGS_IS_MSB_FIRST;\n    decodedIRData.decodedRawData = tDecodedRawData;\n\n    return true;\n}\n#endif // _IR_BANG_OLUFSEN_HPP\n"
    }, {
      filename: "src/IRremote.h",
      code: "/**\n * @file IRremote.h\n *\n * @brief Stub for backward compatibility\n */\n\n#ifndef IRremote_h\n#define IRremote_h\n\n#include \"IRremote.hpp\"\n\n#warning Thank you for using the IRremote library!\n#warning It seems, that you are using a old version 2.0 code / example.\n#warning This version is no longer supported!\n#warning Please use one of the new code examples from the library  available at \"File > Examples > Examples from Custom Libraries / IRremote\".\n#warning Or downgrade your library to version 2.6.0.\n#warning Start with the SimpleReceiver or SimpleSender example.\n#warning The examples are documented here: https://github.com/Arduino-IRremote/Arduino-IRremote#examples-for-this-library\n#warning A guide how to convert your 2.0 program is here: https://github.com/Arduino-IRremote/Arduino-IRremote#converting-your-2x-program-to-the-4x-version\n\n/**********************************************************************************************************************\n * The OLD and DEPRECATED decode function with parameter aResults, kept for backward compatibility to old 2.0 tutorials\n * This function calls the old MSB first decoders and fills only the 3 variables:\n * aResults->value\n * aResults->bits\n * aResults->decode_type\n * It prints a message on the first call.\n **********************************************************************************************************************/\nbool IRrecv::decode(decode_results *aResults) {\n    static bool sMessageWasSent = false;\n    if (!sMessageWasSent) {\n        Serial.println(F(\"**************************************************************************************************\"));\n        Serial.println(F(\"Thank you for using the IRremote library!\"));\n        Serial.println(F(\"It seems, that you are using a old version 2.0 code / example.\"));\n        Serial.println(F(\"This version is no longer supported!\"));\n        Serial.println(F(\"Please use one of the new code examples from the library,\"));\n        Serial.println(F(\" available at \\\"File > Examples > Examples from Custom Libraries / IRremote\\\".\"));\n        Serial.println(F(\"Or downgrade your library to version 2.6.0.\"));\n        Serial.println();\n        Serial.println(F(\"Start with the SimpleReceiver or SimpleSender example.\"));\n        Serial.println();\n        Serial.println(F(\"The examples are documented here:\"));\n        Serial.println(F(\" https://github.com/Arduino-IRremote/Arduino-IRremote#examples-for-this-library\"));\n        Serial.println(F(\"A guide how to convert your 2.0 program is here:\"));\n        Serial.println(F(\" https://github.com/Arduino-IRremote/Arduino-IRremote#converting-your-2x-program-to-the-4x-version\"));\n        Serial.println();\n        Serial.println(F(\"Thanks\"));\n        Serial.println(F(\"**************************************************************************************************\"));\n        Serial.println();\n        Serial.println();\n        sMessageWasSent = true;\n    }\n    return decode_old(aResults);\n}\n\n#endif // IRremote_h\n#pragma once\n\n"
    }, {
      filename: "src/ir_Template.hpp",
      code: "/*\n Assuming the protocol we are adding is for the (imaginary) manufacturer:  Shuzu\n\n Our fantasy protocol is a standard protocol, so we can use this standard\n template without too much work. Some protocols are quite unique and will require\n considerably more work in this file! It is way beyond the scope of this text to\n explain how to reverse engineer \"unusual\" IR protocols. But, unless you own an\n oscilloscope, the starting point is probably to use the ReceiveDump.ino sketch and\n try to spot the pattern!\n\n Before you start, make sure the IR library is working OK:\n # Open up the Arduino IDE\n # Load up the ReceiveDump.ino example sketch\n # Run it\n # Analyze your data to have an idea, what is the header timing, the bit timing, the address, the command and the checksum of your protocol.\n\n Now we can start to add our new protocol...\n\n 1. Copy this file to : ir_<YourProtocolName>.hpp\n\n 2. Replace all occurrences of \"SHUZU\" with the name of your protocol.\n\n 3. Tweak the #defines to suit your protocol.\n\n 4. If you're lucky, tweaking the #defines will make the decode and send() function\n work.\n\n You have now written the code to support your new protocol!\n\n To integrate it into the IRremote library, you must search for \"BOSEWAVE\"\n and add your protocol in the same way as it is already done for BOSEWAVE.\n\n You have to change the following files:\n IRSend.hpp     IRsend::write(IRData *aIRSendData + int_fast8_t aNumberOfRepeats)\n IRProtocol.h   Add it to decode_type_t\n IRReceive.hpp  IRrecv::decode() + printActiveIRProtocols(Print *aSerial) + getProtocolString(decode_type_t aProtocol)\n IRremote.hpp   At 3 occurrences of DECODE_XXX\n IRremoteInt.h  Add the declaration of the decode and send function\n\n Now open the Arduino IDE, load up the ReceiveDump.ino sketch, and run it.\n Hopefully it will compile and upload.\n If it doesn't, you've done something wrong. Check your work and look carefully at the error messages.\n\n If you get this far, I will assume you have successfully added your new protocol\n\n At last, delete this giant instructional comment.\n\n If you want us to include your work in the library so others may benefit\n from your hard work, you have to extend the examples\n IRremoteInfo, SmallReceiver, simple Receiver, SendDemo and UnitTest too\n as well as the Readme.md\n It is not an act, but required for completeness.\n\n Thanks\n The maintainer\n */\n\n/*\n * ir_Shuzu.hpp\n *\n *  Contains functions for receiving and sending Shuzu IR Protocol ...\n *\n *  Copyright (C) 2022  Shuzu Guru\n *  shuzu.guru@gmail.com\n *\n *  This file is part of Arduino-IRremote https://github.com/Arduino-IRremote/Arduino-IRremote.\n *\n ************************************************************************************\n * MIT License\n *\n * Copyright (c) 2022 Unknown Contributor :-)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is furnished\n * to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n ************************************************************************************\n */\n#ifndef _IR_SHUZU_HPP\n#define _IR_SHUZU_HPP\n\n//==============================================================================\n//\n//\n//                              S H U Z U\n//\n//\n//==============================================================================\n// see: https://www....\n\n// LSB first, 1 start bit + 16 bit address + 8 bit command + 1 stop bit.\n#define SHUZU_ADDRESS_BITS      16 // 16 bit address\n#define SHUZU_COMMAND_BITS      8 // Command\n\n#define SHUZU_BITS              (SHUZU_ADDRESS_BITS + SHUZU_COMMAND_BITS) // The number of bits in the protocol\n#define SHUZU_UNIT              560               // All timings are in microseconds\n\n#define SHUZU_HEADER_MARK       (16 * SHUZU_UNIT) // The length of the Header:Mark\n#define SHUZU_HEADER_SPACE      (8 * SHUZU_UNIT)  // The length of the Header:Space\n\n#define SHUZU_BIT_MARK          SHUZU_UNIT        // The length of a Bit:Mark\n#define SHUZU_ONE_SPACE         (3 * SHUZU_UNIT)  // The length of a Bit:Space for 1's\n#define SHUZU_ZERO_SPACE        SHUZU_UNIT        // The length of a Bit:Space for 0's\n\n#define SHUZU_REPEAT_HEADER_SPACE (4 * SHUZU_UNIT)  // 2250\n\n#define SHUZU_REPEAT_PERIOD     110000            // From start to start\n#define SHUZU_REPEAT_SPACE      45000             // SHUZU_REPEAT_PERIOD - default frame duration. Used for repeat detection.\n\n#define SHUZU_OTHER             1234  // Other things you may need to define\n\n// use BOSEWAVE, we have no SHUZU code\nstruct PulseDistanceWidthProtocolConstants ShuzuProtocolConstants = { BOSEWAVE, 38, SHUZU_HEADER_MARK, SHUZU_HEADER_SPACE,\nSHUZU_BIT_MARK, SHUZU_ONE_SPACE, SHUZU_BIT_MARK, SHUZU_ZERO_SPACE, PROTOCOL_IS_LSB_FIRST, (SHUZU_REPEAT_PERIOD\n        / MICROS_IN_ONE_MILLI), NULL };\n\n/************************************\n * Start of send and decode functions\n ************************************/\n\nvoid IRsend::sendShuzu(uint16_t aAddress, uint8_t aCommand, int_fast8_t aNumberOfRepeats) {\n\n    sendPulseDistanceWidth(&ShuzuProtocolConstants, (uint32_t) aCommand << 8 | aCommand, SHUZU_BITS, aNumberOfRepeats);\n}\n\nbool IRrecv::decodeShuzu() {\n    /*\n     * First check for right data length\n     * Next check start bit / header\n     * Next try the decode\n     */\n    // Check we have the right amount of data (28). The +4 is for initial gap, start bit mark and space + stop bit mark\n    if (decodedIRData.rawDataPtr->rawlen != (2 * SHUZU_BITS) + 4) {\n        // no debug output, since this check is mainly to determine the received protocol\n        return false;\n    }\n\n    // Check header\n    if (!checkHeader(&ShuzuProtocolConstants)) {\n        return false;\n    }\n\n    // Decode\n    if (!decodePulseDistanceData(&ShuzuProtocolConstants, SHUZU_BITS)) {\n        IR_DEBUG_PRINT(F(\"Shuzu: \"));\n        IR_DEBUG_PRINTLN(F(\"Decode failed\"));\n        return false;\n    }\n\n    // Success, interpret raw data\n//    decodedIRData.flags = IRDATA_FLAGS_IS_LSB_FIRST; // Not required, since this is the start value\n    decodedIRData.command = decodedIRData.decodedRawData >> SHUZU_ADDRESS_BITS;  // upper 8 bits of LSB first value\n    decodedIRData.address = decodedIRData.decodedRawData & 0xFFFF;    // lowest 16 bit of LSB first value\n    decodedIRData.numberOfBits = SHUZU_BITS;\n    decodedIRData.protocol = BOSEWAVE; // we have no SHUZU code\n\n    //Check for repeat\n    checkForRepeatSpaceAndSetFlag(SHUZU_REPEAT_SPACE / MICROS_IN_ONE_MILLI);\n\n    return true;\n}\n#endif // _IR_SHUZU_HPP\n"
    }, {
      filename: "src/ir_BoseWave.hpp",
      code: "/*\n * ir_BoseWave.cpp\n *\n *  Contains functions for receiving and sending Bose IR Protocol\n *\n *  This file is part of Arduino-IRremote https://github.com/Arduino-IRremote/Arduino-IRremote.\n *\n */\n#ifndef _IR_BOSEWAVE_HPP\n#define _IR_BOSEWAVE_HPP\n\n#if defined(DEBUG) && !defined(LOCAL_DEBUG)\n#define LOCAL_DEBUG\n#else\n//#define LOCAL_DEBUG // This enables debug output only for this file\n#endif\n\n/** \\addtogroup Decoder Decoders and encoders for different protocols\n * @{\n */\n//==============================================================================\n//                           BBBB    OOO    SSSS  EEEEE\n//                           B   B  O   O  S      E\n//                           BB B   O   O   SSS   EEEE\n//                           B   B  O   O      S  E\n//                           BBBB    OOO   SSSS   EEEEE\n//==============================================================================\n// see http://lirc.sourceforge.net/remotes/bose/WAVERADIO\n// see: https://www.mikrocontroller.net/articles/IRMP_-_english#BOSE\n//\n// Support for Bose Wave Radio CD initially provided by https://github.com/uvotguy.\n//\n// As seen on my trusty oscilloscope, there is no repeat code.  Instead, when I\n// press and hold a button on my remote, it sends a command, makes a 51.2ms space,\n// and resends the command, etc, etc.\n// LSB first, 1 start bit + 8 bit data + 8 bit inverted data + 1 stop bit.\n#define BOSEWAVE_BITS             16 // Command and inverted command\n\n#define BOSEWAVE_HEADER_MARK    1014    // 1014 are 39 clock periods (I counted 3 times!)\n#define BOSEWAVE_HEADER_SPACE   1468    // 1468(measured), 1456 are 56 clock periods\n#define BOSEWAVE_BIT_MARK        520    // 520 are 20 clock periods\n#define BOSEWAVE_ZERO_SPACE      468    // 468 are 18 clock periods\n#define BOSEWAVE_ONE_SPACE      1468    // 1468(measured), 1456 are 56 clock periods\n\n#define BOSEWAVE_REPEAT_PERIOD              75000\n#define BOSEWAVE_REPEAT_DISTANCE            50000\n#define BOSEWAVE_MAXIMUM_REPEAT_DISTANCE    62000\n\nstruct PulseDistanceWidthProtocolConstants BoseWaveProtocolConstants = { BOSEWAVE, BOSEWAVE_KHZ, BOSEWAVE_HEADER_MARK,\nBOSEWAVE_HEADER_SPACE, BOSEWAVE_BIT_MARK, BOSEWAVE_ONE_SPACE, BOSEWAVE_BIT_MARK, BOSEWAVE_ZERO_SPACE, PROTOCOL_IS_LSB_FIRST\n       , (BOSEWAVE_REPEAT_PERIOD / MICROS_IN_ONE_MILLI), NULL };\n\n/************************************\n * Start of send and decode functions\n ************************************/\n\nvoid IRsend::sendBoseWave(uint8_t aCommand, int_fast8_t aNumberOfRepeats) {\n\n    // send 8 command bits and then 8 inverted command bits LSB first\n    uint16_t tData = ((~aCommand) << 8) | aCommand;\n    sendPulseDistanceWidth(&BoseWaveProtocolConstants, tData, BOSEWAVE_BITS, aNumberOfRepeats);\n}\n\nbool IRrecv::decodeBoseWave() {\n\n    if (!checkHeader(&BoseWaveProtocolConstants)) {\n        return false;\n    }\n\n    // Check we have enough data +4 for initial gap, start bit mark and space + stop bit mark\n    if (decodedIRData.rawlen != (2 * BOSEWAVE_BITS) + 4) {\n        IR_DEBUG_PRINT(F(\"Bose: \"));\n        IR_DEBUG_PRINT(F(\"Data length=\"));\n        IR_DEBUG_PRINT(decodedIRData.rawlen);\n        IR_DEBUG_PRINTLN(F(\" is not 36\"));\n        return false;\n    }\n\n    if (!decodePulseDistanceWidthData(&BoseWaveProtocolConstants, BOSEWAVE_BITS)) {\n#if defined(LOCAL_DEBUG)\n        Serial.print(F(\"Bose: \"));\n        Serial.println(F(\"Decode failed\"));\n#endif\n        return false;\n    }\n\n    // Stop bit\n    if (!matchMark(decodedIRData.rawDataPtr->rawbuf[3 + (2 * BOSEWAVE_BITS)], BOSEWAVE_BIT_MARK)) {\n#if defined(LOCAL_DEBUG)\n        Serial.print(F(\"Bose: \"));\n        Serial.println(F(\"Stop bit mark length is wrong\"));\n#endif\n        return false;\n    }\n\n    // Success\n//    decodedIRData.flags = IRDATA_FLAGS_IS_LSB_FIRST; // Not required, since this is the start value\n    uint16_t tDecodedValue = decodedIRData.decodedRawData;\n    uint8_t tCommandNotInverted = tDecodedValue & 0xFF; // comes first and is in the lower bits (LSB first :-))\n    uint8_t tCommandInverted = tDecodedValue >> 8;\n    // parity check for command. Use this variant to avoid compiler warning \"comparison of promoted ~unsigned with unsigned [-Wsign-compare]\"\n    if ((tCommandNotInverted ^ tCommandInverted) != 0xFF) {\n#if defined(LOCAL_DEBUG)\n        Serial.print(F(\"Bose: \"));\n        Serial.println(F(\"Command and inverted command check failed\"));\n#endif\n        return false;\n    }\n    decodedIRData.command = tCommandNotInverted;\n    decodedIRData.numberOfBits = BOSEWAVE_BITS;\n    decodedIRData.protocol = BOSEWAVE;\n\n    // check for repeat\n    checkForRepeatSpaceTicksAndSetFlag(BOSEWAVE_MAXIMUM_REPEAT_DISTANCE / MICROS_PER_TICK);\n\n    return true;\n}\n\n/** @}*/\n#if defined(LOCAL_DEBUG)\n#undef LOCAL_DEBUG\n#endif\n#endif // _IR_BOSEWAVE_HPP\n"
    }, {
      filename: "src/IRremote.hpp",
      code: "/**\n * @file IRremote.hpp\n *\n * @brief Public API to the library.\n *\n * @code\n * !!! All the macro values defined here can be overwritten with values,    !!!\n * !!! the user defines in its source code BEFORE the #include <IRremote.hpp> !!!\n * @endcode\n *\n * This file is part of Arduino-IRremote https://github.com/Arduino-IRremote/Arduino-IRremote.\n *\n ************************************************************************************\n * MIT License\n *\n * Copyright (c) 2015-2023 Ken Shirriff http://www.righto.com, Rafi Khan, Armin Joachimsmeyer\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is furnished\n * to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n ************************************************************************************\n *\n * For Ken Shiriffs original blog entry, see http://www.righto.com/2009/08/multi-protocol-infrared-remote-library.html\n * Initially influenced by:\n * http://www.arduino.cc/cgi-bin/yabb2/YaBB.pl?num=1210243556\n * and http://zovirl.com/2008/11/12/building-a-universal-remote-with-an-arduino/\n */\n\n/*\n * This library can be configured at compile time by the following options / macros:\n * For more details see: https://github.com/Arduino-IRremote/Arduino-IRremote#compile-options--macros-for-this-library\n *\n * - RAW_BUFFER_LENGTH                  Buffer size of raw input buffer. Must be even! 100 is sufficient for *regular* protocols of up to 48 bits.\n * - IR_SEND_PIN                        If specified (as constant), reduces program size and improves send timing for AVR.\n * - SEND_PWM_BY_TIMER                  Disable carrier PWM generation in software and use (restricted) hardware PWM.\n * - USE_NO_SEND_PWM                    Use no carrier PWM, just simulate an **active low** receiver signal. Overrides SEND_PWM_BY_TIMER definition.\n * - USE_OPEN_DRAIN_OUTPUT_FOR_SEND_PIN Use or simulate open drain output mode at send pin. Attention, active state of open drain is LOW, so connect the send LED between positive supply and send pin!\n * - EXCLUDE_EXOTIC_PROTOCOLS           If activated, BANG_OLUFSEN, BOSEWAVE, WHYNTER, FAST and LEGO_PF are excluded in decode() and in sending with IrSender.write().\n * - EXCLUDE_UNIVERSAL_PROTOCOLS        If activated, the universal decoder for pulse distance protocols and decodeHash (special decoder for all protocols) are excluded in decode().\n * - DECODE_*                           Selection of individual protocols to be decoded. See below.\n * - MARK_EXCESS_MICROS                 Value is subtracted from all marks and added to all spaces before decoding, to compensate for the signal forming of different IR receiver modules.\n * - RECORD_GAP_MICROS                  Minimum gap between IR transmissions, to detect the end of a protocol.\n * - FEEDBACK_LED_IS_ACTIVE_LOW         Required on some boards (like my BluePill and my ESP8266 board), where the feedback LED is active low.\n * - NO_LED_FEEDBACK_CODE               This completely disables the LED feedback code for send and receive.\n * - IR_INPUT_IS_ACTIVE_HIGH            Enable it if you use a RF receiver, which has an active HIGH output signal.\n * - IR_SEND_DUTY_CYCLE_PERCENT         Duty cycle of IR send signal.\n * - MICROS_PER_TICK                    Resolution of the raw input buffer data. Corresponds to 2 pulses of each 26.3 us at 38 kHz.\n * - IR_USE_AVR_TIMER*                  Selection of timer to be used for generating IR receiving sample interval.\n */\n\n#ifndef _IR_REMOTE_HPP\n#define _IR_REMOTE_HPP\n\n#include \"IRVersion.h\"\n\n// activate it for all cores that does not use the -flto flag, if you get false error messages regarding begin() during compilation.\n//#define SUPPRESS_ERROR_MESSAGE_FOR_BEGIN\n\n/*\n * If activated, BANG_OLUFSEN, BOSEWAVE, MAGIQUEST, WHYNTER, FAST and LEGO_PF are excluded in decoding and in sending with IrSender.write\n */\n//#define EXCLUDE_EXOTIC_PROTOCOLS\n/****************************************************\n *                     PROTOCOLS\n ****************************************************/\n/*\n * Supported IR protocols\n * Each protocol you include costs memory and, during decode, costs time\n * Copy the lines with the protocols you need in your program before the  #include <IRremote.hpp> line\n * See also SimpleReceiver example\n */\n\n#if !defined(NO_DECODER) // for sending raw only\n#  if (!(defined(DECODE_DENON) || defined(DECODE_JVC) || defined(DECODE_KASEIKYO) \\\n|| defined(DECODE_PANASONIC) || defined(DECODE_LG) || defined(DECODE_NEC) || defined(DECODE_ONKYO) || defined(DECODE_SAMSUNG) \\\n|| defined(DECODE_SONY) || defined(DECODE_RC5) || defined(DECODE_RC6) \\\n|| defined(DECODE_DISTANCE_WIDTH) || defined(DECODE_HASH) || defined(DECODE_BOSEWAVE) \\\n|| defined(DECODE_LEGO_PF) || defined(DECODE_MAGIQUEST) || defined(DECODE_FAST) || defined(DECODE_WHYNTER)))\n/*\n * If no protocol is explicitly enabled, we enable all protocols\n */\n#define DECODE_DENON        // Includes Sharp\n#define DECODE_JVC\n#define DECODE_KASEIKYO\n#define DECODE_PANASONIC    // alias for DECODE_KASEIKYO\n#define DECODE_LG\n#define DECODE_NEC          // Includes Apple and Onkyo\n#define DECODE_SAMSUNG\n#define DECODE_SONY\n#define DECODE_RC5\n#define DECODE_RC6\n\n#    if !defined(EXCLUDE_EXOTIC_PROTOCOLS) // saves around 2000 bytes program memory\n#define DECODE_BOSEWAVE\n#define DECODE_LEGO_PF\n#define DECODE_MAGIQUEST // It modifies the RAW_BUFFER_LENGTH from 100 to 112\n#define DECODE_WHYNTER\n#define DECODE_FAST\n#    endif\n\n#    if !defined(EXCLUDE_UNIVERSAL_PROTOCOLS)\n#define DECODE_DISTANCE_WIDTH     // universal decoder for pulse distance width protocols - requires up to 750 bytes additional program memory\n#define DECODE_HASH         // special decoder for all protocols - requires up to 250 bytes additional program memory\n#    endif\n#  endif\n#endif // !defined(NO_DECODER)\n\n//#define DECODE_BEO // Bang & Olufsen protocol always must be enabled explicitly. It prevents decoding of SONY!\n\n#if defined(DECODE_NEC) && !(~(~DECODE_NEC + 0) == 0 && ~(~DECODE_NEC + 1) == 1)\n#warning \"The macros DECODE_XXX no longer require a value. Decoding is now switched by defining / non defining the macro.\"\n#endif\n\n//#define DEBUG // Activate this for lots of lovely debug output from the IRremote core.\n\n/****************************************************\n *                    RECEIVING\n ****************************************************/\n/**\n * MARK_EXCESS_MICROS is subtracted from all marks and added to all spaces before decoding,\n * to compensate for the signal forming of different IR receiver modules\n * For Vishay TSOP*, marks tend to be too long and spaces tend to be too short.\n * If you set MARK_EXCESS_MICROS to approx. 50us then the TSOP4838 works best.\n * At 100us it also worked, but not as well.\n * Set MARK_EXCESS to 100us and the VS1838 doesn't work at all.\n *\n * The right value is critical for IR codes using short pulses like Denon / Sharp / Lego\n *\n *  Observed values:\n *  Delta of each signal type is around 50 up to 100 and at low signals up to 200. TSOP is better, especially at low IR signal level.\n *  VS1838      Mark Excess -50 at low intensity to +50 us at high intensity\n *  TSOP31238   Mark Excess 0 to +50\n */\n#if !defined(MARK_EXCESS_MICROS)\n// To change this value, you simply can add a line #define \"MARK_EXCESS_MICROS <My_new_value>\" in your ino file before the line \"#include <IRremote.hpp>\"\n#define MARK_EXCESS_MICROS    20\n#endif\n\n/**\n * Minimum gap between IR transmissions, to detect the end of a protocol.\n * Must be greater than any space of a protocol e.g. the NEC header space of 4500 us.\n * Must be smaller than any gap between a command and a repeat; e.g. the retransmission gap for Sony is around 15 ms for Sony20 protocol.\n * Keep in mind, that this is the delay between the end of the received command and the start of decoding.\n */\n#if !defined(RECORD_GAP_MICROS)\n// To change this value, you simply can add a line #define \"RECORD_GAP_MICROS <My_new_value>\" in your ino file before the line \"#include <IRremote.hpp>\"\n#define RECORD_GAP_MICROS   8000 // RECS80 (https://www.mikrocontroller.net/articles/IRMP#RECS80) 1 bit space is 7500¬µs , NEC header space is 4500\n#endif\n/**\n * Threshold for warnings at printIRResult*() to report about changing the RECORD_GAP_MICROS value to a higher value.\n */\n#if !defined(RECORD_GAP_MICROS_WARNING_THRESHOLD)\n// To change this value, you simply can add a line #define \"RECORD_GAP_MICROS_WARNING_THRESHOLD <My_new_value>\" in your ino file before the line \"#include <IRremote.hpp>\"\n#define RECORD_GAP_MICROS_WARNING_THRESHOLD   15000\n#endif\n\n/** Minimum gap between IR transmissions, in MICROS_PER_TICK */\n#define RECORD_GAP_TICKS    (RECORD_GAP_MICROS / MICROS_PER_TICK) // 100\n\n/*\n * Activate this line if your receiver has an external output driver transistor / \"inverted\" output\n */\n//#define IR_INPUT_IS_ACTIVE_HIGH\n#if defined(IR_INPUT_IS_ACTIVE_HIGH)\n// IR detector output is active high\n#define INPUT_MARK   1 ///< Sensor output for a mark (\"flash\")\n#else\n// IR detector output is active low\n#define INPUT_MARK   0 ///< Sensor output for a mark (\"flash\")\n#endif\n/****************************************************\n *                     SENDING\n ****************************************************/\n/**\n * Define to disable carrier PWM generation in software and use (restricted) hardware PWM.\n */\n//#define SEND_PWM_BY_TIMER // restricts send pin on many platforms to fixed pin numbers\n#if (defined(ESP32) || defined(ARDUINO_ARCH_RP2040) || defined(PARTICLE)) || defined(ARDUINO_ARCH_MBED)\n#  if !defined(SEND_PWM_BY_TIMER)\n#define SEND_PWM_BY_TIMER       // the best and default method for ESP32 etc.\n#warning INFO: For ESP32, RP2040, mbed and particle boards SEND_PWM_BY_TIMER is enabled by default, since we have the resources and timing is more exact than the software generated one. If this is not intended, deactivate the line in IRremote.hpp over this warning message in file IRremote.hpp.\n#  endif\n#else\n#  if defined(SEND_PWM_BY_TIMER)\n#    if defined(IR_SEND_PIN)\n#undef IR_SEND_PIN // to avoid warning 3 lines later\n#warning Since SEND_PWM_BY_TIMER is defined, the existing value of IR_SEND_PIN is discarded and replaced by the value determined by timer used for PWM generation\n#    endif\n#define IR_SEND_PIN     DeterminedByTimer // must be set here, since it is evaluated at IRremoteInt.h, before the include of private/IRTimer.hpp\n#  endif\n#endif\n\n/**\n * Define to use no carrier PWM, just simulate an active low receiver signal.\n */\n//#define USE_NO_SEND_PWM\n#if defined(SEND_PWM_BY_TIMER) && defined(USE_NO_SEND_PWM)\n#warning \"SEND_PWM_BY_TIMER and USE_NO_SEND_PWM are both defined -> undefine SEND_PWM_BY_TIMER now!\"\n#undef SEND_PWM_BY_TIMER // USE_NO_SEND_PWM overrides SEND_PWM_BY_TIMER\n#endif\n\n/**\n * Define to use or simulate open drain output mode at send pin.\n * Attention, active state of open drain is LOW, so connect the send LED between positive supply and send pin!\n */\n//#define USE_OPEN_DRAIN_OUTPUT_FOR_SEND_PIN\n#if defined(USE_OPEN_DRAIN_OUTPUT_FOR_SEND_PIN) && !defined(OUTPUT_OPEN_DRAIN)\n#warning Pin mode OUTPUT_OPEN_DRAIN is not supported on this platform -> mimick open drain mode by switching between INPUT and OUTPUT mode.\n#endif\n/**\n * This amount is subtracted from the on-time of the pulses generated for software PWM generation.\n * It should be the time used for digitalWrite(sendPin, LOW) and the call to delayMicros()\n * Measured value for Nano @16MHz is around 3000, for Bluepill @72MHz is around 700, for Zero 3600\n */\n#if !defined(PULSE_CORRECTION_NANOS)\n#  if defined(F_CPU)\n// To change this value, you simply can add a line #define \"PULSE_CORRECTION_NANOS <My_new_value>\" in your ino file before the line \"#include <IRremote.hpp>\"\n#define PULSE_CORRECTION_NANOS (48000L / (F_CPU/MICROS_IN_ONE_SECOND)) // 3000 @16MHz, 666 @72MHz\n#  else\n#define PULSE_CORRECTION_NANOS 600\n#  endif\n#endif\n\n/**\n * Duty cycle in percent for sent signals.\n */\n#if ! defined(IR_SEND_DUTY_CYCLE_PERCENT)\n#define IR_SEND_DUTY_CYCLE_PERCENT 30 // 30 saves power and is compatible to the old existing code\n#endif\n\n/**\n * microseconds per clock interrupt tick\n */\n#if ! defined(MICROS_PER_TICK)\n#define MICROS_PER_TICK    50L // must be with L to get 32 bit results if multiplied with rawbuf[] content.\n#endif\n\n#define MILLIS_IN_ONE_SECOND 1000L\n#define MICROS_IN_ONE_SECOND 1000000L\n#define MICROS_IN_ONE_MILLI 1000L\n\n#include \"IRremoteInt.h\"\n/*\n * We always use digitalWriteFast() and digitalReadFast() functions to have a consistent mapping for pins.\n * For most non AVR cpu's, it is just a mapping to digitalWrite() and digitalRead() functions.\n */\n#include \"digitalWriteFast.h\"\n\n#if !defined(USE_IRREMOTE_HPP_AS_PLAIN_INCLUDE)\n#include \"private/IRTimer.hpp\"  // defines IR_SEND_PIN for AVR and SEND_PWM_BY_TIMER\n\n#  if !defined(NO_LED_FEEDBACK_CODE)\n#    if !defined(LED_BUILTIN)\n/*\n * print a warning\n */\n#warning INFO: No definition for LED_BUILTIN found -> default LED feedback is disabled.\n#    endif\n#include \"IRFeedbackLED.hpp\"\n#  else\nvoid disableLEDFeedback() {}; // dummy function for examples\n#  endif\n\n#include \"LongUnion.h\" // used in most decoders\n\n/*\n * Include the sources here to enable compilation with macro values set by user program.\n */\n#include \"IRProtocol.hpp\" // must be first, it includes definition for PrintULL (unsigned long long)\n#if !defined(DISABLE_CODE_FOR_RECEIVER)\n#include \"IRReceive.hpp\"\n#endif\n#include \"IRSend.hpp\"\n\n/*\n * Include the sources of all decoders here to enable compilation with macro values set by user program.\n */\n#include \"ir_BangOlufsen.hpp\"\n#include \"ir_BoseWave.hpp\"\n#include \"ir_Denon.hpp\"\n#include \"ir_JVC.hpp\"\n#include \"ir_Kaseikyo.hpp\"\n#include \"ir_Lego.hpp\"\n#include \"ir_LG.hpp\"\n#include \"ir_MagiQuest.hpp\"\n#include \"ir_NEC.hpp\"\n#include \"ir_RC5_RC6.hpp\"\n#include \"ir_Samsung.hpp\"\n#include \"ir_Sony.hpp\"\n#include \"ir_FAST.hpp\"\n#include \"ir_Others.hpp\"\n#include \"ir_Pronto.hpp\" // pronto is an universal decoder and encoder\n#  if defined(DECODE_DISTANCE_WIDTH)     // universal decoder for pulse distance width protocols - requires up to 750 bytes additional program memory\n#include <ir_DistanceWidthProtocol.hpp>\n#  endif\n#endif // #if !defined(USE_IRREMOTE_HPP_AS_PLAIN_INCLUDE)\n\n/**\n * Macros for legacy compatibility\n */\n#define RAWBUF  101  // Maximum length of raw duration buffer\n#define REPEAT 0xFFFFFFFF\n#define USECPERTICK MICROS_PER_TICK\n#define MARK_EXCESS MARK_EXCESS_MICROS\n\n#endif // _IR_REMOTE_HPP\n"
    }, {
      filename: "src/TinyIRSender.hpp",
      code: "/*\n *  TinyIRSender.hpp\n *\n *  Sends IR protocol data of NEC and FAST protocol using bit banging.\n *  NEC is the protocol of most cheap remote controls for Arduino.\n *\n * The FAST protocol is a proprietary modified JVC protocol without address, with parity and with a shorter header.\n *  FAST Protocol characteristics:\n * - Bit timing is like NEC or JVC\n * - The header is shorter, 3156 vs. 12500\n * - No address and 16 bit data, interpreted as 8 bit command and 8 bit inverted command,\n *     leading to a fixed protocol length of (6 + (16 * 3) + 1) * 526 = 55 * 526 = 28930 microseconds or 29 ms.\n * - Repeats are sent as complete frames but in a 50 ms period / with a 21 ms distance.\n *\n *\n *  This file is part of IRMP https://github.com/IRMP-org/IRMP.\n *  This file is part of Arduino-IRremote https://github.com/Arduino-IRremote/Arduino-IRremote.\n *\n ************************************************************************************\n * MIT License\n *\n * Copyright (c) 2022-2024 Armin Joachimsmeyer\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is furnished\n * to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n ************************************************************************************\n */\n\n#ifndef _TINY_IR_SENDER_HPP\n#define _TINY_IR_SENDER_HPP\n\n#include <Arduino.h>\n\n//#define ENABLE_NEC2_REPEATS // Instead of sending / receiving the NEC special repeat code, send / receive the original frame for repeat.\n\n#if defined(DEBUG) && !defined(LOCAL_DEBUG)\n#define LOCAL_DEBUG\n#else\n//#define LOCAL_DEBUG // This enables debug output only for this file\n#endif\n#include \"TinyIR.h\" // Defines protocol timings\n\n#include \"digitalWriteFast.h\"\n/** \\addtogroup TinySender Minimal sender for NEC and FAST protocol\n * @{\n */\n\n#if !defined(IR_SEND_PIN)\n#warning \"IR_SEND_PIN is not defined, so it is set to 3\"\n#define IR_SEND_PIN    3\n#endif\n/*\n * Generate 38 kHz IR signal by bit banging\n */\nvoid sendMark(uint8_t aSendPin, unsigned int aMarkMicros) {\n    unsigned long tStartMicros = micros();\n    unsigned long tNextPeriodEnding = tStartMicros;\n    unsigned long tMicros;\n    do {\n        /*\n         * Generate pulse\n         */\n        noInterrupts(); // do not let interrupts extend the short on period\n        digitalWriteFast(aSendPin, HIGH);\n        delayMicroseconds(8); // 8 us for a 30 % duty cycle for 38 kHz\n        digitalWriteFast(aSendPin, LOW);\n        interrupts(); // Enable interrupts - to keep micros correct- for the longer off period 3.4 us until receive ISR is active (for 7 us + pop's)\n\n        /*\n         * PWM pause timing and end check\n         * Minimal pause duration is 4.3 us\n         */\n        tNextPeriodEnding += 26; // for 38 kHz\n        do {\n            tMicros = micros(); // we have only 4 us resolution for AVR @16MHz\n            /*\n             * Exit the forever loop if aMarkMicros has reached\n             */\n            unsigned int tDeltaMicros = tMicros - tStartMicros;\n#if defined(__AVR__)\n            // Just getting variables and check for end condition takes minimal 3.8 us\n            if (tDeltaMicros >= aMarkMicros - (112 / (F_CPU / MICROS_IN_ONE_SECOND))) { // To compensate for call duration - 112 is an empirical value\n#else\n                if (tDeltaMicros >= aMarkMicros) {\n    #endif\n                return;\n            }\n        } while (tMicros < tNextPeriodEnding);\n    } while (true);\n}\n\n/*\n * Send NEC with 16 bit address and command, even if aCommand < 0x100 (I.E. ONKYO)\n * @param aAddress  - The 16 bit address to send.\n * @param aCommand  - The 16 bit command to send.\n * @param aNumberOfRepeats  - Number of repeats send at a period of 110 ms.\n * @param aSendNEC2Repeats - Instead of sending the NEC special repeat code, send the original frame for repeat.\n */\nvoid sendONKYO(uint8_t aSendPin, uint16_t aAddress, uint16_t aCommand, uint_fast8_t aNumberOfRepeats, bool aSendNEC2Repeats) {\n    pinModeFast(aSendPin, OUTPUT);\n\n    uint_fast8_t tNumberOfCommands = aNumberOfRepeats + 1;\n    while (tNumberOfCommands > 0) {\n        unsigned long tStartOfFrameMillis = millis();\n\n        sendMark(aSendPin, NEC_HEADER_MARK);\n        if ((!aSendNEC2Repeats) && (tNumberOfCommands < aNumberOfRepeats + 1)) {\n            // send the NEC special repeat\n            delayMicroseconds(NEC_REPEAT_HEADER_SPACE); // - 2250\n        } else {\n            // send header\n            delayMicroseconds(NEC_HEADER_SPACE);\n            LongUnion tData;\n            tData.UWord.LowWord = aAddress;\n            tData.UWord.HighWord = aCommand;\n            // Send data\n            for (uint_fast8_t i = 0; i < NEC_BITS; ++i) {\n                sendMark(aSendPin, NEC_BIT_MARK); // constant mark length\n                if (tData.ULong & 1) {\n                    delayMicroseconds(NEC_ONE_SPACE);\n                } else {\n                    delayMicroseconds(NEC_ZERO_SPACE);\n                }\n                tData.ULong >>= 1; // shift command for next bit\n            }\n        }        // send stop bit\n        sendMark(aSendPin, NEC_BIT_MARK);\n\n        tNumberOfCommands--;\n        // skip last delay!\n        if (tNumberOfCommands > 0) {\n            /*\n             * Check and fallback for wrong RepeatPeriodMillis parameter. I.e the repeat period must be greater than each frame duration.\n             */\n            auto tFrameDurationMillis = millis() - tStartOfFrameMillis;\n            if (NEC_REPEAT_PERIOD / 1000 > tFrameDurationMillis) {\n                delay(NEC_REPEAT_PERIOD / 1000 - tFrameDurationMillis);\n            }\n        }\n    }\n}\n\n/*\n * Send NEC with 8 or 16 bit address or command depending on the values of aAddress and aCommand.\n * @param aAddress  - If aAddress < 0x100 send 8 bit address and 8 bit inverted address, else send 16 bit address.\n * @param aCommand  - If aCommand < 0x100 send 8 bit command and 8 bit inverted command, else send 16 bit command.\n * @param aNumberOfRepeats  - Number of repeats send at a period of 110 ms.\n * @param aSendNEC2Repeats - Instead of sending the NEC special repeat code, send the original frame for repeat.\n */\nvoid sendNECMinimal(uint8_t aSendPin, uint16_t aAddress, uint16_t aCommand, uint_fast8_t aNumberOfRepeats) {\n    sendNEC(aSendPin, aAddress, aCommand, aNumberOfRepeats); // sendNECMinimal() is deprecated\n}\nvoid sendNEC(uint8_t aSendPin, uint16_t aAddress, uint16_t aCommand, uint_fast8_t aNumberOfRepeats, bool aSendNEC2Repeats) {\n    pinModeFast(aSendPin, OUTPUT);\n\n    uint_fast8_t tNumberOfCommands = aNumberOfRepeats + 1;\n    while (tNumberOfCommands > 0) {\n        unsigned long tStartOfFrameMillis = millis();\n\n        sendMark(aSendPin, NEC_HEADER_MARK);\n        if ((!aSendNEC2Repeats) && (tNumberOfCommands < aNumberOfRepeats + 1)) {\n            // send the NEC special repeat\n            delayMicroseconds(NEC_REPEAT_HEADER_SPACE); // - 2250\n        } else {\n            // send header\n            delayMicroseconds(NEC_HEADER_SPACE);\n            LongUnion tData;\n            /*\n             * The compiler is intelligent and removes the code for \"(aAddress > 0xFF)\" if we are called with an uint8_t address :-).\n             * Using an uint16_t address requires additional 28 bytes program memory.\n             */\n            if (aAddress > 0xFF) {\n                tData.UWord.LowWord = aAddress;\n            } else {\n                tData.UByte.LowByte = aAddress; // LSB first\n                tData.UByte.MidLowByte = ~aAddress;\n            }\n            if (aCommand > 0xFF) {\n                tData.UWord.HighWord = aCommand;\n            } else {\n                tData.UByte.MidHighByte = aCommand;\n                tData.UByte.HighByte = ~aCommand; // LSB first\n            }\n            // Send data\n            for (uint_fast8_t i = 0; i < NEC_BITS; ++i) {\n                sendMark(aSendPin, NEC_BIT_MARK); // constant mark length\n\n                if (tData.ULong & 1) {\n                    delayMicroseconds(NEC_ONE_SPACE);\n                } else {\n                    delayMicroseconds(NEC_ZERO_SPACE);\n                }\n                tData.ULong >>= 1; // shift command for next bit\n            }\n        }        // send stop bit\n        sendMark(aSendPin, NEC_BIT_MARK);\n\n        tNumberOfCommands--;\n        // skip last delay!\n        if (tNumberOfCommands > 0) {\n            /*\n             * Check and fallback for wrong RepeatPeriodMillis parameter. I.e the repeat period must be greater than each frame duration.\n             */\n            auto tFrameDurationMillis = millis() - tStartOfFrameMillis;\n            if (NEC_REPEAT_PERIOD / 1000 > tFrameDurationMillis) {\n                delay(NEC_REPEAT_PERIOD / 1000 - tFrameDurationMillis);\n            }\n        }\n    }\n}\n\n/*\n * Send Extended NEC with a forced 16 bit address and 8 or 16 bit command depending on the value of aCommand.\n * @param aAddress  - Send 16 bit address.\n * @param aCommand  - If aCommand < 0x100 send 8 bit command and 8 bit inverted command, else send 16 bit command.\n * @param aNumberOfRepeats  - Number of repeats send at a period of 110 ms.\n * @param aSendNEC2Repeats - Instead of sending the NEC special repeat code, send the original frame for repeat.\n */\nvoid sendExtendedNEC(uint8_t aSendPin, uint16_t aAddress, uint16_t aCommand, uint_fast8_t aNumberOfRepeats, bool aSendNEC2Repeats) {\n    pinModeFast(aSendPin, OUTPUT);\n\n    uint_fast8_t tNumberOfCommands = aNumberOfRepeats + 1;\n    while (tNumberOfCommands > 0) {\n        unsigned long tStartOfFrameMillis = millis();\n\n        sendMark(aSendPin, NEC_HEADER_MARK);\n        if ((!aSendNEC2Repeats) && (tNumberOfCommands < aNumberOfRepeats + 1)) {\n            // send the NEC special repeat\n            delayMicroseconds(NEC_REPEAT_HEADER_SPACE); // - 2250\n        } else {\n            // send header\n            delayMicroseconds(NEC_HEADER_SPACE);\n            LongUnion tData;\n            tData.UWord.LowWord = aAddress;\n            if (aCommand > 0xFF) {\n                tData.UWord.HighWord = aCommand;\n            } else {\n                tData.UByte.MidHighByte = aCommand;\n                tData.UByte.HighByte = ~aCommand; // LSB first\n            }\n            // Send data\n            for (uint_fast8_t i = 0; i < NEC_BITS; ++i) {\n                sendMark(aSendPin, NEC_BIT_MARK); // constant mark length\n\n                if (tData.ULong & 1) {\n                    delayMicroseconds(NEC_ONE_SPACE);\n                } else {\n                    delayMicroseconds(NEC_ZERO_SPACE);\n                }\n                tData.ULong >>= 1; // shift command for next bit\n            }\n        }        // send stop bit\n        sendMark(aSendPin, NEC_BIT_MARK);\n\n        tNumberOfCommands--;\n        // skip last delay!\n        if (tNumberOfCommands > 0) {\n            /*\n             * Check and fallback for wrong RepeatPeriodMillis parameter. I.e the repeat period must be greater than each frame duration.\n             */\n            auto tFrameDurationMillis = millis() - tStartOfFrameMillis;\n            if (NEC_REPEAT_PERIOD / 1000 > tFrameDurationMillis) {\n                delay(NEC_REPEAT_PERIOD / 1000 - tFrameDurationMillis);\n            }\n        }\n    }\n}\n\n/*\n * LSB first, send header, command, inverted command and stop bit\n */\nvoid sendFast8BitAndParity(uint8_t aSendPin, uint8_t aCommand, uint_fast8_t aNumberOfRepeats) {\n    sendFAST(aSendPin, aCommand, aNumberOfRepeats);\n}\n\n/*\n * LSB first, send header, 16 bit command or 8 bit command, inverted command and stop bit\n */\nvoid sendFAST(uint8_t aSendPin, uint16_t aCommand, uint_fast8_t aNumberOfRepeats) {\n    pinModeFast(aSendPin, OUTPUT);\n\n    uint_fast8_t tNumberOfCommands = aNumberOfRepeats + 1;\n    while (tNumberOfCommands > 0) {\n        unsigned long tStartOfFrameMillis = millis();\n\n        // send header\n        sendMark(aSendPin, FAST_HEADER_MARK);\n        delayMicroseconds(FAST_HEADER_SPACE);\n        uint16_t tData;\n        /*\n         * The compiler is intelligent and removes the code for \"(aCommand > 0xFF)\" if we are called with an uint8_t command :-).\n         * Using an uint16_t command requires additional 56 bytes program memory.\n         */\n        if (aCommand > 0xFF) {\n            tData = aCommand;\n        } else {\n            tData = aCommand | (((uint8_t) (~aCommand)) << 8); // LSB first\n        }\n        // Send data\n        for (uint_fast8_t i = 0; i < FAST_BITS; ++i) {\n            sendMark(aSendPin, FAST_BIT_MARK); // constant mark length\n\n            if (tData & 1) {\n                delayMicroseconds(FAST_ONE_SPACE);\n            } else {\n                delayMicroseconds(FAST_ZERO_SPACE);\n            }\n            tData >>= 1; // shift command for next bit\n        }\n        // send stop bit\n        sendMark(aSendPin, FAST_BIT_MARK);\n\n        tNumberOfCommands--;\n        // skip last delay!\n        if (tNumberOfCommands > 0) {\n            /*\n             * Check and fallback for wrong RepeatPeriodMillis parameter. I.e the repeat period must be greater than each frame duration.\n             */\n            auto tFrameDurationMillis = millis() - tStartOfFrameMillis;\n            if (FAST_REPEAT_PERIOD / 1000 > tFrameDurationMillis) {\n                delay(FAST_REPEAT_PERIOD / 1000 - tFrameDurationMillis);\n            }\n        }\n    }\n}\n\n/** @}*/\n\n#if defined(LOCAL_DEBUG)\n#undef LOCAL_DEBUG\n#endif\n#endif // _TINY_IR_SENDER_HPP\n"
    }, {
      filename: "src/IRVersion.h",
      code: "/**\n * @file IRversion.hpp\n *\n * This file is part of Arduino-IRremote https://github.com/Arduino-IRremote/Arduino-IRremote.\n *\n ************************************************************************************\n * MIT License\n *\n * Copyright (c) 2015-2023 Ken Shirriff http://www.righto.com, Rafi Khan, Armin Joachimsmeyer\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is furnished\n * to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n ************************************************************************************\n *\n * For Ken Shiriffs original blog entry, see http://www.righto.com/2009/08/multi-protocol-infrared-remote-library.html\n * Initially influenced by:\n * http://www.arduino.cc/cgi-bin/yabb2/YaBB.pl?num=1210243556\n * and http://zovirl.com/2008/11/12/building-a-universal-remote-with-an-arduino/\n */\n\n#ifndef _IR_VERSION_HPP\n#define _IR_VERSION_HPP\n\n#define VERSION_IRREMOTE \"4.3.1\"\n#define VERSION_IRREMOTE_MAJOR 4\n#define VERSION_IRREMOTE_MINOR 3\n#define VERSION_IRREMOTE_PATCH 1\n\n/*\n * Macro to convert 3 version parts into an integer\n * To be used in preprocessor comparisons, such as #if VERSION_IRREMOTE_HEX >= VERSION_HEX_VALUE(3, 7, 0)\n */\n#define VERSION_HEX_VALUE(major, minor, patch) ((major << 16) | (minor << 8) | (patch))\n#define VERSION_IRREMOTE_HEX  VERSION_HEX_VALUE(VERSION_IRREMOTE_MAJOR, VERSION_IRREMOTE_MINOR, VERSION_IRREMOTE_PATCH)\n\n#endif // _IR_VERSION_HPP\n"
    }, {
      filename: "src/ac_LG.hpp",
      code: "/*\n * ac_LG.hpp\n *\n *  Contains functions for sending LG air conditioner IR Protocol\n *  There is no state plausibility check, e.g. you can send fan speed in Mode D and change temperature in mode F\n *\n *  This file is part of Arduino-IRremote https://github.com/Arduino-IRremote/Arduino-IRremote.\n *\n ************************************************************************************\n * MIT License\n *\n * Copyright (c) 2021-2022 Armin Joachimsmeyer\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is furnished\n * to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n ************************************************************************************\n */\n#ifndef _AC_LG_HPP\n#define _AC_LG_HPP\n#include <Arduino.h>\n\n#if defined(INFO) && !defined(LOCAL_INFO)\n#define LOCAL_INFO\n#else\n//#define LOCAL_INFO // This enables info output only for this file\n#endif\n//#define DEBUG // for more output from the LG-AC driver.\n#include \"IRremoteInt.h\"\n#include \"ac_LG.h\" // useful constants\n#include \"LongUnion.h\"\n\n/** \\addtogroup Airconditoners Air conditioner special code\n * @{\n */\n/*\n * LG remote measurements: Type AKB73315611, Ver1.1 from 2011.03.01\n * Internal crystal: 4 MHz\n * Header:  8.9 ms mark 4.15 ms space\n * Data:    500 / 540 and 500 / 1580;\n * Clock is nor synchronized with gate so you have 19 and sometimes 19 and a spike pulses for mark\n * Duty:    9 us on 17 us off => around 33 % duty\n * NO REPEAT: If value like temperature has changed during long press, the last value is send at button release\n * If you do a double press -tested with the fan button-, the next value can be sent after 118 ms\n */\n#define SIZE_OF_FAN_SPEED_MAPPING_TABLE     4\nconst int AC_FAN_TOWER[SIZE_OF_FAN_SPEED_MAPPING_TABLE] = { 0, 4, 6, 6 }; // last dummy entry to avoid out of bounds access\nconst int AC_FAN_WALL[SIZE_OF_FAN_SPEED_MAPPING_TABLE] = { 0, 2, 4, 5 }; // 0 -> low, 4 high, 5 -> cycle\n\nvoid Aircondition_LG::setType(bool aIsWallType) {\n    ACIsWallType = aIsWallType;\n#if defined(LOCAL_INFO)\n    Serial.print(F(\"Set wall type to \"));\n    Serial.println(aIsWallType);\n#endif\n}\n\nvoid Aircondition_LG::printMenu(Print *aSerial) {\n    aSerial->println();\n    aSerial->println();\n    aSerial->println(F(\"Type command and optional parameter without a separator\"));\n    aSerial->println(F(\"0 Off\"));\n    aSerial->println(F(\"1 On\"));\n    aSerial->println(F(\"s Swing <0 or 1>\"));\n    aSerial->println(F(\"a Auto clean <0 or 1>\"));\n    aSerial->println(F(\"j Jet on\"));\n    aSerial->println(F(\"e Energy saving <0 or 1>\"));\n    aSerial->println(F(\"l Lights toggle\"));\n    aSerial->println(F(\"f Fan speed <0 to 2 or 3 for cycle>\"));\n    aSerial->println(F(\"t Temperature <18 to 30> degree\"));\n    aSerial->println(F(\"+ Temperature + 1\"));\n    aSerial->println(F(\"- Temperature - 1\"));\n    aSerial->println(F(\"m <c(ool) or a(uto) or d(ehumidifying) or h(eating) or f(an) mode>\"));\n    aSerial->println(F(\"S Sleep after <0 to 420> minutes\"));\n    aSerial->println(F(\"T Timer on after <0 to 1439> minutes\"));\n    aSerial->println(F(\"O Timer off after <0 to 1439> minutes\"));\n    aSerial->println(F(\"C Clear all timer and sleep\"));\n    aSerial->println(F(\"e.g. \\\"s1\\\" or \\\"t23\\\" or \\\"mc\\\" or \\\"O60\\\" or \\\"+\\\"\"));\n    aSerial->println(F(\"No plausibility check is made!\"));\n    aSerial->println();\n}\n\n/*\n * Send repeat\n * Repeat commands should be sent in a 110 ms raster.\n * @param aCommand one of LG_COMMAND_OFF, LG_COMMAND_ON etc.\n */\nbool Aircondition_LG::sendCommandAndParameter(char aCommand, int aParameter) {\n    // Commands without parameter\n    switch (aCommand) {\n    case LG_COMMAND_OFF: // off\n        sendIRCommand(LG_POWER_DOWN);\n        PowerIsOn = false;\n        return true;\n\n    case LG_COMMAND_ON: // on\n        PowerIsOn = false; // set to false in order to suppress on bit\n        sendTemperatureFanSpeedAndMode();\n        return true;\n\n    case LG_COMMAND_JET:\n        IR_DEBUG_PRINTLN(F(\"Send jet on\"));\n        sendIRCommand(LG_JET_ON);\n        return true;\n\n    case LG_COMMAND_LIGHT:\n        sendIRCommand(LG_LIGHT);\n        return true;\n\n    case LG_COMMAND_CLEAR_ALL:\n        sendIRCommand(LG_CLEAR_ALL);\n        return true;\n\n    case LG_COMMAND_TEMPERATURE_PLUS:\n        if (18 <= Temperature && Temperature <= 29) {\n            Temperature++;\n            sendTemperatureFanSpeedAndMode();\n        } else {\n            return false;\n        }\n        return true;\n\n    case LG_COMMAND_TEMPERATURE_MINUS:\n        if (19 <= Temperature && Temperature <= 30) {\n            Temperature--;\n            sendTemperatureFanSpeedAndMode();\n        } else {\n            return false;\n        }\n        return true;\n\n    }\n\n    PowerIsOn = true;\n\n    /*\n     * Now the commands which require a parameter\n     */\n    if (aParameter < 0) {\n        IR_DEBUG_PRINT(F(\"Error: Parameter is less than 0\"));\n        return false;\n    }\n    switch (aCommand) {\n\n    case LG_COMMAND_MODE:\n        Mode = aParameter + '0';\n        sendTemperatureFanSpeedAndMode();\n        break;\n\n    case LG_COMMAND_SWING:\n        IR_DEBUG_PRINT(F(\"Send air swing=\"));\n        IR_DEBUG_PRINTLN(aParameter);\n        if (ACIsWallType) {\n            if (aParameter) {\n                sendIRCommand(LG_WALL_SWING_ON);\n            } else {\n                sendIRCommand(LG_WALL_SWING_OFF);\n            }\n        } else {\n            if (aParameter) {\n                sendIRCommand(LG_SWING_ON);\n            } else {\n                sendIRCommand(LG_SWING_OFF);\n            }\n        }\n        break;\n\n    case LG_COMMAND_AUTO_CLEAN:\n        IR_DEBUG_PRINT(F(\"Send auto clean=\"));\n        IR_DEBUG_PRINTLN(aParameter);\n        if (aParameter) {\n            sendIRCommand(LG_AUTO_CLEAN_ON);\n        } else {\n            sendIRCommand(LG_AUTO_CLEAN_OFF);\n        }\n        break;\n\n    case LG_COMMAND_ENERGY:\n        IR_DEBUG_PRINT(F(\"Send energy saving on=\"));\n        IR_DEBUG_PRINTLN(aParameter);\n        if (aParameter) {\n            sendIRCommand(LG_ENERGY_SAVING_ON);\n        } else {\n            sendIRCommand(LG_ENERGY_SAVING_OFF);\n        }\n        break;\n\n    case LG_COMMAND_FAN_SPEED:\n        if (aParameter < SIZE_OF_FAN_SPEED_MAPPING_TABLE) {\n            FanIntensity = aParameter;\n            sendTemperatureFanSpeedAndMode();\n        } else {\n            return false;\n        }\n        break;\n\n    case LG_COMMAND_TEMPERATURE:\n        if (18 <= aParameter && aParameter <= 30) {\n            Temperature = aParameter;\n            sendTemperatureFanSpeedAndMode();\n        } else {\n            return false;\n        }\n        break;\n\n    case LG_COMMAND_SLEEP:\n        // 420 = maximum I have recorded\n        if (aParameter <= 420) {\n            sendIRCommand(LG_SLEEP + aParameter);\n        } else {\n            return false;\n        }\n        break;\n\n    case LG_COMMAND_TIMER_ON:\n        // 1440 = minutes of a day\n        if (aParameter <= 1439) {\n            sendIRCommand(LG_TIMER_ON + aParameter);\n        } else {\n            return false;\n        }\n        break;\n\n    case LG_COMMAND_TIMER_OFF:\n        if (aParameter <= 1439) {\n            sendIRCommand(LG_TIMER_OFF + aParameter);\n        } else {\n            return false;\n        }\n        break;\n\n    default:\n        return false;\n    }\n    return true;\n}\n\nvoid Aircondition_LG::sendIRCommand(uint16_t aCommand) {\n\n#if defined(LOCAL_INFO)\n    Serial.print(F(\"Send code=0x\"));\n    Serial.print(aCommand, HEX);\n    Serial.print(F(\" | 0b\"));\n    Serial.println(aCommand, BIN);\n#endif\n\n    IrSender.sendLG2((uint8_t) LG_ADDRESS, aCommand, 0);\n}\n\n/*\n * Takes values from static variables\n */\nvoid Aircondition_LG::sendTemperatureFanSpeedAndMode() {\n\n    uint8_t tTemperature = Temperature;\n#if defined(LOCAL_INFO)\n    Serial.print(F(\"Send temperature=\"));\n    Serial.print(tTemperature);\n    Serial.print(F(\" fan intensity=\"));\n    Serial.print(FanIntensity);\n    Serial.print(F(\" mode=\"));\n    Serial.println((char )Mode);\n#endif\n\n    WordUnion tIRCommand;\n    tIRCommand.UWord = 0;\n\n    // Temperature is coded in the upper nibble of the LowByte\n    tIRCommand.UByte.LowByte = ((tTemperature - 15) << 4); // 16 -> 0x00, 18 -> 0x30, 30 -> 0xF0\n\n    // Fan intensity is coded in the lower nibble of the LowByte\n    if (ACIsWallType) {\n        tIRCommand.UByte.LowByte |= AC_FAN_WALL[FanIntensity];\n    } else {\n        tIRCommand.UByte.LowByte |= AC_FAN_TOWER[FanIntensity];\n    }\n\n    switch (Mode) {\n    case AC_MODE_COOLING:\n        tIRCommand.UByte.HighByte = LG_MODE_COOLING >> 8;\n        break;\n    case AC_MODE_HEATING:\n        tIRCommand.UByte.HighByte = LG_MODE_HEATING >> 8;\n        break;\n    case AC_MODE_AUTO:\n        tIRCommand.UByte.HighByte = LG_MODE_AUTO >> 8;\n        break;\n    case AC_MODE_FAN:\n        tTemperature = 18;\n        tIRCommand.UByte.HighByte = LG_MODE_FAN >> 8;\n        break;\n    case AC_MODE_DEHUMIDIFIYING:\n        tIRCommand.UWord = LG_MODE_DEHUMIDIFIYING;\n        break;\n    default:\n        break;\n    }\n    if (!PowerIsOn) {\n        // switch on requires masked bit\n        tIRCommand.UByte.HighByte &= ~(LG_SWITCH_ON_MASK >> 8);\n    }\n    PowerIsOn = true;\n\n    sendIRCommand(tIRCommand.UWord);\n}\n\n/** @}*/\n#endif // _AC_LG_HPP\n"
    }, {
      filename: "src/ir_Lego.hpp",
      code: "/*\n * ir_Lego.hpp\n *\n *  Contains functions for receiving and sending Lego Power Functions IR Protocol\n *\n *  This file is part of Arduino-IRremote https://github.com/Arduino-IRremote/Arduino-IRremote.\n *\n ************************************************************************************\n * MIT License\n *\n * Copyright (c) 2020-2023 Armin Joachimsmeyer\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is furnished\n * to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n ************************************************************************************\n */\n#ifndef _IR_LEGO_HPP\n#define _IR_LEGO_HPP\n\n/** \\addtogroup Decoder Decoders and encoders for different protocols\n * @{\n */\n//==============================================================================\n//         L       EEEEEE   EEEE    OOOO\n//         L       E       E       O    O\n//         L       EEEE    E  EEE  O    O\n//         L       E       E    E  O    O\n//         LLLLLL  EEEEEE   EEEE    OOOO\n//==============================================================================\n// from LEGO Power Functions RC Manual 26.02.2010 Version 1.20\n// https://github.com/jurriaan/Arduino-PowerFunctions/raw/master/LEGO_Power_Functions_RC_v120.pdf\n// https://oberguru.net/elektronik/ir/codes/lego_power_functions_train.lircd.conf\n// For original LEGO receiver see: https://www.philohome.com/pfrec/pfrec.htm and https://www.youtube.com/watch?v=KCM4Ug1bPrM\n//\n// To ensure correct detection of IR messages six 38 kHz cycles are transmitted as mark.\n// Low bit consists of 6 cycles of IR and 10 ÔøΩcyclesÔøΩ of pause,\n// high bit of 6 cycles IR and 21 ÔøΩcyclesÔøΩ of pause and start bit of 6 cycles IR and 39 ÔøΩcyclesÔøΩ of pause.\n// Low bit range 316 - 526 us\n// High bit range 526 ÔøΩ 947 us\n// Start/stop bit range 947 ÔøΩ 1579 us\n// If tm is the maximum message length (16ms) and Ch is the channel number, then\n// The delay before transmitting the first message is: (4 ÔøΩ Ch)*tm\n// The time from start to start for the next 2 messages is: 5*tm\n// The time from start to start for the following messages is: (6 + 2*Ch)*tm\n// Supported Devices\n// LEGO Power Functions IR Receiver 8884\n// MSB first, 1 start bit + 4 bit channel, 4 bit mode + 4 bit command + 4 bit parity + 1 stop bit.\n#define LEGO_CHANNEL_BITS       4\n#define LEGO_MODE_BITS          4\n#define LEGO_COMMAND_BITS       4\n#define LEGO_PARITY_BITS        4\n\n#define LEGO_BITS               (LEGO_CHANNEL_BITS + LEGO_MODE_BITS + LEGO_COMMAND_BITS + LEGO_PARITY_BITS)\n\n#define LEGO_HEADER_MARK        158    //  6 cycles\n#define LEGO_HEADER_SPACE       1026   // 39 cycles\n\n#define LEGO_BIT_MARK           158    //  6 cycles\n#define LEGO_ONE_SPACE          553    // 21 cycles\n#define LEGO_ZERO_SPACE         263    // 10 cycles\n\n#define LEGO_AVERAGE_DURATION   11000 // LEGO_HEADER_MARK + LEGO_HEADER_SPACE  + 16 * 600 + 158\n\n#define LEGO_AUTO_REPEAT_PERIOD_MIN 110000 // Every frame is auto repeated 5 times.\n#define LEGO_AUTO_REPEAT_PERIOD_MAX 230000 // space for channel 3\n\n#define LEGO_MODE_EXTENDED  0\n#define LEGO_MODE_COMBO     1\n#define LEGO_MODE_SINGLE    0x4 // here the 2 LSB have meanings like Output A / Output B\n\nstruct PulseDistanceWidthProtocolConstants LegoProtocolConstants = { LEGO_PF, 38, LEGO_HEADER_MARK, LEGO_HEADER_SPACE, LEGO_BIT_MARK,\nLEGO_ONE_SPACE, LEGO_BIT_MARK, LEGO_ZERO_SPACE, PROTOCOL_IS_LSB_FIRST, (LEGO_AUTO_REPEAT_PERIOD_MIN\n        / MICROS_IN_ONE_MILLI), NULL };\n\n/************************************\n * Start of send and decode functions\n ************************************/\n/*\n * Here we process the structured data, and call the send raw data function\n * @param aMode one of LEGO_MODE_EXTENDED, LEGO_MODE_COMBO, LEGO_MODE_SINGLE\n */\nvoid IRsend::sendLegoPowerFunctions(uint8_t aChannel, uint8_t aCommand, uint8_t aMode, bool aDoSend5Times) {\n    aChannel &= 0x0F; // allow toggle and escape bits too\n    aCommand &= 0x0F;\n    aMode &= 0x0F;\n    uint8_t tParity = 0xF ^ aChannel ^ aMode ^ aCommand;\n    // send 4 bit channel, 4 bit mode, 4 bit command, 4 bit parity\n    uint16_t tRawData = (((aChannel << LEGO_MODE_BITS) | aMode) << (LEGO_COMMAND_BITS + LEGO_PARITY_BITS))\n            | (aCommand << LEGO_PARITY_BITS) | tParity;\n    sendLegoPowerFunctions(tRawData, aChannel, aDoSend5Times);\n}\n\nvoid IRsend::sendLegoPowerFunctions(uint16_t aRawData, uint8_t aChannel, bool aDoSend5Times) {\n\n    IR_DEBUG_PRINT(F(\"sendLego aRawData=0x\"));\n    IR_DEBUG_PRINTLN(aRawData, HEX);\n\n    aChannel &= 0x03; // we have 4 channels\n\n    uint_fast8_t tNumberOfRepeats = 0;\n    if (aDoSend5Times) {\n        tNumberOfRepeats = 4;\n    }\n// required for repeat timing, see http://www.hackvandedam.nl/blog/?page_id=559\n    uint8_t tRepeatPeriod = (LEGO_AUTO_REPEAT_PERIOD_MIN / MICROS_IN_ONE_MILLI) + (aChannel * 40); // from 110 to 230\n    LegoProtocolConstants.RepeatPeriodMillis = tRepeatPeriod;\n    sendPulseDistanceWidth(&LegoProtocolConstants, aRawData, LEGO_BITS, tNumberOfRepeats);\n}\n\n/*\n * Mode is stored in the upper nibble of command\n */\nbool IRrecv::decodeLegoPowerFunctions() {\n\n    if (!checkHeader(&LegoProtocolConstants)) {\n        return false;\n    }\n\n    // Check we have enough data - +4 for initial gap, start bit mark and space + stop bit mark\n    if (decodedIRData.rawDataPtr->rawlen != (2 * LEGO_BITS) + 4) {\n        IR_DEBUG_PRINT(F(\"LEGO: \"));\n        IR_DEBUG_PRINT(F(\"Data length=\"));\n        IR_DEBUG_PRINT(decodedIRData.rawDataPtr->rawlen);\n        IR_DEBUG_PRINTLN(F(\" is not 36\"));\n        return false;\n    }\n\n    if (!decodePulseDistanceWidthData(&LegoProtocolConstants, LEGO_BITS)) {\n        IR_DEBUG_PRINT(F(\"LEGO: \"));\n        IR_DEBUG_PRINTLN(F(\"Decode failed\"));\n        return false;\n    }\n\n    // Stop bit\n    if (!matchMark(decodedIRData.rawDataPtr->rawbuf[3 + (2 * LEGO_BITS)], LEGO_BIT_MARK)) {\n        IR_DEBUG_PRINT(F(\"LEGO: \"));\n        IR_DEBUG_PRINTLN(F(\"Stop bit mark length is wrong\"));\n        return false;\n    }\n\n    // Success\n    decodedIRData.flags = IRDATA_FLAGS_IS_MSB_FIRST;\n    uint16_t tDecodedValue = decodedIRData.decodedRawData;\n    uint8_t tToggleEscapeChannel = tDecodedValue >> (LEGO_MODE_BITS + LEGO_COMMAND_BITS + LEGO_PARITY_BITS);\n    uint8_t tMode = (tDecodedValue >> (LEGO_COMMAND_BITS + LEGO_PARITY_BITS)) & 0xF;\n    uint8_t tData = (tDecodedValue >> LEGO_PARITY_BITS) & 0xF; // lego calls this field \"data\"\n    uint8_t tParityReceived = tDecodedValue & 0xF;\n\n    // This is parity as defined in the specifications\n    // But in some scans I saw 0x9 ^ .. as parity formula\n    uint8_t tParityComputed = 0xF ^ tToggleEscapeChannel ^ tMode ^ tData;\n\n    // parity check\n    if (tParityReceived != tParityComputed) {\n        IR_DEBUG_PRINT(F(\"LEGO: \"));\n        IR_DEBUG_PRINT(F(\"Parity is not correct. expected=0x\"));\n        IR_DEBUG_PRINT(tParityComputed, HEX);\n        IR_DEBUG_PRINT(F(\" received=0x\"));\n        IR_DEBUG_PRINT(tParityReceived, HEX);\n        IR_DEBUG_PRINT(F(\", raw=0x\"));\n        IR_DEBUG_PRINT(tDecodedValue, HEX);\n        IR_DEBUG_PRINT(F(\", 3 nibbles are 0x\"));\n        IR_DEBUG_PRINT(tToggleEscapeChannel, HEX);\n        IR_DEBUG_PRINT(F(\", 0x\"));\n        IR_DEBUG_PRINT(tMode, HEX);\n        IR_DEBUG_PRINT(F(\", 0x\"));\n        IR_DEBUG_PRINTLN(tData, HEX);\n        // might not be an error, so just continue\n        decodedIRData.flags = IRDATA_FLAGS_PARITY_FAILED | IRDATA_FLAGS_IS_MSB_FIRST;\n    }\n\n    /*\n     * Check for autorepeat (should happen 4 times for one press)\n     */\n    if (decodedIRData.initialGap < (LEGO_AUTO_REPEAT_PERIOD_MAX / MICROS_PER_TICK)) {\n        decodedIRData.flags |= IRDATA_FLAGS_IS_AUTO_REPEAT;\n    }\n    decodedIRData.address = tToggleEscapeChannel;\n    decodedIRData.command = tData | tMode << LEGO_COMMAND_BITS;\n    decodedIRData.numberOfBits = LEGO_BITS;\n    decodedIRData.protocol = LEGO_PF;\n\n    return true;\n}\n\n/*********************************************************************************\n * Old deprecated functions, kept for backward compatibility to old 2.0 tutorials\n *********************************************************************************/\n\nvoid IRsend::sendLegoPowerFunctions(uint16_t aRawData, bool aDoSend5Times) {\n    sendLegoPowerFunctions(aRawData, (aRawData >> (LEGO_MODE_BITS + LEGO_COMMAND_BITS + LEGO_PARITY_BITS)) & 0x3, aDoSend5Times);\n}\n\n/** @}*/\n#endif // _IR_LEGO_HPP\n"
    }, {
      filename: "src/private/IRTimer.hpp",
      code: "/**\n * @file IRTimer.hpp\n *\n * @brief All timer specific definitions are contained in this file.\n * Sets IR_SEND_PIN if required, e.g. if SEND_PWM_BY_TIMER for AVR is defined, which restricts the output to a dedicated pin number\n *\n * timerConfigForSend(aFrequencyKHz) must set output pin mode and disable receive interrupt if it uses the same resource\n *\n *  This file is part of Arduino-IRremote https://github.com/Arduino-IRremote/Arduino-IRremote.\n *\n *************************************************************************************\n * MIT License\n *\n * Copyright (c) 2021-2023 Armin Joachimsmeyer\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is furnished\n * to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n ************************************************************************************\n */\n#ifndef _IR_TIMER_HPP\n#define _IR_TIMER_HPP\n\n/** \\addtogroup HardwareDependencies CPU / board dependent definitions\n * @{\n */\n/** \\addtogroup Timer Usage of timers for the different CPU / boards\n * @{\n */\n/*\n * Functions declared here\n */\nvoid timerResetInterruptPending();\nvoid timerEnableReceiveInterrupt();\nvoid timerDisableReceiveInterrupt();\nvoid timerConfigForReceive();\nvoid enableSendPWMByTimer();\nvoid disableSendPWMByTimer();\nvoid timerConfigForSend(uint16_t aFrequencyKHz);\n\n// SEND_PWM_BY_TIMER is defined in IRremote.hpp line 195.\n#if  defined(SEND_PWM_BY_TIMER) && ( (defined(ESP32) || defined(ARDUINO_ARCH_RP2040) || defined(PARTICLE)) || defined(ARDUINO_ARCH_MBED) )\n#define SEND_PWM_DOES_NOT_USE_RECEIVE_TIMER // Receive timer and send generation timer are independent here.\n#endif\n\n#if defined(IR_SEND_PIN) && defined(SEND_PWM_BY_TIMER) && !defined(SEND_PWM_DOES_NOT_USE_RECEIVE_TIMER) // For ESP32 etc. IR_SEND_PIN definition is useful\n#undef IR_SEND_PIN // To avoid \"warning: \"IR_SEND_PIN\" redefined\". The user warning is done at IRremote.hpp line 202.\n#endif\n\n// Macros for enabling timers for development\n//#define SEND_PWM_BY_TIMER\n//#define IR_USE_AVR_TIMER1\n//#define IR_USE_AVR_TIMER2\n//#define IR_USE_AVR_TIMER3\n//#define IR_USE_AVR_TIMER4\n//#define IR_USE_AVR_TIMER4_HS\n//#define IR_USE_AVR_TIMER5\n//#define IR_USE_AVR_TIMER_TINY0\n//#define IR_USE_AVR_TIMER_TINY1\n//#define IR_USE_AVR_TIMER_A\n//#define IR_USE_AVR_TIMER_B\n//#define IR_USE_AVR_TIMER_D\n//#define __MK20DX128__\n//#define __MKL26Z64__\n//#define __IMXRT1062__\n//#define ESP8266\n//#define ESP32\n//#define ARDUINO_ARCH_SAMD\n//#define ARDUINO_ARCH_MBED\n//#define ARDUINO_ARCH_RP2040\n//#define NRF5\n//#define __STM32F1__\n//#define STM32F1xx\n//#define PARTICLE\n//#define ARDUINO_ARCH_RENESAS\n\n#if defined (DOXYGEN)\n/**\n * Hardware / timer dependent pin number for sending IR if SEND_PWM_BY_TIMER is defined. Otherwise used as default for IrSender.sendPin.\n */\n#define IR_SEND_PIN\n\n/**\n * Configures the timer to be able to generate the receive sample interrupt,\n * which consumes a small amount of CPU every 50 (MICROS_PER_TICK) us.\n * The actual interrupt generation is controlled by timerEnableReceiveInterrupt() and timerDisableReceiveInterrupt().\n * timerConfigForReceive() is used exclusively by IRrecv::start()\n */\nvoid timerConfigForReceive() {\n}\n/**\n *  Enables the receive sample timer interrupt, which consumes a small amount of CPU every 50 us.\n */\nvoid timerEnableReceiveInterrupt() {\n}\n\n/**\n *  Disables the receive sample timer interrupt. This must be done before using the timer for e.g. tone().\n *  Is a synonym for calling end() or stop().\n */\nvoid timerDisableReceiveInterrupt() {\n}\n\n/**\n * IF PWM should be generated not by software, but by a timer, this function sets output pin mode,\n * configures the timer for generating a PWM with duty cycle of IR_SEND_DUTY_CYCLE_PERCENT\n * and disables the receive interrupt if it uses the same resource.\n * For most architectures, the pin number(s) which can be used for output is determined by the timer used!\n * The output of the PWM signal is controlled by enableSendPWMByTimer() and disableSendPWMByTimer().\n * timerConfigForSend() is used exclusively by IRsend::enableIROut().\n * @param aFrequencyKHz     Frequency of the sent PWM signal in kHz. There is no practical reason to have a sub kHz resolution for sending frequency :-).\n */\nvoid timerConfigForSend(uint16_t aFrequencyKHz) {\n}\n\n/**\n * Enables output of the PWM signal of the timer at the timer pin.\n */\nvoid enableSendPWMByTimer() {\n}\n/**\n * Disables output of the PWM signal of the timer at the timer pin and set it to inactive.\n */\nvoid disableSendPWMByTimer() {\n}\n\n#elif defined(__AVR__)\n/**********************************************************************************************************************\n * Mapping of AVR boards to AVR timers\n * For some CPU's you have the option to switch the timer and the hardware send pin\n **********************************************************************************************************************/\n/***************************************\n * Plain AVR CPU's, no boards\n ***************************************/\n// Arduino Duemilanove, Diecimila, LilyPad, Mini, Fio, Nano, etc\n#if defined(__AVR_ATmega328P__) || defined(__AVR_ATmega328PB__) || defined(__AVR_ATmega168__) \\\n    || defined(__AVR_ATmega88P__) || defined(__AVR_ATmega88PB__)\n#  if !defined(IR_USE_AVR_TIMER1) && !defined(IR_USE_AVR_TIMER2)\n//#define IR_USE_AVR_TIMER1   // send pin = pin 9\n#define IR_USE_AVR_TIMER2     // send pin = pin 3\n#  endif\n\n// Arduino Mega\n#elif defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)\n#  if !defined(IR_USE_AVR_TIMER1) && !defined(IR_USE_AVR_TIMER2) && !defined(IR_USE_AVR_TIMER3) && !defined(IR_USE_AVR_TIMER4) && !defined(IR_USE_AVR_TIMER5)\n//#define IR_USE_AVR_TIMER1   // send pin = pin 11\n#define IR_USE_AVR_TIMER2     // send pin = pin 9\n//#define IR_USE_AVR_TIMER3   // send pin = pin 5\n//#define IR_USE_AVR_TIMER4   // send pin = pin 6\n//#define IR_USE_AVR_TIMER5   // send pin = pin 46\n#  endif\n\n// Leonardo\n#elif defined(__AVR_ATmega32U4__) && ! defined(TEENSYDUINO) && ! defined(ARDUINO_AVR_PROMICRO)\n#  if !defined(IR_USE_AVR_TIMER1) && !defined(IR_USE_AVR_TIMER3) && !defined(IR_USE_AVR_TIMER4_HS)\n//#define IR_USE_AVR_TIMER1     // send pin = pin 9\n#define IR_USE_AVR_TIMER3       // send pin = pin 5\n//#define IR_USE_AVR_TIMER4_HS  // send pin = pin 13\n#  endif\n\n// Nano Every, Uno WiFi Rev2 and similar\n#elif defined(__AVR_ATmega808__) || defined(__AVR_ATmega809__) || defined(__AVR_ATmega3208__) || defined(__AVR_ATmega3209__) \\\n     || defined(__AVR_ATmega1608__) || defined(__AVR_ATmega1609__) || defined(__AVR_ATmega4808__) || defined(__AVR_ATmega4809__) || defined(__AVR_ATtiny1604__)\n#  if !defined(IR_USE_AVR_TIMER_B)\n#define IR_USE_AVR_TIMER_B     //  send pin = pin 6 on ATmega4809 1 on ATmega4809\n#  endif\n\n#elif defined(__AVR_ATtiny816__) || defined(__AVR_ATtiny1614__) || defined(__AVR_ATtiny1616__) || defined(__AVR_ATtiny3216__) || defined(__AVR_ATtiny3217__) // e.g. TinyCore boards\n#  if !defined(IR_USE_AVR_TIMER_A) && !defined(IR_USE_AVR_TIMER_D)\n#define IR_USE_AVR_TIMER_A // use this if you use megaTinyCore, Tone is on TCB and millis() on TCD\n//#define IR_USE_AVR_TIMER_D // use this if you use TinyCore\n#  endif\n\n// ATmega8u2, ATmega16U2, ATmega32U2, ATmega8 - Timer 2 does not work with existing code below\n#elif defined(__AVR_ATmega8U2__) || defined(__AVR_ATmega16U2__)  || defined(__AVR_ATmega32U2__) || defined(__AVR_ATmega8__)\n#  if !defined(IR_USE_AVR_TIMER1)\n#define IR_USE_AVR_TIMER1     // send pin = pin C6\n#  endif\n\n// ATtiny84\n#elif defined(__AVR_ATtiny84__) || defined(__AVR_ATtiny88__)\n#  if !defined(IR_USE_AVR_TIMER1)\n#define IR_USE_AVR_TIMER1     // send pin = pin 6\n#  endif\n\n#elif  defined(__AVR_ATtiny87__) || defined(__AVR_ATtiny167__)\n#  if !defined(IR_USE_AVR_TIMER1)\n#define IR_USE_AVR_TIMER1   // send pin = pin PB1 / 8\n#  endif\n#define USE_TIMER_CHANNEL_B\n\n//ATtiny85, 45, 25\n#elif defined(__AVR_ATtiny25__) || defined(__AVR_ATtiny45__) || defined(__AVR_ATtiny85__)\n#  if !defined(IR_USE_AVR_TIMER_TINY0) && !defined(IR_USE_AVR_TIMER_TINY1)\n#    if defined(ARDUINO_AVR_DIGISPARK) // tested with 16 and 8 MHz\n#define IR_USE_AVR_TIMER_TINY0   // send pin = pin 1\n// standard Digispark settings use timer 1 for millis() and micros()\n#    else\n// standard ATTinyCore settings use timer 0 for millis() and micros()\n#define IR_USE_AVR_TIMER_TINY1   // send pin = pin 4\n#    endif\n#  endif\n\n/***************************************\n * SPARKFUN Pro Micro board\n ***************************************/\n#elif defined(ARDUINO_AVR_PROMICRO)\n#  if !defined(IR_USE_AVR_TIMER1) && !defined(IR_USE_AVR_TIMER3) && !defined(IR_USE_AVR_TIMER4_HS)\n//#define IR_USE_AVR_TIMER1     // send pin = pin 9\n#define IR_USE_AVR_TIMER3       // send pin = pin 5\n//#define IR_USE_AVR_TIMER4_HS  // send pin = pin 13\n#  endif\n\n/***************************************\n * TEENSY Boards\n ***************************************/\n// Teensy 1.0\n#elif defined(__AVR_AT90USB162__)\n#  if !defined(IR_USE_AVR_TIMER1)\n#define IR_USE_AVR_TIMER1     // send pin = pin 17\n#  endif\n\n// Teensy++ 1.0 & 2.0\n#elif defined(__AVR_AT90USB646__) || defined(__AVR_AT90USB1286__)\n#  if !defined(IR_USE_AVR_TIMER1) && !defined(IR_USE_AVR_TIMER2) && !defined(IR_USE_AVR_TIMER3)\n//#define IR_USE_AVR_TIMER1   // send pin = pin 25\n#define IR_USE_AVR_TIMER2     // send pin = pin 1\n//#define IR_USE_AVR_TIMER3   // send pin = pin 16\n#  endif\n\n// Teensy 2.0\n#elif defined(__AVR_ATmega32U4__) && defined(TEENSYDUINO)\n#  if !defined(IR_USE_AVR_TIMER1) && !defined(IR_USE_AVR_TIMER3) && !defined(IR_USE_AVR_TIMER4_HS)\n//#define IR_USE_AVR_TIMER1     // send pin = pin 14 (Teensy 2.0 - physical pin: B5)\n//#define IR_USE_AVR_TIMER3     // send pin = pin 9  (Teensy 2.0 - physical pin: C6)\n#define IR_USE_AVR_TIMER4_HS    // send pin = pin 10 (Teensy 2.0 - physical pin: C7)\n#  endif\n\n/***************************************\n * CPU's with MegaCore\n ***************************************/\n// MegaCore - ATmega64, ATmega128\n#elif defined(__AVR_ATmega64__) || defined(__AVR_ATmega128__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__)\n#  if !defined(IR_USE_AVR_TIMER1)\n#define IR_USE_AVR_TIMER1     // send pin = pin 13\n#  endif\n\n/***************************************\n * CPU's with MajorCore\n ***************************************/\n#elif defined(__AVR_ATmega8515__) || defined(__AVR_ATmega162__)\n#  if !defined(IR_USE_AVR_TIMER1) && !defined(IR_USE_AVR_TIMER3)\n#define IR_USE_AVR_TIMER1     // send pin = pin 13\n//#define IR_USE_AVR_TIMER3   // send pin = pin 12 - ATmega162 only\n#  endif\n\n/***************************************\n * CPU's with MightyCore\n ***************************************/\n// MightyCore - ATmega1284\n#elif defined(__AVR_ATmega1284__) || defined(__AVR_ATmega1284P__)\n#  if !defined(IR_USE_AVR_TIMER1) && !defined(IR_USE_AVR_TIMER2) && !defined(IR_USE_AVR_TIMER3)\n//#define IR_USE_AVR_TIMER1   // send pin = pin 13\n#define IR_USE_AVR_TIMER2     // send pin = pin 14\n//#define IR_USE_AVR_TIMER3   // send pin = pin 6\n#  endif\n\n// MightyCore - ATmega164, ATmega324, ATmega644\n#elif defined(__AVR_ATmega644__) || defined(__AVR_ATmega644P__) \\\n|| defined(__AVR_ATmega324P__) || defined(__AVR_ATmega324A__) \\\n|| defined(__AVR_ATmega324PA__) || defined(__AVR_ATmega164A__) \\\n|| defined(__AVR_ATmega164P__)\n#  if !defined(IR_USE_AVR_TIMER1) && !defined(IR_USE_AVR_TIMER2)\n//#define IR_USE_AVR_TIMER1   // send pin = pin 13\n#define IR_USE_AVR_TIMER2     // send pin = pin 14\n#  endif\n\n// MightyCore - ATmega8535, ATmega16, ATmega32\n#elif defined(__AVR_ATmega8535__) || defined(__AVR_ATmega16__) || defined(__AVR_ATmega32__)\n#  if !defined(IR_USE_AVR_TIMER1)\n#define IR_USE_AVR_TIMER1     // send pin = pin 13\n#  endif\n\n#endif // AVR CPU's\n/**********************************************************************************************************************\n * End of AVR mapping, start of AVR timers\n **********************************************************************************************************************/\n/*\n * AVR Timer1 (16 bits)\n */\n#if defined(IR_USE_AVR_TIMER1)\n\n#  if defined(TIMSK1)\n#define TIMSK   TIMSK1 // use the value of TIMSK1 for the statements below\n#  endif\n\nvoid timerEnableReceiveInterrupt() {\n    TIMSK |= _BV(OCIE1A);\n}\nvoid timerDisableReceiveInterrupt() {\n    TIMSK &= ~_BV(OCIE1A);\n}\n\n#  if defined(USE_TIMER_CHANNEL_B)\n#    if defined(TIMER1_COMPB_vect)\n#define TIMER_INTR_NAME       TIMER1_COMPB_vect\n#    elif defined(TIM1_COMPB_vect)\n#define TIMER_INTR_NAME       TIM1_COMPB_vect\n#    endif\n#else\n#    if defined(TIMER1_COMPA_vect)\n#define TIMER_INTR_NAME       TIMER1_COMPA_vect\n#    elif defined(TIM1_COMPA_vect)\n#define TIMER_INTR_NAME       TIM1_COMPA_vect\n#    endif\n#  endif\n\nvoid timerConfigForReceive() {\n    TCCR1A = 0;\n    TCCR1B = _BV(WGM12) | _BV(CS10); // CTC mode, no prescaling\n    OCR1A = (F_CPU * MICROS_PER_TICK) / MICROS_IN_ONE_SECOND; // 16 * 50 = 800\n    TCNT1 = 0;\n}\n\n#  if defined(SEND_PWM_BY_TIMER)\n#    if defined(CORE_OC1A_PIN)\n#define IR_SEND_PIN  CORE_OC1A_PIN  // Teensy\n\n#    elif defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)\n#define IR_SEND_PIN  11             // Arduino Mega\n\n// MightyCore, MegaCore, MajorCore\n#    elif defined(__AVR_ATmega1284__) || defined(__AVR_ATmega1284P__) \\\n|| defined(__AVR_ATmega644__) || defined(__AVR_ATmega644P__) \\\n|| defined(__AVR_ATmega324P__) || defined(__AVR_ATmega324A__) \\\n|| defined(__AVR_ATmega324PA__) || defined(__AVR_ATmega164A__) \\\n|| defined(__AVR_ATmega164P__) || defined(__AVR_ATmega32__) \\\n|| defined(__AVR_ATmega16__) || defined(__AVR_ATmega8535__) \\\n|| defined(__AVR_ATmega64__) || defined(__AVR_ATmega128__) \\\n|| defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2561__) \\\n|| defined(__AVR_ATmega8515__) || defined(__AVR_ATmega162__)\n#define IR_SEND_PIN  13\n\n#    elif defined(__AVR_ATtiny84__)\n#define IR_SEND_PIN  6\n\n#    elif defined(__AVR_ATtiny88__)\n#define IR_SEND_PIN  8\n\n#    elif defined(__AVR_ATtiny87__) || defined(__AVR_ATtiny167__)\n/*\n * !!! IR_SEND_PIN value must correspond to ENABLE_SEND_PWM_BY_TIMER below !!!\n */\n#      if defined(USE_TIMER_CHANNEL_B)\n#define IR_SEND_PIN  PIN_PB1 // OC1BU / PB1 / Pin9 at ATTinyCore\n//#define IR_SEND_PIN  PIN_PB3 // OC1BV / PB3 / Pin11 at ATTinyCore\n//#define IR_SEND_PIN  PIN_PB5 // OC1BW / PB5 / Pin13 at ATTinyCore\n//#define IR_SEND_PIN  PIN_PB7 // OC1BX / PB7 / Pin15 at ATTinyCore\n#      else\n#define IR_SEND_PIN  PIN_PB0 // OC1AU / PB1 / Pin8 at ATTinyCore\n//#define IR_SEND_PIN  PIN_PB2 // OC1AV / PB3 / Pin10 at ATTinyCore\n//#define IR_SEND_PIN  PIN_PB4 // OC1AW / PB5 / Pin12 at ATTinyCore\n//#define IR_SEND_PIN  PIN_PB6 // OC1AX / PB6 / Pin14 at ATTinyCore\n#      endif\n\n#    else\n#define IR_SEND_PIN  9              // OC1A Arduino Duemilanove, Diecimila, LilyPad, Sparkfun Pro Micro, Leonardo, MH-ET Tiny88 etc.\n#    endif // defined(CORE_OC1A_PIN)\n\n#    if defined(__AVR_ATtiny87__) || defined(__AVR_ATtiny167__)\n// Clear OC1A/OC1B on Compare Match when up-counting. Set OC1A/OC1B on Compare Match when down counting.\n#      if defined(USE_TIMER_CHANNEL_B)\nvoid enableSendPWMByTimer() {\n    TCNT1 = 0;\n    TCCR1A |= _BV(COM1B1);\n    TCCR1D |= _BV(OC1BU); // + enable OC1BU as output\n    //TCNT1 = 0;  TCCR1A |= _BV(COM1B1); TCCR1D |= _BV(OC1BV); // + enable OC1BV as output\n    //TCNT1 = 0;  TCCR1A |= _BV(COM1B1); TCCR1D |= _BV(OC1BW); // + enable OC1BW as output\n    //TCNT1 = 0;  TCCR1A |= _BV(COM1B1); TCCR1D |= _BV(OC1BX); // + enable OC1BX as output\n}\n#      else\nvoid disableSendPWMByTimer() {\n    TCNT1 = 0;\n    TCCR1A |= _BV(COM1A1);\n    TCCR1D |= _BV(OC1AU); // + enable OC1BU as output\n    //TCNT1 = 0;  TCCR1A |= _BV(COM1A1); TCCR1D |= _BV(OC1AV); // + enable OC1BV as output\n    //TCNT1 = 0;  TCCR1A |= _BV(COM1A1); TCCR1D |= _BV(OC1AW); // + enable OC1BW as output\n    //TCNT1 = 0;  TCCR1A |= _BV(COM1A1); TCCR1D |= _BV(OC1AX); // + enable OC1BX as output\n}\n\n#      endif\nvoid disableSendPWMByTimer() {\n    TCCR1D = 0;\n}\n#    else\n#      if defined(USE_TIMER_CHANNEL_B)\nvoid enableSendPWMByTimer() {\n    TCNT1 = 0;\n    TCCR1A |= _BV(COM1B1);  // Clear OC1A/OC1B on Compare Match when up-counting. Set OC1A/OC1B on Compare Match when counting down.\n}\nvoid disableSendPWMByTimer() {\n    TCCR1A &= ~(_BV(COM1B1));\n}\n#      else\nvoid enableSendPWMByTimer() {\n    TCNT1 = 0;\n    TCCR1A |= _BV(COM1A1); // Clear OC1A/OC1B on Compare Match when up-counting. Set OC1A/OC1B on Compare Match when downcounting.\n}\nvoid disableSendPWMByTimer() {\n    TCCR1A &= ~(_BV(COM1A1));\n}\n#      endif\n#    endif\n\n/*\n * timerConfigForSend() is used exclusively by IRsend::enableIROut()\n * Set output pin mode and disable receive interrupt if it uses the same resource\n */\nvoid timerConfigForSend(uint16_t aFrequencyKHz) {\n    timerDisableReceiveInterrupt();\n\n#  if (((F_CPU / 2000) / 38) < 256)\n    const uint16_t tPWMWrapValue = (F_CPU / 2000) / (aFrequencyKHz); // 210,52 for 38 kHz @16 MHz clock, 2000 instead of 1000 because of Phase Correct PWM\n    TCCR1A = _BV(WGM11); // PWM, Phase Correct, Top is ICR1\n    TCCR1B = _BV(WGM13) | _BV(CS10); // CS10 -> no prescaling\n    ICR1 = tPWMWrapValue - 1;\n#    if defined(USE_TIMER_CHANNEL_B)\n    OCR1B = ((tPWMWrapValue * IR_SEND_DUTY_CYCLE_PERCENT) / 100) - 1;\n#    else\n    OCR1A = ((tPWMWrapValue * IR_SEND_DUTY_CYCLE_PERCENT) / 100) - 1;\n#    endif\n    TCNT1 = 0; // not really required, since we have an 8 bit counter, but makes the signal more reproducible\n#  else\n    const uint16_t tPWMWrapValue = ((F_CPU / 8) / 2000) / (aFrequencyKHz); // 2000 instead of 1000 because of Phase Correct PWM\n    TCCR1A = _BV(WGM11);// PWM, Phase Correct, Top is ICR1\n    TCCR1B = _BV(WGM13) | _BV(CS11);// CS11 -> Prescaling by 8\n    ICR1 = tPWMWrapValue - 1;\n#    if defined(USE_TIMER_CHANNEL_B)\n    OCR1A = ((tPWMWrapValue * IR_SEND_DUTY_CYCLE_PERCENT) / 100) - 1;\n#    else\n    OCR1A = ((tPWMWrapValue * IR_SEND_DUTY_CYCLE_PERCENT) / 100) - 1;\n#    endif\n    TCNT1 = 0; // not really required, since we have an 8 bit counter, but makes the signal more reproducible\n#  endif\n}\n#  endif // defined(SEND_PWM_BY_TIMER)\n\n/*\n * AVR Timer2 (8 bits) // Tone timer on Uno\n */\n#elif defined(IR_USE_AVR_TIMER2)\n\nvoid timerEnableReceiveInterrupt() {\n    TIMSK2 = _BV(OCIE2B);   // Output Compare Match A Interrupt Enable\n}\nvoid timerDisableReceiveInterrupt() {\n    TIMSK2 = 0;\n}\n#define TIMER_INTR_NAME             TIMER2_COMPB_vect                   // We use TIMER2_COMPB_vect to be compatible with tone() library\n\n#define TIMER_COUNT_TOP  (F_CPU * MICROS_PER_TICK / MICROS_IN_ONE_SECOND)\n\nvoid timerConfigForReceive() {\n#  if (TIMER_COUNT_TOP < 256)\n    TCCR2A = _BV(WGM21);\n    TCCR2B = _BV(CS20);\n    OCR2A = TIMER_COUNT_TOP;\n    OCR2B = TIMER_COUNT_TOP;\n    TCNT2 = 0;\n#  else\n    TCCR2A = _BV(WGM21);\n    TCCR2B = _BV(CS21);\n    OCR2A = TIMER_COUNT_TOP / 8;\n    OCR2B = TIMER_COUNT_TOP / 8;\n    TCNT2 = 0;\n#  endif\n}\n\n#  if defined(SEND_PWM_BY_TIMER)\n#    if defined(CORE_OC2B_PIN)\n#define IR_SEND_PIN  CORE_OC2B_PIN  // Teensy\n\n#    elif defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)\n#define IR_SEND_PIN  9              // Arduino Mega\n\n#    elif defined(__AVR_ATmega1284__) || defined(__AVR_ATmega1284P__) \\\n|| defined(__AVR_ATmega644__) || defined(__AVR_ATmega644P__) \\\n|| defined(__AVR_ATmega324P__) || defined(__AVR_ATmega324A__) \\\n|| defined(__AVR_ATmega324PA__) || defined(__AVR_ATmega164A__) \\\n|| defined(__AVR_ATmega164P__)\n#define IR_SEND_PIN  14             // MightyCore, MegaCore\n\n#    else\n#define IR_SEND_PIN  3              // Arduino Duemilanove, Diecimila, LilyPad, etc\n#    endif // defined(CORE_OC2B_PIN)\n\nvoid enableSendPWMByTimer() {\n    TCNT2 = 0;\n    TCCR2A |= _BV(COM2B1);          // Clear OC2B on Compare Match\n}\nvoid disableSendPWMByTimer() {\n    TCCR2A &= ~(_BV(COM2B1));      // Normal port operation, OC2B disconnected.\n}\n\n/*\n * timerConfigForSend() is used exclusively by IRsend::enableIROut()\n * Set output pin mode and disable receive interrupt if it uses the same resource\n */\nvoid timerConfigForSend(uint16_t aFrequencyKHz) {\n    timerDisableReceiveInterrupt();\n\n#  if (((F_CPU / 2000) / 38) < 256)\n    /*\n     * tPWMWrapValue is 210.52 for 38 kHz, 17.58 for 455 kHz @16 MHz clock.\n     * 210 -> 38.095 kHz, 17 -> 470.588 kHz @16 MHz clock.\n     * We use 2000 instead of 1000 in the formula, because of Phase Correct PWM.\n     */\n    const uint16_t tPWMWrapValue = (F_CPU / 2000) / (aFrequencyKHz);\n    TCCR2A = _BV(WGM20); // PWM, Phase Correct, Top is OCR2A\n    TCCR2B = _BV(WGM22) | _BV(CS20); // CS20 -> no prescaling\n    OCR2A = tPWMWrapValue - 1; // The top value for the timer.  The modulation frequency will be F_CPU / 2 / (OCR2A + 1).\n    OCR2B = ((tPWMWrapValue * IR_SEND_DUTY_CYCLE_PERCENT) / 100) - 1;\n    TCNT2 = 0; // not really required, since we have an 8 bit counter, but makes the signal more reproducible\n#  else\n    const uint16_t tPWMWrapValue = ((F_CPU / 8) / 2000) / (aFrequencyKHz); // 2000 instead of 1000 because of Phase Correct PWM\n    TCCR2A = _BV(WGM20);// PWM, Phase Correct, Top is OCR2A\n    TCCR2B = _BV(WGM22) | _BV(CS21);// CS21 -> Prescaling by 8\n    OCR2A = tPWMWrapValue - 1;\n    OCR2B = ((tPWMWrapValue * IR_SEND_DUTY_CYCLE_PERCENT) / 100) - 1;\n    TCNT2 = 0;// not really required, since we have an 8 bit counter, but makes the signal more reproducible\n#  endif\n}\n#  endif // defined(SEND_PWM_BY_TIMER)\n\n/*\n * AVR Timer3 (16 bits)\n */\n#elif defined(IR_USE_AVR_TIMER3)\n\nvoid timerEnableReceiveInterrupt() {\n    TIMSK3 = _BV(OCIE3B);\n}\nvoid timerDisableReceiveInterrupt() {\n    TIMSK3 = 0;\n}\n#define TIMER_INTR_NAME             TIMER3_COMPB_vect\n\nvoid timerConfigForReceive() {\n    TCCR3A = 0;\n    TCCR3B = _BV(WGM32) | _BV(CS30);\n    OCR3A = F_CPU * MICROS_PER_TICK / MICROS_IN_ONE_SECOND;\n    OCR3B = F_CPU * MICROS_PER_TICK / MICROS_IN_ONE_SECOND;\n    TCNT3 = 0;\n}\n\n#  if defined(SEND_PWM_BY_TIMER)\n#    if defined(CORE_OC3A_PIN)\n#define IR_SEND_PIN  CORE_OC3A_PIN  // Teensy\n\n#    elif defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__) \\\n|| defined(__AVR_ATmega32U4__) || defined(ARDUINO_AVR_PROMICRO)\n#define IR_SEND_PIN  5              // Arduino Mega, Arduino Leonardo, Sparkfun Pro Micro\n\n#    elif defined(__AVR_ATmega1284__) || defined(__AVR_ATmega1284P__)\n#define IR_SEND_PIN  6              // MightyCore, MegaCore\n\n#    else\n#error Please add OC3A pin number here\n#    endif\n\nvoid enableSendPWMByTimer() {\n    TCNT3 = 0;\n    TCCR3A |= _BV(COM3A1);\n}\nvoid disableSendPWMByTimer() {\n    TCCR3A &= ~(_BV(COM3A1));\n}\n\n/*\n * timerConfigForSend() is used exclusively by IRsend::enableIROut()\n * Set output pin mode and disable receive interrupt if it uses the same resource\n */\nvoid timerConfigForSend(uint16_t aFrequencyKHz) {\n#if F_CPU > 16000000\n#error \"Creating timer PWM with timer 3 is not supported for F_CPU > 16 MHz\"\n#endif\n    timerDisableReceiveInterrupt();\n\n    const uint16_t tPWMWrapValue = (F_CPU / 2000) / (aFrequencyKHz); // 210,52 for 38 kHz @16 MHz clock, 2000 instead of 1000 because of Phase Correct PWM\n    TCCR3A = _BV(WGM31);\n    TCCR3B = _BV(WGM33) | _BV(CS30); // PWM, Phase Correct, ICRn as TOP, complete period is double of tPWMWrapValue\n    ICR3 = tPWMWrapValue - 1;\n    OCR3A = ((tPWMWrapValue * IR_SEND_DUTY_CYCLE_PERCENT) / 100) - 1;\n    TCNT3 = 0; // required, since we have an 16 bit counter\n}\n#  endif // defined(SEND_PWM_BY_TIMER)\n\n/*\n * AVR Timer4 (16 bits)\n */\n#elif defined(IR_USE_AVR_TIMER4)\nvoid timerEnableReceiveInterrupt() {\n    TIMSK4 = _BV(OCIE4A);\n}\nvoid timerDisableReceiveInterrupt() {\n    TIMSK4 = 0;\n}\n#define TIMER_INTR_NAME             TIMER4_COMPA_vect\n\nvoid timerConfigForReceive() {\n    TCCR4A = 0;\n    TCCR4B = _BV(WGM42) | _BV(CS40);\n    OCR4A = F_CPU * MICROS_PER_TICK / MICROS_IN_ONE_SECOND;\n    TCNT4 = 0;\n}\n\n#  if defined(SEND_PWM_BY_TIMER)\n#    if defined(CORE_OC4A_PIN)\n#define IR_SEND_PIN  CORE_OC4A_PIN\n#    elif defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)\n#define IR_SEND_PIN  6  // Arduino Mega\n#    else\n#error Please add OC4A pin number here\n#    endif\n\nvoid enableSendPWMByTimer() {\n    TCNT4 = 0;\n    TCCR4A |= _BV(COM4A1);\n}\nvoid disableSendPWMByTimer() {\n    TCCR4A &= ~(_BV(COM4A1));\n}\n\nvoid timerConfigForSend(uint16_t aFrequencyKHz) {\n#if F_CPU > 16000000\n#error \"Creating timer PWM with timer 4 is not supported for F_CPU > 16 MHz\"\n#endif\n    timerDisableReceiveInterrupt();\n    const uint16_t tPWMWrapValue = (F_CPU / 2000) / (aFrequencyKHz); // 210,52 for 38 kHz @16 MHz clock, 2000 instead of 1000 because of Phase Correct PWM\n    TCCR4A = _BV(WGM41);\n    TCCR4B = _BV(WGM43) | _BV(CS40);\n    ICR4 = tPWMWrapValue - 1;\n    OCR4A = ((tPWMWrapValue * IR_SEND_DUTY_CYCLE_PERCENT) / 100) - 1;\n    TCNT4 = 0; // required, since we have an 16 bit counter\n}\n#  endif // defined(SEND_PWM_BY_TIMER)\n\n/*\n * AVR Timer4 (10 bits, high speed option)\n */\n#elif defined(IR_USE_AVR_TIMER4_HS)\n\nvoid timerEnableReceiveInterrupt() {\n    TIMSK4 = _BV(TOIE4);\n}\nvoid timerDisableReceiveInterrupt() {\n    TIMSK4 = 0;\n}\n#define TIMER_INTR_NAME             TIMER4_OVF_vect\n\nvoid timerConfigForReceive() {\n    TCCR4A = 0;\n    TCCR4B = _BV(CS40);\n    TCCR4C = 0;\n    TCCR4D = 0;\n    TCCR4E = 0;\n    TC4H = (F_CPU * MICROS_PER_TICK / MICROS_IN_ONE_SECOND) >> 8;\n    OCR4C = (F_CPU * MICROS_PER_TICK / MICROS_IN_ONE_SECOND) & 255;\n    TC4H = 0;\n    TCNT4 = 0;\n}\n\n#  if defined(SEND_PWM_BY_TIMER)\n#    if defined(CORE_OC4A_PIN)\n#define IR_SEND_PIN  CORE_OC4A_PIN  // Teensy 2.0\n#    elif defined(ARDUINO_AVR_PROMICRO)\n#define IR_SEND_PIN  5              // Sparkfun Pro Micro\n#    elif defined(__AVR_ATmega32U4__)\n#define IR_SEND_PIN  13             // Leonardo\n#    else\n#error Please add OC4A pin number here\n#    endif\n\n#    if defined(ARDUINO_AVR_PROMICRO) // Sparkfun Pro Micro\nvoid enableSendPWMByTimer() {\n    TCNT4 = 0;\n    TCCR4A |= _BV(COM4A0);     // Use complementary OC4A output on pin 5\n}\nvoid disableSendPWMByTimer() {\n    TCCR4A &= ~(_BV(COM4A0));  // (Pro Micro does not map PC7 (32/ICP3/CLK0/OC4A)\n}\n// of ATmega32U4 )\n#    else\nvoid enableSendPWMByTimer() {\n    TCNT4 = 0;\n    TCCR4A |= _BV(COM4A1);\n    DDRC |= 1 << 7;\n}\nvoid disableSendPWMByTimer() {\n    TCCR4A &= ~(_BV(COM4A1));\n}\n#    endif\n\n/*\n * timerConfigForSend() is used exclusively by IRsend::enableIROut()\n * Set output pin mode and disable receive interrupt if it uses the same resource\n */\nvoid timerConfigForSend(uint16_t aFrequencyKHz) {\n#if F_CPU > 16000000\n#error \"Creating timer PWM with timer 4 HS is not supported for F_CPU > 16 MHz\"\n#endif\n    timerDisableReceiveInterrupt();\n\n    const uint16_t tPWMWrapValue = ((F_CPU / 2000) / (aFrequencyKHz)) - 1; // 210,52 for 38 kHz @16 MHz clock, 2000 instead of 1000 because of Phase Correct PWM\n    TCCR4A = (1 << PWM4A);\n    TCCR4B = _BV(CS40);\n    TCCR4C = 0;\n    TCCR4D = (1 << WGM40);\n    TCCR4E = 0;\n    TC4H = tPWMWrapValue >> 8;\n    OCR4C = tPWMWrapValue;\n    TC4H = (tPWMWrapValue * IR_SEND_DUTY_CYCLE_PERCENT / 100) >> 8;\n    OCR4A = (tPWMWrapValue * IR_SEND_DUTY_CYCLE_PERCENT / 100) & 255;\n    TCNT4 = 0; // not really required, since we have an 8 bit counter, but makes the signal more reproducible\n}\n#  endif // defined(SEND_PWM_BY_TIMER)\n\n/*\n * AVR Timer5 (16 bits)\n */\n#elif defined(IR_USE_AVR_TIMER5)\n\nvoid timerEnableReceiveInterrupt() {\n    TIMSK5 = _BV(OCIE5A);\n}\nvoid timerDisableReceiveInterrupt() {\n    TIMSK5 = 0;\n}\n#define TIMER_INTR_NAME             TIMER5_COMPA_vect\n\nvoid timerConfigForReceive() {\n    TCCR5A = 0;\n    TCCR5B = _BV(WGM52) | _BV(CS50);\n    OCR5A = F_CPU * MICROS_PER_TICK / MICROS_IN_ONE_SECOND;\n    TCNT5 = 0;\n}\n\n#  if defined(SEND_PWM_BY_TIMER)\n#    if defined(CORE_OC5A_PIN)\n#define IR_SEND_PIN  CORE_OC5A_PIN\n#    elif defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)\n#define IR_SEND_PIN  46  // Arduino Mega\n#    else\n#error Please add OC5A pin number here\n#    endif\n\nvoid enableSendPWMByTimer() {\n    TCNT5 = 0;\n    TCCR5A |= _BV(COM5A1);\n}\nvoid disableSendPWMByTimer() {\n    TCCR5A &= ~(_BV(COM5A1));\n}\n\n/*\n * timerConfigForSend() is used exclusively by IRsend::enableIROut()\n * Set output pin mode and disable receive interrupt if it uses the same resource\n */\nvoid timerConfigForSend(uint16_t aFrequencyKHz) {\n#if F_CPU > 16000000\n#error \"Creating timer PWM with timer 5 is not supported for F_CPU > 16 MHz\"\n#endif\n    timerDisableReceiveInterrupt();\n\n    const uint16_t tPWMWrapValue = (F_CPU / 2000) / (aFrequencyKHz); // 210,52 for 38 kHz @16 MHz clock, 2000 instead of 1000 because of Phase Correct PWM\n    TCCR5A = _BV(WGM51);\n    TCCR5B = _BV(WGM53) | _BV(CS50);\n    ICR5 = tPWMWrapValue - 1;\n    OCR5A = ((tPWMWrapValue * IR_SEND_DUTY_CYCLE_PERCENT) / 100) - 1;\n    TCNT5 = 0; // required, since we have an 16 bit counter\n}\n#  endif // defined(SEND_PWM_BY_TIMER)\n\n/*\n * AVR Timer0 for ATtinies (8 bits)\n */\n#elif defined(IR_USE_AVR_TIMER_TINY0)\n\nvoid timerEnableReceiveInterrupt() {\n    TIMSK |= _BV(OCIE0A);\n}\nvoid timerDisableReceiveInterrupt() {\n    TIMSK &= ~(_BV(OCIE0A));\n}\n#define TIMER_INTR_NAME                 TIMER0_COMPA_vect\n\n#define TIMER_COUNT_TOP  (F_CPU * MICROS_PER_TICK / MICROS_IN_ONE_SECOND)\n\nvoid timerConfigForReceive() {\n#  if (TIMER_COUNT_TOP < 256)\n    TCCR0A = _BV(WGM01); // CTC, Top is OCR0A\n    TCCR0B = _BV(CS00);// No prescaling\n    OCR0A = TIMER_COUNT_TOP;\n    TCNT0 = 0;\n#  else\n    TCCR0A = _BV(WGM01);\n    TCCR0B = _BV(CS01); // prescaling by 8\n    OCR0A = TIMER_COUNT_TOP / 8;\n    TCNT0 = 0;\n#  endif\n}\n\n#  if defined(SEND_PWM_BY_TIMER)\n#define IR_SEND_PIN        1\n\nvoid enableSendPWMByTimer() {\n    TCNT0 = 0;\n    TCCR0A |= _BV(COM0B1);\n}\nvoid disableSendPWMByTimer() {\n    TCCR0A &= ~(_BV(COM0B1));\n}\n\n/*\n * timerConfigForSend() is used exclusively by IRsend::enableIROut()\n * Set output pin mode and disable receive interrupt if it uses the same resource\n */\nvoid timerConfigForSend(uint16_t aFrequencyKHz) {\n#if F_CPU > 16000000\n#error \"Creating timer PWM with timer TINY0 is not supported for F_CPU > 16 MHz\"\n#endif\n    timerDisableReceiveInterrupt();\n\n    const uint16_t tPWMWrapValue = (F_CPU / 2000) / (aFrequencyKHz); // 210,52 for 38 kHz @16 MHz clock, 2000 instead of 1000 because of Phase Correct PWM\n    TCCR0A = _BV(WGM00); // PWM, Phase Correct, Top is OCR0A\n    TCCR0B = _BV(WGM02) | _BV(CS00); // CS00 -> no prescaling\n    OCR0A = tPWMWrapValue - 1;\n    OCR0B = ((tPWMWrapValue * IR_SEND_DUTY_CYCLE_PERCENT) / 100) - 1;\n    TCNT0 = 0; // not really required, since we have an 8 bit counter, but makes the signal more reproducible\n}\n#  endif // defined(SEND_PWM_BY_TIMER)\n\n/*\n * AVR Timer1 for ATtinies (8 bits)\n */\n#elif defined(IR_USE_AVR_TIMER_TINY1)\n\nvoid timerEnableReceiveInterrupt() {\n    TIMSK |= _BV(OCIE1B);\n}\nvoid timerDisableReceiveInterrupt() {\n    TIMSK &= ~(_BV(OCIE1B));\n}\n#define TIMER_INTR_NAME             TIMER1_COMPB_vect\n\n#define TIMER_COUNT_TOP  (F_CPU * MICROS_PER_TICK / MICROS_IN_ONE_SECOND)\n\nvoid timerConfigForReceive() {\n#  if (TIMER_COUNT_TOP < 256)\n    TCCR1 = _BV(CTC1) | _BV(CS10); // Clear Timer/Counter on Compare Match, Top is OCR1C, No prescaling\n    GTCCR = 0;// normal, non-PWM mode\n    OCR1C = TIMER_COUNT_TOP;\n    TCNT1 = 0;\n#  else\n    TCCR1 = _BV(CTC1) | _BV(CS12); // Clear Timer/Counter on Compare Match, Top is OCR1C, prescaling by 8\n    GTCCR = 0; // normal, non-PWM mode\n    OCR1C = TIMER_COUNT_TOP / 8;\n    TCNT1 = 0;\n#  endif\n}\n\n#  if defined(SEND_PWM_BY_TIMER)\n#define IR_SEND_PIN        4\n\nvoid enableSendPWMByTimer() {\n    TCNT1 = 0;\n    GTCCR |= _BV(PWM1B) | _BV(COM1B0); // Enable pin 4 PWM output (PB4 - Arduino D4)\n}\nvoid disableSendPWMByTimer() {\n    GTCCR &= ~(_BV(PWM1B) | _BV(COM1B0));\n}\n\n/*\n * timerConfigForSend() is used exclusively by IRsend::enableIROut()\n * Set output pin mode and disable receive interrupt if it uses the same resource\n */\nvoid timerConfigForSend(uint16_t aFrequencyKHz) {\n    timerDisableReceiveInterrupt();\n\n#  if (((F_CPU / 1000) / 38) < 256)\n    const uint16_t tPWMWrapValue = (F_CPU / 1000) / (aFrequencyKHz); // 421 @16 MHz, 26 @1 MHz and 38 kHz\n    TCCR1 = _BV(CTC1) | _BV(CS10);// CTC1 = 1: TOP value set to OCR1C, CS10 No Prescaling\n    OCR1C = tPWMWrapValue - 1;\n    OCR1B = ((tPWMWrapValue * IR_SEND_DUTY_CYCLE_PERCENT) / 100) - 1;\n    TCNT1 = 0;// not really required, since we have an 8 bit counter, but makes the signal more reproducible\n    GTCCR = _BV(PWM1B) | _BV(COM1B0);// PWM1B = 1: Enable PWM for OCR1B, COM1B0 Clear on compare match\n#  else\n    const uint16_t tPWMWrapValue = ((F_CPU / 2) / 1000) / (aFrequencyKHz); // 210 for 16 MHz and 38 kHz\n    TCCR1 = _BV(CTC1) | _BV(CS11); // CTC1 = 1: TOP value set to OCR1C, CS11 Prescaling by 2\n    OCR1C = tPWMWrapValue - 1;\n    OCR1B = ((tPWMWrapValue * IR_SEND_DUTY_CYCLE_PERCENT) / 100) - 1;\n    TCNT1 = 0; // not really required, since we have an 8 bit counter, but makes the signal more reproducible\n    GTCCR = _BV(PWM1B) | _BV(COM1B0); // PWM1B = 1: Enable PWM for OCR1B, COM1B0 Clear on compare match\n#  endif\n}\n#  endif // defined(SEND_PWM_BY_TIMER)\n\n/*\n * AVR TimerA for TinyCore 32 (16 bits)\n */\n#elif defined(IR_USE_AVR_TIMER_A)\n#define TIMER_REQUIRES_RESET_INTR_PENDING\nvoid timerResetInterruptPending() {\n    TCA0.SINGLE.INTFLAGS = TCA_SINGLE_OVF_bm;\n}\nvoid timerEnableReceiveInterrupt() {\n    TCA0.SINGLE.INTCTRL = TCA_SINGLE_OVF_bm;\n}\nvoid timerDisableReceiveInterrupt() {\n    TCA0.SINGLE.INTCTRL &= ~(TCA_SINGLE_OVF_bm);\n}\n#define TIMER_INTR_NAME             TCA0_OVF_vect\n// For MegaTinyCore:\n// TCB1 is used by Tone()\n// TCB2 is used by Servo, but we cannot hijack the ISR, so we must use a dedicated timer for the 20 ms interrupt\n// TCB3 is used by millis()\n// Must use TCA0, since TCBx have only prescaler %2. Use single (16bit) mode, because it seems to be easier :-)\nvoid timerConfigForReceive() {\n    TCA0.SINGLE.CTRLD = 0; // Single mode - required at least for MegaTinyCore\n    TCA0.SINGLE.CTRLB = TCA_SINGLE_WGMODE_NORMAL_gc;                        // Normal mode, top = PER\n    TCA0.SINGLE.PER = (F_CPU / MICROS_IN_ONE_SECOND) * MICROS_PER_TICK;     // 800 at 16 MHz\n    TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV1_gc | TCA_SINGLE_ENABLE_bm;   // set prescaler to 1 and enable timer\n}\n\n#  if defined(SEND_PWM_BY_TIMER)\n#error \"No support for hardware PWM generation for ATtiny3216/17 etc.\"\n#  endif // defined(SEND_PWM_BY_TIMER)\n\n/*\n * AVR TimerB  (8 bits) for ATmega4809 (Nano Every, Uno WiFi Rev2)\n */\n#elif defined(IR_USE_AVR_TIMER_B)\n\n// ATmega4809 TCB0\n#define TIMER_REQUIRES_RESET_INTR_PENDING\nvoid timerResetInterruptPending() {\n    TCB0.INTFLAGS = TCB_CAPT_bm;\n}\nvoid timerEnableReceiveInterrupt() {\n    TCB0.INTCTRL = TCB_CAPT_bm;\n}\nvoid timerDisableReceiveInterrupt() {\n    TCB0.INTCTRL &= ~(TCB_CAPT_bm);\n}\n#define TIMER_INTR_NAME             TCB0_INT_vect\n\nvoid timerConfigForReceive() {\n    TCB0.CTRLB = (TCB_CNTMODE_INT_gc);  // Periodic interrupt mode\n    TCB0.CCMP = ((F_CPU * MICROS_PER_TICK) / MICROS_IN_ONE_SECOND);\n    TCB0.INTFLAGS = TCB_CAPT_bm;  // reset interrupt flags\n    TCB0.CTRLA = (TCB_CLKSEL_CLKDIV1_gc) | (TCB_ENABLE_bm);\n}\n\n#  if defined(SEND_PWM_BY_TIMER)\n#    if defined(__AVR_ATmega4808__) || defined(__AVR_ATmega4809__)\n#define IR_SEND_PIN        6 // PF4 on ATmega4809 / Nano Every (see pins_arduino.h digital_pin_to_timer)\n#    else\n#error SEND_PWM_BY_TIMER not yet supported for this CPU\n#    endif\n\nvoid enableSendPWMByTimer() {\n    TCB0.CNT = 0;\n    TCB0.CTRLB |= TCB_CCMPEN_bm;    // set Compare/Capture Output Enable\n}\nvoid disableSendPWMByTimer() {\n    TCB0.CTRLB &= ~(TCB_CCMPEN_bm);\n}\n\n/*\n * timerConfigForSend() is used exclusively by IRsend::enableIROut()\n * Set output pin mode and disable receive interrupt if it uses the same resource\n */\nvoid timerConfigForSend(uint16_t aFrequencyKHz) {\n#if F_CPU > 16000000\n        // we have only prescaler 2 or must take clock of timer A (which is non deterministic)\n#error \"Creating timer PWM with timer TCB0 is not possible for F_CPU > 16 MHz\"\n#endif\n    timerDisableReceiveInterrupt();\n\n    const uint16_t tPWMWrapValue = (F_CPU / 2000) / (aFrequencyKHz); // 210,52 for 38 kHz @16 MHz clock, 2000 instead of 1000 because of using CLK / 2\n    TCB0.CTRLB = TCB_CNTMODE_PWM8_gc; // 8 bit PWM mode\n    TCB0.CCMPL = tPWMWrapValue - 1; // Period of 8 bit PWM\n    TCB0.CCMPH = ((tPWMWrapValue * IR_SEND_DUTY_CYCLE_PERCENT) / 100) - 1; // Duty cycle of waveform of 8 bit PWM\n    TCB0.CTRLA = (TCB_CLKSEL_CLKDIV2_gc) | (TCB_ENABLE_bm); // use CLK / 2\n    TCB0.CNT = 0; // not really required, since we have an 8 bit counter, but makes the signal more reproducible\n}\n#  endif // defined(SEND_PWM_BY_TIMER)\n\n/*\n * AVR TimerD for TinyCore 32 (16 bits)\n */\n#elif defined(IR_USE_AVR_TIMER_D)\n\n#define TIMER_REQUIRES_RESET_INTR_PENDING\nvoid timerResetInterruptPending() {\n    TCD0.INTFLAGS = TCD_OVF_bm;\n}\nvoid timerEnableReceiveInterrupt() {\n    TCD0.INTCTRL = TCD_OVF_bm;\n}\nvoid timerDisableReceiveInterrupt() {\n    TCD0.INTCTRL = 0;\n}\n#define TIMER_INTR_NAME             TCD0_OVF_vect\n\nvoid timerConfigForReceive() {\n    TCD0.CTRLA = 0;                     // reset enable bit in order to unprotect the other bits\n    TCD0.CTRLB = TCD_WGMODE_ONERAMP_gc; // must be set since it is used by PWM\n//    TCD0.CMPBSET = 80;\n    TCD0.CMPBCLR = ((F_CPU * MICROS_PER_TICK) / MICROS_IN_ONE_SECOND) - 1;\n\n    _PROTECTED_WRITE(TCD0.FAULTCTRL, 0); // must disable WOA output at pin 13/PA4\n\n    TCD0.INTFLAGS = TCD_OVF_bm;         // reset interrupt flags\n    // check enable ready\n//    while ((TCD0.STATUS & TCD_ENRDY_bm) == 0); // Wait for Enable Ready to be high - I guess it is not required\n    // enable timer - this locks the other bits and static registers and activates values in double buffered registers\n    TCD0.CTRLA = TCD_ENABLE_bm | TCD_CLKSEL_SYSCLK_gc | TCD_CNTPRES_DIV1_gc; // System clock, no prescale, no synchronization prescaler\n}\n\n#  if defined(SEND_PWM_BY_TIMER)\n#define IR_SEND_PIN 13\n\nvoid timerEnableSendPWM() {\n    TCD0.CTRLA = 0;                                                 // reset enable bit in order to unprotect the other bits\n    _PROTECTED_WRITE(TCD0.FAULTCTRL, FUSE_CMPAEN_bm);                                             // enable WOA output at pin 13/PA4\n//    _PROTECTED_WRITE(TCD0.FAULTCTRL, FUSE_CMPAEN_bm | FUSE_CMPBEN_bm); // enable WOA + WOB output pins at 13/PA4 + 14/PA5\n    TCD0.CTRLA = TCD_ENABLE_bm | TCD_CLKSEL_SYSCLK_gc | TCD_CNTPRES_DIV1_gc; // System clock, no prescale, no synchronization prescaler\n}\n\nvoid enableSendPWMByTimer() {\n    timerEnableSendPWM();\n}\nvoid disableSendPWMByTimer() {\n    TCD0.CTRLA = 0; // do not disable output, disable complete timer\n}\n\n/*\n * timerConfigForSend() is used exclusively by IRsend::enableIROut()\n * Set output pin mode and disable receive interrupt if it uses the same resource\n */\nvoid timerConfigForSend(uint16_t aFrequencyKHz) {\n    timerDisableReceiveInterrupt();\n\n    const uint16_t tPWMWrapValue = (F_CPU / 1000) / (aFrequencyKHz);    // 526,31 for 38 kHz @20 MHz clock\n    // use one ramp mode and overflow interrupt\n    TCD0.CTRLA = 0;        // reset enable bit in order to unprotect the other bits\n//    while ((TCD0.STATUS & TCD_ENRDY_bm) == 0);                      // Wait for Enable Ready to be high - I guess it is not required\n    TCD0.CTRLB = TCD_WGMODE_ONERAMP_gc;        // must be set since it is used by PWM\n    TCD0.CTRLC = 0;        // reset WOx output settings\n//    TCD0.CMPBSET = 80;\n    TCD0.CMPBCLR = tPWMWrapValue - 1;\n\n    // Generate duty cycle signal for debugging etc.\n    TCD0.CMPASET = 0;\n    TCD0.CMPACLR = (tPWMWrapValue * IR_SEND_DUTY_CYCLE_PERCENT / 100) - 1;        // duty cycle for WOA\n\n    TCD0.INTFLAGS = TCD_OVF_bm;        // reset interrupt flags\n    TCD0.INTCTRL = TCD_OVF_bm;        // overflow interrupt\n    // Do not enable timer, this is done at timerEnablSendPWM()\n}\n#  endif // defined(SEND_PWM_BY_TIMER)\n\n#else\n#error Internal code configuration error, no timer functions implemented for this AVR CPU / board\n#endif //defined(IR_USE_AVR_TIMER*)\n/**********************************************************************************************************************\n * End of AVR timers\n **********************************************************************************************************************/\n\n/**********************************************\n * Uno R4 boards\n **********************************************/\n#elif defined(ARDUINO_ARCH_RENESAS)\n#include \"FspTimer.h\"\nFspTimer s50usTimer;\n\n// Undefine ISR, because we register/call the plain function IRReceiveTimerInterruptHandler()\n#  if defined(ISR)\n#undef ISR\n#  endif\n\n// callback method used by timer\nvoid IRTimerInterruptHandlerHelper(timer_callback_args_t __attribute((unused)) *p_args) {\n    IRReceiveTimerInterruptHandler();\n}\nvoid timerEnableReceiveInterrupt() {\n//    s50usTimer.enable_overflow_irq();\n    s50usTimer.start();\n}\nvoid timerDisableReceiveInterrupt() {\n//    s50usTimer.disable_overflow_irq();\n    s50usTimer.stop(); // May save power\n}\n\nvoid timerConfigForReceive() {\n    uint8_t tTimerType = GPT_TIMER;\n    int8_t tIndex = FspTimer::get_available_timer(tTimerType); // Get first unused channel. Here we need the address of tTimerType\n    if (tIndex < 0 || tTimerType != GPT_TIMER) {\n        // here we found no unused GPT channel\n        tIndex = FspTimer::get_available_timer(tTimerType, true); // true to force use of already used PWM channel. Sets \"force_pwm_reserved\" if timer found\n        if (tIndex < 0) {\n            // If we already get an tIndex < 0 we have an error, but do not know how to handle :-(\n            return;\n        }\n    }\n    s50usTimer.begin(TIMER_MODE_PERIODIC, tTimerType, tIndex, MICROS_IN_ONE_SECOND / MICROS_PER_TICK, 0.0,\n            IRTimerInterruptHandlerHelper);\n    s50usTimer.setup_overflow_irq();\n    s50usTimer.open(); // In turn calls R_GPT_Enable()\n    s50usTimer.stop(); // May save power\n}\n\n#  if defined(SEND_PWM_BY_TIMER)\n#error PWM generation by hardware not yet implemented for Arduino Uno R4\n// Not yet implemented\nvoid enableSendPWMByTimer() {\n}\nvoid disableSendPWMByTimer() {\n}\n\n/*\n * timerConfigForSend() is used exclusively by IRsend::enableIROut()\n */\nvoid timerConfigForSend(uint16_t aFrequencyKHz) {\n#    if defined(IR_SEND_PIN)\n#    else\n#    endif\n}\n#  endif\n\n/**********************************************\n * Teensy 3.0 / Teensy 3.1 / Teensy 3.2 boards\n **********************************************/\n#elif defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)\n\n// Special carrier modulator timer for Teensy 3.0 / Teensy 3.1 / Teensy 3.2\n#define TIMER_REQUIRES_RESET_INTR_PENDING\nvoid timerResetInterruptPending() {\n    uint8_t tmp __attribute__((unused)) = CMT_MSC;\n    CMT_CMD2 = 30;\n}\nvoid timerEnableReceiveInterrupt() {\n    NVIC_ENABLE_IRQ(IRQ_CMT);\n    NVIC_SET_PRIORITY(IRQ_CMT, 48);\n}\nvoid timerDisableReceiveInterrupt() {\n    NVIC_DISABLE_IRQ(IRQ_CMT);\n}\n\n#define TIMER_INTR_NAME     cmt_isr\n#  if defined(ISR)\n#undef ISR\n#  endif\n#define ISR(f) void f(void)\n\n#define CMT_PPS_DIV  ((F_BUS + 7999999) / 8000000)\n#  if F_BUS < 8000000\n#error IRremote requires at least 8 MHz on Teensy 3.x\n#  endif\n\nvoid timerConfigForReceive() {\n    SIM_SCGC4 |= SIM_SCGC4_CMT;\n    CMT_PPS = CMT_PPS_DIV - 1;\n    CMT_CGH1 = 1;\n    CMT_CGL1 = 1;\n    CMT_CMD1 = 0;\n    CMT_CMD2 = 30;\n    CMT_CMD3 = 0;\n    CMT_CMD4 = (F_BUS / 160000 + CMT_PPS_DIV / 2) / CMT_PPS_DIV - 31;\n    CMT_OC = 0;\n    CMT_MSC = 0x03;\n}\n\n#  if defined(SEND_PWM_BY_TIMER)\n#define IR_SEND_PIN  5\n\nvoid enableSendPWMByTimer() {\n    do {\n        CORE_PIN5_CONFIG = PORT_PCR_MUX(2) | PORT_PCR_DSE | PORT_PCR_SRE;\n    } while (0);\n}\nvoid disableSendPWMByTimer() {\n    do {\n        CORE_PIN5_CONFIG = PORT_PCR_MUX(1) | PORT_PCR_DSE | PORT_PCR_SRE;\n    } while (0);\n}\n\n/*\n * timerConfigForSend() is used exclusively by IRsend::enableIROut()\n * Set output pin mode and disable receive interrupt if it uses the same resource\n */\nvoid timerConfigForSend(uint16_t aFrequencyKHz) {\n    timerDisableReceiveInterrupt(); // TODO really required here? Do we have a common resource for Teensy3.0, 3.1\n#    if defined(IR_SEND_PIN)\n    pinMode(IR_SEND_PIN, OUTPUT);\n#    else\n    pinMode(IrSender.sendPin, OUTPUT);\n#    endif\n\n    SIM_SCGC4 |= SIM_SCGC4_CMT;\n    SIM_SOPT2 |= SIM_SOPT2_PTD7PAD;\n    CMT_PPS = CMT_PPS_DIV - 1;\n    CMT_CGH1 = ((F_BUS / CMT_PPS_DIV / 3000) + ((aFrequencyKHz) / 2)) / (aFrequencyKHz);\n    CMT_CGL1 = ((F_BUS / CMT_PPS_DIV / 1500) + ((aFrequencyKHz) / 2)) / (aFrequencyKHz);\n    CMT_CMD1 = 0;\n    CMT_CMD2 = 30;\n    CMT_CMD3 = 0;\n    CMT_CMD4 = 0;\n    CMT_OC = 0x60;\n    CMT_MSC = 0x01;\n}\n#  endif // defined(SEND_PWM_BY_TIMER)\n\n/***************************************\n * Teensy-LC board\n ***************************************/\n#elif defined(__MKL26Z64__)\n\n// defines for TPM1 timer on Teensy-LC\n#define TIMER_REQUIRES_RESET_INTR_PENDING\nvoid timerResetInterruptPending() {\n    FTM1_SC |= FTM_SC_TOF;\n}\nvoid timerEnableReceiveInterrupt() {\n    NVIC_ENABLE_IRQ(IRQ_FTM1);\n    NVIC_SET_PRIORITY(IRQ_FTM1, 0);\n}\nvoid timerDisableReceiveInterrupt() {\n    NVIC_DISABLE_IRQ(IRQ_FTM1);\n}\n#define TIMER_INTR_NAME                 ftm1_isr\n#  if defined(ISR)\n#undef ISR\n#  endif\n#define ISR(f) void f(void)\n\nvoid timerConfigForReceive() {\n    SIM_SCGC6 |= SIM_SCGC6_TPM1;\n    FTM1_SC = 0;\n    FTM1_CNT = 0;\n    FTM1_MOD = (F_PLL / 40000) - 1;\n    FTM1_C0V = 0;\n    FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(0) | FTM_SC_TOF | FTM_SC_TOIE;\n}\n\n#  if defined(SEND_PWM_BY_TIMER)\n#define IR_SEND_PIN        16\n\nvoid enableSendPWMByTimer() {\n    FTM1_CNT = 0;\n    CORE_PIN16_CONFIG = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;\n}\nvoid disableSendPWMByTimer() {\n    CORE_PIN16_CONFIG = PORT_PCR_MUX(1) | PORT_PCR_SRE;\n}\n\n/*\n * timerConfigForSend() is used exclusively by IRsend::enableIROut()\n * Set output pin mode and disable receive interrupt if it uses the same resource\n */\nvoid timerConfigForSend(uint16_t aFrequencyKHz) {\n    timerDisableReceiveInterrupt();\n#    if defined(IR_SEND_PIN)\n    pinMode(IR_SEND_PIN, OUTPUT);\n#    else\n    pinMode(IrSender.sendPin, OUTPUT);\n#    endif\n\n    SIM_SCGC6 |= SIM_SCGC6_TPM1;\n    FTM1_SC = 0;\n    FTM1_CNT = 0;\n    FTM1_MOD = ((F_PLL / 2000) / aFrequencyKHz) - 1;\n    FTM1_C0V = ((F_PLL / 6000) / aFrequencyKHz) - 1;\n    FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(0);\n}\n#  endif // defined(SEND_PWM_BY_TIMER)\n\n/***************************************\n * Teensy 4.0, 4.1, MicroMod boards\n ***************************************/\n#elif defined(__IMXRT1062__)\n// forward declare ISR function (will be implemented by IRReceive.hpp)\nvoid pwm1_3_isr();\n\n// defines for FlexPWM1 timer on Teensy 4\n#define TIMER_REQUIRES_RESET_INTR_PENDING\nvoid timerResetInterruptPending() {\n    FLEXPWM1_SM3STS = FLEXPWM_SMSTS_RF;\n}\nvoid timerEnableReceiveInterrupt() {\n    attachInterruptVector(IRQ_FLEXPWM1_3, pwm1_3_isr);\n    FLEXPWM1_SM3STS = FLEXPWM_SMSTS_RF;\n    FLEXPWM1_SM3INTEN = FLEXPWM_SMINTEN_RIE;\n    NVIC_ENABLE_IRQ (IRQ_FLEXPWM1_3), NVIC_SET_PRIORITY(IRQ_FLEXPWM1_3, 48);\n}\nvoid timerDisableReceiveInterrupt() {\n    NVIC_DISABLE_IRQ (IRQ_FLEXPWM1_3);\n}\n#define TIMER_INTR_NAME                 pwm1_3_isr\n#  if defined(ISR)\n#undef ISR\n#  endif\n#define ISR(f) void (f)(void)\n\nvoid timerConfigForReceive() {\n    uint32_t period = (float) F_BUS_ACTUAL * (float) (MICROS_PER_TICK) * 0.0000005f;\n    uint32_t prescale = 0;\n    while (period > 32767) {\n        period = period >> 1;\n        if (prescale < 7)\n            prescale++;\n    }\n    FLEXPWM1_FCTRL0 |= FLEXPWM_FCTRL0_FLVL(8);\n    FLEXPWM1_FSTS0 = 0x0008;\n    FLEXPWM1_MCTRL |= FLEXPWM_MCTRL_CLDOK(8);\n    FLEXPWM1_SM3CTRL2 = FLEXPWM_SMCTRL2_INDEP;\n    FLEXPWM1_SM3CTRL = FLEXPWM_SMCTRL_HALF | FLEXPWM_SMCTRL_PRSC(prescale);\n    FLEXPWM1_SM3INIT = -period;\n    FLEXPWM1_SM3VAL0 = 0;\n    FLEXPWM1_SM3VAL1 = period;\n    FLEXPWM1_SM3VAL2 = 0;\n    FLEXPWM1_SM3VAL3 = 0;\n    FLEXPWM1_SM3VAL4 = 0;\n    FLEXPWM1_SM3VAL5 = 0;\n    FLEXPWM1_MCTRL |= FLEXPWM_MCTRL_LDOK(8) | FLEXPWM_MCTRL_RUN(8);\n}\n\n#  if defined(SEND_PWM_BY_TIMER)\n#define IR_SEND_PIN        7\nvoid enableSendPWMByTimer() {\n    FLEXPWM1_OUTEN |= FLEXPWM_OUTEN_PWMA_EN(8);\n    IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_00 = 6;\n}\n\nvoid disableSendPWMByTimer() {\n    IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_00 = 5;\n    FLEXPWM1_OUTEN &= ~FLEXPWM_OUTEN_PWMA_EN(8);\n}\n\n/*\n * timerConfigForSend() is used exclusively by IRsend::enableIROut()\n * Set output pin mode and disable receive interrupt if it uses the same resource\n */\nvoid timerConfigForSend(uint16_t aFrequencyKHz) {\n    timerDisableReceiveInterrupt();\n#    if defined(IR_SEND_PIN)\n    pinMode(IR_SEND_PIN, OUTPUT);\n#    else\n    pinMode(IrSender.sendPin, OUTPUT);\n#    endif\n\n    uint32_t period = (float) F_BUS_ACTUAL / (float) ((aFrequencyKHz) * 2000);\n    uint32_t prescale = 0;\n    while (period > 32767) {\n        period = period >> 1;\n        if (prescale < 7)\n            prescale++;\n    }\n    FLEXPWM1_FCTRL0 |= FLEXPWM_FCTRL0_FLVL(8);\n    FLEXPWM1_FSTS0 = 0x0008;\n    FLEXPWM1_MCTRL |= FLEXPWM_MCTRL_CLDOK(8);\n    FLEXPWM1_SM3CTRL2 = FLEXPWM_SMCTRL2_INDEP;\n    FLEXPWM1_SM3CTRL = FLEXPWM_SMCTRL_HALF | FLEXPWM_SMCTRL_PRSC(prescale);\n    FLEXPWM1_SM3INIT = -period;\n    FLEXPWM1_SM3VAL0 = 0;\n    FLEXPWM1_SM3VAL1 = period;\n    FLEXPWM1_SM3VAL2 = -(period / 3);\n    FLEXPWM1_SM3VAL3 = period / 3;\n    FLEXPWM1_SM3VAL4 = 0;\n    FLEXPWM1_SM3VAL5 = 0;\n    FLEXPWM1_MCTRL |= FLEXPWM_MCTRL_LDOK(8) | FLEXPWM_MCTRL_RUN(8);\n}\n#  endif // defined(SEND_PWM_BY_TIMER)\n\n#elif defined(ESP8266)\n#  if defined(SEND_PWM_BY_TIMER)\n#error \"No support for hardware PWM generation for ESP8266\"\n#  endif // defined(SEND_PWM_BY_TIMER)\n\n// Undefine ISR, because we register/call the plain function IRReceiveTimerInterruptHandler()\n#  if defined(ISR)\n#undef ISR\n#  endif\n\nvoid timerEnableReceiveInterrupt() {\n    timer1_attachInterrupt(&IRReceiveTimerInterruptHandler); // enables interrupt too\n}\nvoid timerDisableReceiveInterrupt() {\n    timer1_detachInterrupt(); // disables interrupt too }\n}\n\nvoid timerConfigForReceive() {\n    timer1_isr_init();\n    /*\n     * TIM_DIV1 = 0,   //80MHz (80 ticks/us - 104857.588 us max)\n     * TIM_DIV16 = 1,  //5MHz (5 ticks/us - 1677721.4 us max)\n     * TIM_DIV256 = 3  //312.5Khz (1 tick = 3.2us - 26843542.4 us max)\n     */\n    timer1_enable(TIM_DIV16, TIM_EDGE, TIM_LOOP);\n    timer1_write((80 / 16) * MICROS_PER_TICK); // 80 for 80 and 160! MHz clock, 16 for TIM_DIV16 above\n}\n\n/**********************************************************\n * ESP32 boards - can use any pin for send PWM\n * Receive timer and send generation are independent,\n * so it is recommended to always define SEND_PWM_BY_TIMER\n **********************************************************/\n#elif defined(ESP32)\n// Variables specific to the ESP32.\n// the ledc functions behave like hardware timers for us :-), so we do not require our own soft PWM generation code.\nhw_timer_t *s50usTimer = NULL; // set by timerConfigForReceive()\n\n#  if ESP_ARDUINO_VERSION < ESP_ARDUINO_VERSION_VAL(3, 0, 0) &&  !defined(SEND_AND_RECEIVE_TIMER_LEDC_CHANNEL)\n#define SEND_AND_RECEIVE_TIMER_LEDC_CHANNEL 0 // The channel used for PWM 0 to 7 are high speed PWM channels\n#  endif\n\nvoid timerEnableReceiveInterrupt() {\n    timerAlarmEnable(s50usTimer);\n}\n\n#if !defined(ESP_ARDUINO_VERSION)\n#define ESP_ARDUINO_VERSION 0\n#endif\n#if !defined(ESP_ARDUINO_VERSION_VAL)\n#define ESP_ARDUINO_VERSION_VAL(major, minor, patch) 202\n#endif\n#if ESP_ARDUINO_VERSION < ESP_ARDUINO_VERSION_VAL(2, 0, 2)\nvoid timerDisableReceiveInterrupt() {\n    if (s50usTimer != NULL) {\n        timerDetachInterrupt(s50usTimer);\n        timerEnd(s50usTimer);\n    }\n}\n#else\nvoid timerDisableReceiveInterrupt() {\n    if (s50usTimer != NULL) {\n        timerAlarmDisable(s50usTimer);\n    }\n}\n#endif\n\n// Undefine ISR, because we register/call the plain function IRReceiveTimerInterruptHandler()\n#  if defined(ISR)\n#undef ISR\n#  endif\n\n#  if !defined(DISABLE_CODE_FOR_RECEIVER) // &IRReceiveTimerInterruptHandler is referenced, but not available\nvoid timerConfigForReceive() {\n    // ESP32 has a proper API to setup timers, no weird chip macros needed\n    // simply call the readable API versions :)\n    // 3 timers, choose #1, 80 divider for microsecond precision @80MHz clock, count_up = true\n    if(s50usTimer == NULL) {\n        s50usTimer = timerBegin(1, 80, true);\n        timerAttachInterrupt(s50usTimer, &IRReceiveTimerInterruptHandler, false); // false -> level interrupt, true -> edge interrupt, but this is not supported :-(\n        timerAlarmWrite(s50usTimer, MICROS_PER_TICK, true);\n    }\n    // every 50 us, autoreload = true\n}\n#  endif\n\n#  if !defined(IR_SEND_PIN)\nuint8_t sLastSendPin = 0; // To detach before attach, if already attached\n#  endif\n\n#  if defined(SEND_PWM_BY_TIMER)\nvoid enableSendPWMByTimer() {\n#    if ESP_ARDUINO_VERSION < ESP_ARDUINO_VERSION_VAL(3, 0, 0)\n    ledcWrite(SEND_AND_RECEIVE_TIMER_LEDC_CHANNEL, (IR_SEND_DUTY_CYCLE_PERCENT * 256) / 100); //  * 256 since we have 8 bit resolution\n#    else\n    ledcWrite(IrSender.sendPin, (IR_SEND_DUTY_CYCLE_PERCENT * 256) / 100); // New API\n#    endif\n}\nvoid disableSendPWMByTimer() {\n#    if ESP_ARDUINO_VERSION < ESP_ARDUINO_VERSION_VAL(3, 0, 0)\n    ledcWrite(SEND_AND_RECEIVE_TIMER_LEDC_CHANNEL, 0);\n#    else\n    ledcWrite(IrSender.sendPin, 0); // New API\n#    endif\n}\n\n/*\n * timerConfigForSend() is used exclusively by IRsend::enableIROut() (or enableHighFrequencyIROut())\n * ledcWrite since ESP 2.0.2 does not work if pin mode is set.\n */\nvoid timerConfigForSend(uint16_t aFrequencyKHz) {\n#    if ESP_ARDUINO_VERSION < ESP_ARDUINO_VERSION_VAL(3, 0, 0)\n    ledcSetup(SEND_AND_RECEIVE_TIMER_LEDC_CHANNEL, aFrequencyKHz * 1000, 8);  // 8 bit PWM resolution\n#      if defined(IR_SEND_PIN)\n    ledcAttachPin(IR_SEND_PIN, SEND_AND_RECEIVE_TIMER_LEDC_CHANNEL);  // attach pin to channel\n#      else\n    if(sLastSendPin != 0 && sLastSendPin != IrSender.sendPin){\n        ledcDetachPin(IrSender.sendPin);  // detach pin before new attaching see #1194\n    }\n    ledcAttachPin(IrSender.sendPin, SEND_AND_RECEIVE_TIMER_LEDC_CHANNEL);  // attach pin to channel\n    sLastSendPin = IrSender.sendPin;\n#      endif\n#    else  // New API here\n#      if defined(IR_SEND_PIN)\n    ledcAttach(IR_SEND_PIN, aFrequencyKHz * 1000, 8); // New API\n#      else\n    if(sLastSendPin != 0 && sLastSendPin != IrSender.sendPin){\n        ledcDetach(IrSender.sendPin); // detach pin before new attaching see #1194\n    }\n    ledcAttach(IrSender.sendPin, aFrequencyKHz * 1000, 8); // New API\n    sLastSendPin = IrSender.sendPin;\n#      endif\n#    endif\n}\n#  endif // defined(SEND_PWM_BY_TIMER)\n\n/***************************************\n * SAMD boards like DUE and Zero\n ***************************************/\n#elif defined(ARDUINO_ARCH_SAMD)\n#  if defined(SEND_PWM_BY_TIMER)\n#error PWM generation by hardware is not yet implemented for SAMD\n#  endif\n\n#  if !defined(IR_SAMD_TIMER)\n#    if defined(__SAMD51__)\n#define IR_SAMD_TIMER       TC5\n#define IR_SAMD_TIMER_IRQ   TC5_IRQn\n#    else\n// SAMD21\n#define IR_SAMD_TIMER       TC3\n#define IR_SAMD_TIMER_ID    GCLK_CLKCTRL_ID_TCC2_TC3\n#define IR_SAMD_TIMER_IRQ   TC3_IRQn\n#    endif\n#  endif\n\nvoid timerEnableReceiveInterrupt() {\n    NVIC_EnableIRQ (IR_SAMD_TIMER_IRQ);\n}\nvoid timerDisableReceiveInterrupt() {\n    NVIC_DisableIRQ (IR_SAMD_TIMER_IRQ); // or TC5->INTENCLR.bit.MC0 = 1; or TC5->COUNT16.CTRLA.reg &= ~TC_CTRLA_ENABLE;\n\n}\n// Undefine ISR, because we call the plain function IRReceiveTimerInterruptHandler()\n// The ISR is now TC3_Handler() or TC5_Handler() below\n#  if defined(ISR)\n#undef ISR\n#  endif\n\n/**\n * Adafruit M4 code (cores/arduino/startup.c) configures these clock generators:\n * GCLK0 = F_CPU\n * GCLK2 = 100 MHz\n * GCLK1 = 48 MHz // This Clock is present in SAMD21 and SAMD51\n * GCLK4 = 12 MHz\n * GCLK3 = XOSC32K\n */\nvoid timerConfigForReceive() {\n    TcCount16 *TC = (TcCount16*) IR_SAMD_TIMER;\n\n#  if defined(__SAMD51__)\n    // Enable the TC5 clock, use generic clock generator 0 (F_CPU) for TC5\n    GCLK->PCHCTRL[TC5_GCLK_ID].reg = GCLK_PCHCTRL_GEN_GCLK0_Val | (1 << GCLK_PCHCTRL_CHEN_Pos);\n\n    // The TC should be disabled before the TC is reset in order to avoid undefined behavior.\n    TC->CTRLA.reg &= ~TC_CTRLA_ENABLE; // Disable the Timer\n    while (TC->SYNCBUSY.bit.ENABLE)\n        ; // Wait for disabled\n    // Reset TCx\n    TC->CTRLA.reg = TC_CTRLA_SWRST;\n    // When writing a '1' to the CTRLA.SWRST bit it will immediately read as '1'.\n    while (TC->SYNCBUSY.bit.SWRST)\n        ; // CTRL.SWRST will be cleared by hardware when the peripheral has been reset.\n\n    // SAMD51 has F_CPU = 120 MHz\n    TC->CC[0].reg = ((MICROS_PER_TICK * (F_CPU / MICROS_IN_ONE_SECOND)) / 16) - 1;   // (375 - 1);\n\n    /*\n     * Set timer counter mode to 16 bits, set mode as match frequency, prescaler is DIV16 => 7.5 MHz clock, start counter\n     */\n    TC->CTRLA.reg |= TC_CTRLA_MODE_COUNT16 | TC_WAVE_WAVEGEN_MFRQ | TC_CTRLA_PRESCALER_DIV16 | TC_CTRLA_ENABLE;\n//    while (TC5->COUNT16.STATUS.bit.SYNCBUSY == 1);                                // The next commands do an implicit wait :-)\n#  else\n    // Enable GCLK and select GCLK0 (F_CPU) as clock for TC4 and TC5\n    REG_GCLK_CLKCTRL = (uint16_t)(GCLK_CLKCTRL_CLKEN | GCLK_CLKCTRL_GEN_GCLK0 | IR_SAMD_TIMER_ID);\n    while (GCLK->STATUS.bit.SYNCBUSY == 1)\n        ;\n\n    // The TC should be disabled before the TC is reset in order to avoid undefined behavior.\n    TC->CTRLA.reg &= ~TC_CTRLA_ENABLE;\n    // When write-synchronization is ongoing for a register, any subsequent write attempts to this register will be discarded, and an error will be reported.\n    while (TC->STATUS.bit.SYNCBUSY == 1)\n        ; // wait for sync to ensure that we can write again to COUNT16.CTRLA.reg\n    // Reset TCx\n    TC->CTRLA.reg = TC_CTRLA_SWRST;\n    // When writing a 1 to the CTRLA.SWRST bit it will immediately read as 1.\n    while (TC->CTRLA.bit.SWRST)\n        ; // CTRL.SWRST will be cleared by hardware when the peripheral has been reset.\n\n    // SAMD51 has F_CPU = 48 MHz\n    TC->CC[0].reg = ((MICROS_PER_TICK * (F_CPU / MICROS_IN_ONE_SECOND)) / 16) - 1;   // (150 - 1);\n\n    /*\n     * Set timer counter mode to 16 bits, set mode as match frequency, prescaler is DIV16 => 3 MHz clock, start counter\n     */\n    TC->CTRLA.reg |= TC_CTRLA_MODE_COUNT16 | TC_CTRLA_WAVEGEN_MFRQ | TC_CTRLA_PRESCALER_DIV16 | TC_CTRLA_ENABLE;\n\n#  endif\n    // Configure interrupt request\n    NVIC_DisableIRQ (IR_SAMD_TIMER_IRQ);\n    NVIC_ClearPendingIRQ(IR_SAMD_TIMER_IRQ);\n    NVIC_SetPriority(IR_SAMD_TIMER_IRQ, 0);\n    NVIC_EnableIRQ(IR_SAMD_TIMER_IRQ);\n\n    // Enable the compare interrupt\n    TC->INTENSET.bit.MC0 = 1;\n}\n\n#  if !defined(DISABLE_CODE_FOR_RECEIVER)\n#    if defined(__SAMD51__)\nvoid TC5_Handler(void) {\n    TcCount16 *TC = (TcCount16*) IR_SAMD_TIMER;\n    // Check for right interrupt bit\n    if (TC->INTFLAG.bit.MC0 == 1) {\n        // reset bit for next turn\n        TC->INTFLAG.bit.MC0 = 1;\n        IRReceiveTimerInterruptHandler();\n    }\n}\n#    else\nvoid TC3_Handler(void) {\n    TcCount16 *TC = (TcCount16*) IR_SAMD_TIMER;\n    // Check for right interrupt bit\n    if (TC->INTFLAG.bit.MC0 == 1) {\n        // reset bit for next turn\n        TC->INTFLAG.bit.MC0 = 1;\n        IRReceiveTimerInterruptHandler();\n    }\n}\n#    endif // defined(__SAMD51__)\n#  endif // !defined(DISABLE_CODE_FOR_RECEIVER)\n\n/***************************************\n * Mbed based boards\n ***************************************/\n#elif defined(ARDUINO_ARCH_MBED) // Arduino Nano 33 BLE + Sparkfun Apollo3 + Nano RP2040 Connect\n#include \"mbed.h\"\nmbed::Ticker s50usTimer;\n\n// Undefine ISR, because we register/call the plain function IRReceiveTimerInterruptHandler()\n#  if defined(ISR)\n#undef ISR\n#  endif\n\nvoid timerEnableReceiveInterrupt() {\n    s50usTimer.attach(IRReceiveTimerInterruptHandler, std::chrono::microseconds(MICROS_PER_TICK));\n}\nvoid timerDisableReceiveInterrupt() {\n    s50usTimer.detach();\n}\n\nvoid timerConfigForReceive() {\n    s50usTimer.attach(IRReceiveTimerInterruptHandler, std::chrono::microseconds(MICROS_PER_TICK));\n}\n\n#  if defined(SEND_PWM_BY_TIMER)\n#include \"pins_arduino.h\" // for digitalPinToPinName()\n\n#    if defined(IR_SEND_PIN)\nmbed::PwmOut sPwmOutForSendPWM(digitalPinToPinName(IR_SEND_PIN));\n#    else\nmbed::PwmOut sPwmOutForSendPWM(digitalPinToPinName(IrSender.sendPin));\n#    endif\nuint8_t sIROutPuseWidth;\n\nvoid enableSendPWMByTimer() {\n    sPwmOutForSendPWM.pulsewidth_us(sIROutPuseWidth);\n}\n//void enableSendPWMByTimer() {    sPwmOutForSendPWM.resume(); sPwmOutForSendPWM.pulsewidth_us(sIROutPuseWidth);}\n//void disableSendPWMByTimer() {   sPwmOutForSendPWM.suspend();} // this kills pulsewidth_us value and does not set output level to LOW\n\nvoid disableSendPWMByTimer() {\n    sPwmOutForSendPWM.pulsewidth_us(0); // this also sets output level to LOW :-)\n}\n\n/*\n * timerConfigForSend() is used exclusively by IRsend::enableIROut()\n * Set output pin mode and disable receive interrupt if it uses the same resource\n */\nvoid timerConfigForSend(uint16_t aFrequencyKHz) {\n    sPwmOutForSendPWM.period_us(1000 / aFrequencyKHz);  // 26.315 for 38 kHz\n    sIROutPuseWidth = (1000 * IR_SEND_DUTY_CYCLE_PERCENT) / (aFrequencyKHz * 100);\n}\n#  endif // defined(SEND_PWM_BY_TIMER)\n\n/*************************************************************************************************************************************\n * RP2040 based boards for pico core\n * https://github.com/earlephilhower/arduino-pico\n * https://github.com/earlephilhower/arduino-pico/releases/download/global/package_rp2040_index.json\n * Can use any pin for PWM, no timer restrictions\n *************************************************************************************************************************************/\n#elif defined(ARDUINO_ARCH_RP2040) // Raspberry Pi Pico, Adafruit Feather RP2040, etc.\n#include \"pico/time.h\"\n\nrepeating_timer_t s50usTimer;\n\n// Undefine ISR, because we register/call the plain function IRReceiveTimerInterruptHandler()\n#  if defined(ISR)\n#undef ISR\n#  endif\n\n// The timer callback has a parameter and a return value\nbool IRTimerInterruptHandlerHelper(repeating_timer_t*) {\n    IRReceiveTimerInterruptHandler();\n    return true;\n}\n\nvoid timerEnableReceiveInterrupt() {\n    add_repeating_timer_us(-(MICROS_PER_TICK), IRTimerInterruptHandlerHelper, NULL, &s50usTimer);\n}\nvoid timerDisableReceiveInterrupt() {\n    cancel_repeating_timer(&s50usTimer);\n}\n\nvoid timerConfigForReceive() {\n    // no need for initializing timer at setup()\n}\n\n#  if defined(SEND_PWM_BY_TIMER)\n#include \"hardware/pwm.h\"\n\nuint sSliceNumberForSendPWM;\nuint sChannelNumberForSendPWM;\nuint sIROutPuseWidth;\n\n/*\n * If we just disable the PWM, the counter stops and the output stays at the state is currently has\n */\nvoid enableSendPWMByTimer() {\n    pwm_set_counter(sSliceNumberForSendPWM, 0);\n    pwm_set_chan_level(sSliceNumberForSendPWM, sChannelNumberForSendPWM, sIROutPuseWidth);\n}\nvoid disableSendPWMByTimer() {\n    pwm_set_chan_level(sSliceNumberForSendPWM, sChannelNumberForSendPWM, 0); // this sets output also to LOW\n}\n\n/*\n * timerConfigForSend() is used exclusively by IRsend::enableIROut()\n * Set output pin mode and disable receive interrupt if it uses the same resource\n */\nvoid timerConfigForSend(uint16_t aFrequencyKHz) {\n#    if defined(IR_SEND_PIN)\n    gpio_set_function(IR_SEND_PIN, GPIO_FUNC_PWM);\n    // Find out which PWM slice is connected to IR_SEND_PIN\n    sSliceNumberForSendPWM = pwm_gpio_to_slice_num(IR_SEND_PIN);\n    sChannelNumberForSendPWM = pwm_gpio_to_channel(IR_SEND_PIN);\n#    else\n    gpio_set_function(IrSender.sendPin, GPIO_FUNC_PWM);\n    // Find out which PWM slice is connected to IR_SEND_PIN\n    sSliceNumberForSendPWM = pwm_gpio_to_slice_num(IrSender.sendPin);\n    sChannelNumberForSendPWM = pwm_gpio_to_channel(IrSender.sendPin);\n#    endif\n    uint16_t tPWMWrapValue = (clock_get_hz(clk_sys)) / (aFrequencyKHz * 1000); // 3289.473 for 38 kHz @125 MHz clock. We have a 16 bit counter and use system clock (125 MHz)\n\n    pwm_config tPWMConfig = pwm_get_default_config();\n    pwm_config_set_wrap(&tPWMConfig, tPWMWrapValue - 1);\n    pwm_init(sSliceNumberForSendPWM, &tPWMConfig, false); // we do not want to send now\n    sIROutPuseWidth = ((tPWMWrapValue * IR_SEND_DUTY_CYCLE_PERCENT) / 100) - 1; // 985.84 for 38 kHz\n    pwm_set_chan_level(sSliceNumberForSendPWM, sChannelNumberForSendPWM, 0);\n    pwm_set_enabled(sSliceNumberForSendPWM, true);\n}\n#  endif // defined(SEND_PWM_BY_TIMER)\n\n/***************************************\n * NRF5 boards like the BBC:Micro\n ***************************************/\n#elif defined(NRF5) || defined(ARDUINO_ARCH_NRF52840) || defined(ARDUINO_ARCH_NRF52)\n#  if defined(SEND_PWM_BY_TIMER)\n#error PWM generation by hardware not implemented for NRF5\n#  endif\n\nvoid timerEnableReceiveInterrupt() {\n    NVIC_EnableIRQ (TIMER2_IRQn);\n}\nvoid timerDisableReceiveInterrupt() {\n    NVIC_DisableIRQ (TIMER2_IRQn);\n}\n\n// Undefine ISR, because we call the plain function IRReceiveTimerInterruptHandler()\n#  if defined(ISR)\n#undef ISR\n#  endif\n\nvoid timerConfigForReceive() {\n    NRF_TIMER2->MODE = TIMER_MODE_MODE_Timer;              // Set the timer in Timer Mode\n    NRF_TIMER2->TASKS_CLEAR = 1;              // clear the task first to be usable for later\n    NRF_TIMER2->PRESCALER = 4;              // f TIMER = 16 MHz / (2 ^ PRESCALER ) : 4 -> 1 MHz, 1 uS\n    NRF_TIMER2->BITMODE = TIMER_BITMODE_BITMODE_16Bit;              //Set counter to 16 bit resolution\n    NRF_TIMER2->CC[0] = MICROS_PER_TICK;              //Set value for TIMER2 compare register 0, to trigger every 50 uS\n    NRF_TIMER2->CC[1] = 0;              //Set value for TIMER2 compare register 1\n\n    // Enable interrupt on Timer 2, for CC[0] compare match events\n    NRF_TIMER2->INTENSET = (TIMER_INTENSET_COMPARE0_Enabled << TIMER_INTENSET_COMPARE0_Pos);\n    NRF_TIMER2->TASKS_START = 1;              // Start TIMER2\n\n    // timerAttachInterrupt(timer, &IRTimerInterruptHandler, 1);\n}\n\n#if !defined(DISABLE_CODE_FOR_RECEIVER)\n/** TIMTER2 peripheral interrupt handler. This interrupt handler is called whenever there it a TIMER2 interrupt\n * Don't mess with this line. really.\n */\nextern \"C\" {\nvoid TIMER2_IRQHandler(void) {\n    // Interrupt Service Routine - Fires every 50uS\n    if ((NRF_TIMER2->EVENTS_COMPARE[0] != 0) && ((NRF_TIMER2->INTENSET & TIMER_INTENSET_COMPARE0_Msk) != 0)) {\n        NRF_TIMER2->EVENTS_COMPARE[0] = 0;          //Clear compare register 0 event\n        IRReceiveTimerInterruptHandler();          // call the IR-receive function\n        NRF_TIMER2->CC[0] += 50;\n    }\n}\n}\n#endif\n\n/**********************************************************************************************************************\n * BluePill in 2 flavors see https://samuelpinches.com.au/3d-printer/cutting-through-some-confusion-on-stm32-and-arduino/\n *\n * Recommended original Arduino_STM32 by Roger Clark.\n * http://dan.drown.org/stm32duino/package_STM32duino_index.json\n * STM32F1 architecture for \"Generic STM32F103C series\" from \"STM32F1 Boards (Arduino_STM32)\" of Arduino Board manager\n **********************************************************************************************************************/\n#elif defined(__STM32F1__) || defined(ARDUINO_ARCH_STM32F1)\n#include <HardwareTimer.h> // 4 timers and 4. timer (4.channel) is used for tone()\n#  if defined(SEND_PWM_BY_TIMER)\n#error PWM generation by hardware not implemented for STM32\n#  endif\n\n/*\n * Use timer 3 as IR timer.\n * Timer 3 blocks PA6, PA7, PB0, PB1, so if you require one of them as tone() or Servo output, you must choose another timer.\n */\nHardwareTimer s50usTimer(3);\n\nvoid timerEnableReceiveInterrupt() {\n    s50usTimer.resume();\n}\nvoid timerDisableReceiveInterrupt() {\n    s50usTimer.pause();\n}\n\n// Undefine ISR, because we register/call the plain function IRReceiveTimerInterruptHandler()\n#  if defined(ISR)\n#undef ISR\n#  endif\n\nvoid timerConfigForReceive() {\n    s50usTimer.setMode(TIMER_CH1, TIMER_OUTPUT_COMPARE);\n    s50usTimer.setPrescaleFactor(1);\n    s50usTimer.setOverflow((F_CPU / MICROS_IN_ONE_SECOND) * MICROS_PER_TICK);\n    s50usTimer.attachInterrupt(TIMER_CH1, IRReceiveTimerInterruptHandler);\n    s50usTimer.refresh();\n}\n\n/**********************************************************************************************************************\n * STM32duino by ST Microsystems.\n * https://github.com/stm32duino/Arduino_Core_STM32\n * https://github.com/stm32duino/BoardManagerFiles/raw/master/STM32/package_stm_index.json\n * stm32 architecture for \"Generic STM32F1 series\" from \"STM32 Boards (selected from submenu)\" of Arduino Board manager\n **********************************************************************************************************************/\n#elif defined(STM32F1xx) || defined(ARDUINO_ARCH_STM32)\n#include <HardwareTimer.h> // 4 timers and 3. timer is used for tone(), 2. for Servo\n#  if defined(SEND_PWM_BY_TIMER)\n#error PWM generation by hardware not implemented for STM32\n#  endif\n\n/*\n * Use timer 4 as IR timer.\n * Timer 4 blocks PB6, PB7, PB8, PB9, so if you need one them as tone() or Servo output, you must choose another timer.\n */\n#  if defined(TIM4)\nHardwareTimer s50usTimer(TIM4);\n#  else\nHardwareTimer s50usTimer(TIM2);\n#  endif\n\nvoid timerEnableReceiveInterrupt() {\n    s50usTimer.resume();\n}\nvoid timerDisableReceiveInterrupt() {\n    s50usTimer.pause();\n}\n\n// Undefine ISR, because we register/call the plain function IRReceiveTimerInterruptHandler()\n#  if defined(ISR)\n#undef ISR\n#  endif\n\nvoid timerConfigForReceive() {\n    s50usTimer.setOverflow(MICROS_PER_TICK, MICROSEC_FORMAT); // 50 uS\n    s50usTimer.attachInterrupt(IRReceiveTimerInterruptHandler);\n    s50usTimer.resume();\n}\n\n/***************************************\n * Particle special IntervalTimer\n * !!!UNTESTED!!!\n ***************************************/\n#elif defined(PARTICLE)\n#  ifndef __INTERVALTIMER_H__\n#include \"SparkIntervalTimer.h\" // SparkIntervalTimer.h is required if PARTICLE is defined.\n#  endif\n\nextern IntervalTimer timer;\nextern int ir_out_kHz;\n\nvoid timerEnableReceiveInterrupt() {\n    timer.begin(IRReceiveTimerInterruptHandler, MICROS_PER_TICK, uSec);\n}\nvoid timerDisableReceiveInterrupt() {\n    timer.end();\n}\n\n// Undefine ISR, because we register/call the plain function IRReceiveTimerInterruptHandler()\n#  if defined(ISR)\n#undef ISR\n#  endif\n\nvoid timerConfigForReceive() {\n}\n\n#  if defined(SEND_PWM_BY_TIMER)\n#    if defined(IR_SEND_PIN)\nvoid enableSendPWMByTimer() {\n    analogWrite(IR_SEND_PIN, ((256L * 100) / IR_SEND_DUTY_CYCLE_PERCENT)), ir_out_kHz*1000);\n}\nvoid disableSendPWMByTimer() {\n    analogWrite(IR_SEND_PIN, 0, ir_out_kHz*1000);\n}\n#    else\nvoid enableSendPWMByTimer() {\n    analogWrite(IrSender.sendPin, ((256L * 100) / IR_SEND_DUTY_CYCLE_PERCENT), ir_out_kHz * 1000);\n}\nvoid disableSendPWMByTimer() {\n    analogWrite(IrSender.sendPin, 0, ir_out_kHz * 1000);\n}\n#    endif\n\n\n/*\n * timerConfigForSend() is used exclusively by IRsend::enableIROut()\n * Set output pin mode and disable receive interrupt if it uses the same resource\n */\nvoid timerConfigForSend(uint16_t aFrequencyKHz) {\n    timerDisableReceiveInterrupt();\n#    if defined(IR_SEND_PIN)\n    pinMode(IR_SEND_PIN, OUTPUT);\n#    else\n    pinMode(IrSender.sendPin, OUTPUT);\n#    endif\n    ir_out_kHz = aFrequencyKHz;\n}\n#  endif // defined(SEND_PWM_BY_TIMER)\n\n/***************************************\n * Unknown CPU board\n ***************************************/\n#else\n#error Internal code configuration error, no timer functions implemented for this CPU / board\n/*\n * Dummy definitions to avoid more irritating compile errors\n */\n\nvoid timerEnableReceiveInterrupt() {};\nvoid timerDisableReceiveInterrupt() {};\n\n#  if defined(ISR)\n#undef ISR\n#  endif\n#define ISR() void notImplemented(void)\n\nvoid timerConfigForReceive() {\n}\n\n#  if defined(SEND_PWM_BY_TIMER)\nvoid enableSendPWMByTimer() {\n}\nvoid disableSendPWMByTimer() {\n}\n\nvoid timerConfigForSend(uint16_t aFrequencyKHz) {\n    timerDisableReceiveInterrupt();\n#    if defined(IR_SEND_PIN)\n    pinMode(IR_SEND_PIN, OUTPUT);\n#    else\n    pinMode(IrSender.sendPin, OUTPUT);\n#    endif\n    (void) aFrequencyKHz;\n}\n#  endif // defined(SEND_PWM_BY_TIMER)\n\n#endif // defined(DOXYGEN / CPU_TYPES)\n\n/** @}*/\n/** @}*/\n#endif // _IR_TIMER_HPP\n"
    }]
  };
  const extFacePanels = {};
  const ExtHandler = {
    onLoad: function onLoad(app, target) {
      const that = this;

      if (!that.__workerSetupInstance) {
        that.__workerSetupInstance = that.workerSetup({
          app
        }).then(() => {
          that.worker.remote.runExtension('onLoad', target.id);
        });
      }
    },
    onUnload: function onUnload(app) {
      this.__workerSetupInstance = null;
      this.worker.remote.runExtension('onUnload');
      this.worker.dispose();
    },
    onConnect: function onConnect(app, device) {
      this.worker.remote.runExtension('onConnect', device.id);
    },
    onDisconnect: function onDisconnect(app, device) {
      this.worker.remote.runExtension('onDisconnect', device.id);
    },
    onStopAll: function onStopAll(app, device) {
      this.worker.remote.runExtension('onStopAll', device.id);
    },
    beforeChangeUploadMode: function beforeChangeUploadMode(app, device) {
      return this.worker.remote.runExtension('beforeChangeUploadMode', device.id);
    },
    beforeChangeDebugMode: function beforeChangeDebugMode(app, device) {
      return this.worker.remote.runExtension('beforeChangeDebugMode', device.id);
    },
    afterChangeUploadMode: function afterChangeUploadMode(app, device) {
      this.worker.remote.runExtension('afterChangeUploadMode', device.id);
    },
    afterChangeDebugMode: function afterChangeDebugMode(app, device) {
      this.worker.remote.runExtension('afterChangeDebugMode', device.id);
    },
    onSelect: function onSelect(app, device) {
      if (!this.worker) {
        setTimeout(() => {
          this.onSelect(app, device);
        }, 200);
        return;
      }

      this.worker.remote.runExtension('onSelect', device.id);
    },
    onUnselect: function onUnselect(app, device) {
      this.worker.remote.runExtension('onUnselect', device.id);
    },
    beforeCodeUpload: function beforeCodeUpload(app, device) {
      this.worker.remote.runExtension('beforeCodeUpload', device.id);
    },
    afterCodeUpload: function afterCodeUpload(app, device) {
      this.worker.remote.runExtension('afterCodeUpload', device.id);
    },
    onRead: function onRead(app, device) {
      this.worker.remote.runExtension('onRead', device.id);
    },
    beforeFirmwareUpdate: function beforeFirmwareUpdate(app, device) {
      this.worker.remote.runExtension('beforeFirmwareUpdate', device.id);
    },
    afterFirmwareUpdate: function afterFirmwareUpdate(app, device) {
      this.worker.remote.runExtension('afterFirmwareUpdate', device.id);
    }
  };

  class ExtLeptonIrRemote {
    constructor() {
      this.checkFirmwareInForce = typeof checkFirmwareInForce !== 'undefined' ? checkFirmwareInForce : false;
      const handlerProxyUrl = window.MbApi.getExtResPath('lepton_ir_remote/handlerProxy.js', 'lepton_ir_remote');
      const that = this;

      that.workerSetup = async function (exports) {
        that.worker = await window.__web_worker_rpc.create(handlerProxyUrl, exports).then(worker => {
          worker.CONFIG.TIMEOUT = 42000;
          worker.CONFIG.HEARTBEAT = 4200;

          worker.onFail = () => {
            that.worker = null;
            that.workerSetup(exports);
            const app = exports.app;

            if (app) {
              app.workspace.resetEvents();
            }
          };

          return worker;
        });
      };

      this.funcs = {
        'BLOCK_1713216604395': {
          onRun: (args, app, device, block) => {
            return this.worker.remote.runBlock('BLOCK_1713216604395', 'onRun', device.id, {
              id: block.id,
              opcode: block.opcode,
              arguments: block.arguments
            }, Object.assign({}, args));
          }
        },
        'BLOCK_1713216604631': {
          onRun: (args, app, device, block) => {
            return this.worker.remote.runBlock('BLOCK_1713216604631', 'onRun', device.id, {
              id: block.id,
              opcode: block.opcode,
              arguments: block.arguments
            }, Object.assign({}, args));
          }
        },
        'BLOCK_1713216604820': {
          onRun: (args, app, device, block) => {
            return this.worker.remote.runBlock('BLOCK_1713216604820', 'onRun', device.id, {
              id: block.id,
              opcode: block.opcode,
              arguments: block.arguments
            }, Object.assign({}, args));
          }
        },
        'BLOCK_1713216605004': {
          onRun: (args, app, device, block) => {
            return this.worker.remote.runBlock('BLOCK_1713216605004', 'onRun', device.id, {
              id: block.id,
              opcode: block.opcode,
              arguments: block.arguments
            }, Object.assign({}, args));
          }
        },
        'BLOCK_1713216605193': {
          onRun: (args, app, device, block) => {
            return this.worker.remote.runBlock('BLOCK_1713216605193', 'onRun', device.id, {
              id: block.id,
              opcode: block.opcode,
              arguments: block.arguments
            }, Object.assign({}, args));
          }
        },
        'BLOCK_1713216605384': {
          onRun: (args, app, device, block) => {
            return this.worker.remote.runBlock('BLOCK_1713216605384', 'onRun', device.id, {
              id: block.id,
              opcode: block.opcode,
              arguments: block.arguments
            }, Object.assign({}, args));
          }
        }
      };
    }

    getInfo() {
      return {
        "id": "lepton_ir_remote",
        "targets": [{
          "name": "arduino_uno",
          "options": {
            "upload": {
              "middlewares": [{
                "name": "arduino",
                "params": {
                  "sources": extSources.arduino
                }
              }]
            }
          }
        }, {
          "name": "arduino_mega2560",
          "options": {
            "upload": {
              "middlewares": [{
                "name": "arduino",
                "params": {
                  "sources": extSources.arduino
                }
              }]
            }
          }
        }],
        "codeTypes": ["arduinoc"],
        "version": "0.0.0",
        "platform": ["mblockpc", "mblockweb"],
        "categories": [{
          "name": "cate_fa32e659",
          "colors": ["#008080", "#007373", "#006666"],
          "menuIconURI": window.MbApi.getExtResPath('lepton_ir_remote/imgs/60af48d4_gamepad-solid.svg', 'lepton_ir_remote'),
          "blockIcon": {
            "type": "image",
            "width": 28,
            "height": 26,
            "src": window.MbApi.getExtResPath('lepton_ir_remote/imgs/669ec287_gamepad-solid (1).svg', 'lepton_ir_remote')
          },
          "blocks": [{
            "opcode": "BLOCK_1713216604395",
            "blockType": "command",
            "checkboxInFlyout": false,
            "hidden": false,
            "gap": 12,
            "arguments": {
              "pin": {
                "type": "number",
                "defaultValue": 2
              }
            },
            "branchCount": 0,
            "platform": ["mblockpc", "mblockweb"],
            "codes": {
              "arduinoc": {
                "sections": {
                  "include": ["\"src/IRremote.hpp\""],
                  "declare": `const char* lepton_ir_protocols[] = {\n    \"UNKNOWN\",\n    \"PULSE_WIDTH\",\n    \"PULSE_DISTANCE\",\n    \"APPLE\",\n    \"DENON\",\n    \"JVC\",\n    \"LG\",\n    \"LG2\",\n    \"NEC\",\n    \"NEC2\",\n    \"ONKYO\",\n    \"PANASONIC\",\n    \"KASEIKYO\",\n    \"KASEIKYO_DENON\",\n    \"KASEIKYO_SHARP\",\n    \"KASEIKYO_JVC\",\n    \"KASEIKYO_MITSUBISHI\",\n    \"RC5\",\n    \"RC6\",\n    \"SAMSUNG\",\n    \"SAMSUNGLG\",\n    \"SAMSUNG48\",\n    \"SHARP\",\n    \"SONY\",\n    \"BANG_OLUFSEN\",\n    \"BOSEWAVE\",\n    \"LEGO_PF\",\n    \"MAGIQUEST\",\n    \"WHYNTER\",\n    \"FAST\"\n};\n\nconst int lepton_ir_protocols_num = sizeof(lepton_ir_protocols) / sizeof(lepton_ir_protocols[0]);\n\nString lepton_ir_protocols_to_string(int number) {\n    if (number >= 0 && number < lepton_ir_protocols_num) {\n        return String(lepton_ir_protocols[number]);\n    } else {\n        return \"OUT_OF_RANGE\";\n    }\n}`,
                  "setup": ` IrReceiver.begin(/*{pin}*/, ENABLE_LED_FEEDBACK);`
                }
              }
            },
            "handler": this.funcs.BLOCK_1713216604395
          }, {
            "opcode": "BLOCK_1713216604631",
            "blockType": "boolean",
            "checkboxInFlyout": false,
            "hidden": false,
            "gap": 12,
            "arguments": {},
            "branchCount": 0,
            "platform": ["mblockpc", "mblockweb"],
            "codes": {
              "arduinoc": {
                "code": `IrReceiver.decode()`
              }
            },
            "handler": this.funcs.BLOCK_1713216604631
          }, {
            "opcode": "BLOCK_1713216604820",
            "blockType": "command",
            "checkboxInFlyout": false,
            "hidden": false,
            "gap": 12,
            "arguments": {},
            "branchCount": 0,
            "platform": ["mblockpc", "mblockweb"],
            "codes": {
              "arduinoc": {
                "code": `IrReceiver.resume();`
              }
            },
            "handler": this.funcs.BLOCK_1713216604820
          }, {
            "opcode": "BLOCK_1713216605004",
            "blockType": "number",
            "checkboxInFlyout": false,
            "hidden": false,
            "gap": 12,
            "arguments": {},
            "branchCount": 0,
            "platform": ["mblockpc", "mblockweb"],
            "codes": {
              "arduinoc": {
                "code": `IrReceiver.decodedIRData.command`
              }
            },
            "handler": this.funcs.BLOCK_1713216605004
          }, {
            "opcode": "BLOCK_1713216605193",
            "blockType": "string",
            "checkboxInFlyout": false,
            "hidden": false,
            "gap": 12,
            "arguments": {},
            "branchCount": 0,
            "platform": ["mblockpc", "mblockweb"],
            "codes": {
              "arduinoc": {
                "code": `lepton_ir_protocols_to_string(IrReceiver.decodedIRData.protocol)`
              }
            },
            "handler": this.funcs.BLOCK_1713216605193
          }, {
            "opcode": "BLOCK_1713216605384",
            "blockType": "string",
            "checkboxInFlyout": false,
            "hidden": false,
            "gap": 12,
            "arguments": {},
            "branchCount": 0,
            "platform": ["mblockpc", "mblockweb"],
            "codes": {
              "arduinoc": {
                "code": `String(IrReceiver.decodedIRData.decodedRawData, HEX)`
              }
            },
            "handler": this.funcs.BLOCK_1713216605384
          }],
          "menus": {}
        }],
        "generators": extGenerators,
        "translationMap": extTranslationMap,
        "snippets": codeSnippets,
        "generatorStartBlocks": [],
        "feature": ["worker"],
        "mustLoginBlocks": [],
        "disabledOffline": [],
        "disabledOnline": []
      };
    }

    getHandler() {
      if (typeof ExtHandler === 'object') {
        return ExtHandler;
      } else if (typeof ExtHandler === 'function') {
        return new ExtHandler();
      }
    }

  }

  var _default = ExtLeptonIrRemote;
  _exports.default = _default;
});