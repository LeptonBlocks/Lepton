{
    "device": false,
    "identify": "lepton_lcd_i2c",
    "version": "0.0.0",
    "name": "Lepton LCD I2C",
    "description": "",
    "homepage": "",
    "cover": {
        "name": "desktop-solid.svg",
        "url": "https://storage-eu.mblock.cc/ext-eu/extlist/prod/custom/a47d492b_desktop-solid.svg"
    },
    "platform": [
        "mblockpc",
        "mblockweb"
    ],
    "targets": [
        "arduino_uno"
    ],
    "sort": 999,
    "codeTypes": [
        "arduinoc"
    ],
    "generator": {
        "arduinoc": {
            "template": "// generated by mBlock5 for <your product>\n// codes make you happy\n\n//( include //)\n#include <Arduino.h>\n//( lib //)\n\n//({\n    this.$ALL_VARIABLES.length==0?'':this.$ALL_VARIABLES.map(v=>\"float \"+v+\" = 0;\").join('\\\\n')\n}//)\n\n//( declare //)\n\n\nvoid _delay(float seconds) {\n  long endTime = millis() + seconds * 1000;\n  while(millis() < endTime) _loop();\n}\n\n//(\nvoid setup() {\n  //( setup //)\n  //( code //)\n}\n//)\n\nvoid _loop() {\n  //( _loop //)\n}\n\nvoid loop() {\n  _loop();\n}",
            "generator": "({\n  lang: 'arduinoc',\n  template: `<%=template%>`,\n  splitor: {\n    frame: {\n      left: \"//(\",\n      right: \"//)\",\n    },\n    expression: {\n      left: \"/*{\",\n      right: \"}*/\",\n    }\n  },\n  reducers: [\n    {\n      name: 'include',\n      reduce: (codes) => {\n        let codes1 = []\n        for (let code of codes) {\n          let codeStr = '';\n          if (typeof code === 'string') {\n            codeStr = code;\n          } else if (typeof code === 'function') {\n            codeStr = code();\n          }\n          if (codes1.indexOf(codeStr) === -1) {\n            codes1.push(codeStr);\n          }\n        }\n        if (codes1.length === 0) {\n          return undefined;\n        }\n        return codes1.map(code => {\n          return '#include ' + code;\n        }).join('\\n') + '\\n'\n      }\n    }\n  ]\n})",
            "snippets": "",
            "sources": [
                {
                    "name": "I2C_LCD/I2C_LCD.h",
                    "url": "I2C_LCD/I2C_LCD.h",
                    "fileData": "#pragma once\n//\n//    FILE: I2C_LCD.h\n//  AUTHOR: Rob.Tillaart\n// VERSION: 0.2.1\n//    DATE: 2023-12-16\n// PURPOSE: Arduino library for I2C_LCD\n//     URL: https://github.com/RobTillaart/I2C_LCD\n\n\n#define I2C_LCD_LIB_VERSION     (F(\"0.2.1\"))\n\n\n#include \"Arduino.h\"\n#include \"Wire.h\"\n\nconst uint8_t POSITIVE = 1;\nconst uint8_t NEGATIVE = 0;\n\n\nclass I2C_LCD : public Print\n{\npublic:\n  //  only one constructor\n  explicit  I2C_LCD(uint8_t address, TwoWire * wire = &Wire);\n\n  //  adjust pins\n  void      config(uint8_t address, uint8_t enable, uint8_t readWrite, uint8_t registerSelect,\n                   uint8_t data4, uint8_t data5, uint8_t data6, uint8_t data7,\n                   uint8_t backLight, uint8_t polarity);\n\n  //  only supports 5x8 char set for now.\n  //  blocks up to 100 milliseconds to give LCD time to boot\n  bool      begin(uint8_t cols = 20, uint8_t rows = 4);\n  bool      isConnected();\n\n\n  //  BACKLIGHT\n  void      setBacklightPin(uint8_t pin, uint8_t polarity);\n  void      setBacklight(bool on);\n  void      backlight()   { setBacklight(true);  };\n  void      noBacklight() { setBacklight(false); };\n\n\n  //  DISPLAY ON OFF\n  void      display();\n  void      noDisplay();\n  void      on()  { display(); };\n  void      off() { noDisplay(); };\n\n\n  //  POSITIONING & CURSOR\n  void      clear();      //  clears whole screen\n  void      clearEOL();   //  clears line from current pos.\n  void      home();\n  bool      setCursor(uint8_t col, uint8_t row);\n\n  void      noBlink();\n  void      blink();\n  void      noCursor();\n  void      cursor();\n\n  void      scrollDisplayLeft();\n  void      scrollDisplayRight();\n  void      moveCursorRight(uint8_t n = 1);\n  void      moveCursorLeft(uint8_t n = 1);\n\n  //  next 4 limited support\n  void      autoscroll();\n  void      noAutoscroll();\n  void      leftToRight();\n  void      rightToLeft();\n\n\n  //  8 definable characters\n  void      createChar(uint8_t index, uint8_t * charmap);\n  //  clean way to print them\n  inline size_t special(uint8_t index) { return write((uint8_t)index); };\n\n\n  //  PRINT INTERFACE ++\n  size_t    write(uint8_t c);\n  size_t    center(uint8_t row, const char * message);\n  size_t    right(uint8_t col, uint8_t row, const char * message);\n  size_t    repeat(uint8_t c, uint8_t times);\n\n\n  //  DEBUG  development\n  uint8_t   getColumn() { return _pos; };  //  works.\n  uint32_t  getWriteCount()  { return _count; };  // works\n\n\nprivate:\n\n  void      sendData(uint8_t value);\n  void      sendCommand(uint8_t value);\n  void      send(uint8_t value, bool dataFlag);\n  void      write4bits(uint8_t value);\n\n  uint8_t   _address = 0;\n  TwoWire * _wire = NULL;\n\n  uint8_t   _enable         = 4;\n  uint8_t   _readWrite      = 2;\n  uint8_t   _registerSelect = 1;\n\n  uint8_t   _dataPin[4]     = { 16, 32, 64, 128 };  //  == pin 4, 5, 6, 7\n  //  minor optimization only for pins = 4,5,6,7\n  bool      _pin4567 = true;\n\n\n  uint8_t   _backLightPin   = 8;\n  uint8_t   _backLightPol   = 1;\n  uint8_t   _backLight      = 1;\n\n  uint8_t   _cols = 20;\n  uint8_t   _rows = 4;\n\n  //  DISPLAYCONTROL bit always on, set in constructor.\n  uint8_t   _displayControl = 0;\n\n  //  overflow protection\n  uint8_t   _pos = 0;\n\n  uint32_t  _count = 0;\n};\n\n\n//  -- END OF FILE --\n\n"
                },
                {
                    "name": "I2C_LCD/I2C_LCD_special_chars.h",
                    "url": "I2C_LCD/I2C_LCD_special_chars.h",
                    "fileData": "#pragma once\n//\n//    FILE: I2C_LCD_special_chars.h\n//  AUTHOR: Rob.Tillaart\n// VERSION: see library.properties\n// PURPOSE: Arduino library for I2C_LCD\n//     URL: https://github.com/RobTillaart/I2C_LCD\n\n\n//  SPECIAL CHARS,\n//  will only work on displays with ROM CODE A00\n\n\nconst char LCD_ALPHA    = 0xE0;\nconst char LCD_BETA     = 0xE2;\nconst char LCD_EPSILON  = 0xE3;\nconst char LCD_MU       = 0xE4;\nconst char LCD_RHO      = 0xE5;\nconst char LCD_SQROOT   = 0xE7;\n\nconst char LCD_THETA    = 0xF2;\nconst char LCD_INFINITY = 0xF3;\nconst char LCD_OHM      = 0xF4;\nconst char LCD_SIGMA    = 0xF6;\nconst char LCD_PI       = 0xF7;\nconst char LCD_XAVG     = 0xF8;\n\nconst char LCD_DEGREE   = 0xDF;\nconst char LCD_DIVIDE   = 0xFD;\n\n\n\n//  -- END OF FILE --\n\n"
                },
                {
                    "name": "I2C_LCD/I2C_LCD.cpp",
                    "url": "I2C_LCD/I2C_LCD.cpp",
                    "fileData": "//\n//    FILE: I2C_LCD.cpp\n//  AUTHOR: Rob.Tillaart\n// VERSION: 0.2.0\n//    DATE: 2023-12-16\n// PURPOSE: Arduino library for I2C_LCD\n//     URL: https://github.com/RobTillaart/I2C_LCD\n\n\n#include \"I2C_LCD.h\"\n\n//  40 us is a save value at any speed.\n//  20 us is a save value for I2C at 400K.\nconst uint8_t I2C_LCD_CHAR_DELAY = 0;\n\n\n///////////////////////////////////////////////////////\n//\n//  DO NOT CHANGE BELOW THIS LINE\n//\n//  keep defines compatible / recognizable\n//  the zero valued defines are not used.\n#define I2C_LCD_CLEARDISPLAY        0x01\n#define I2C_LCD_RETURNHOME          0x02\n#define I2C_LCD_ENTRYMODESET        0x04\n#define I2C_LCD_DISPLAYCONTROL      0x08\n#define I2C_LCD_CURSORSHIFT         0x10\n#define I2C_LCD_FUNCTIONSET         0x20\n#define I2C_LCD_SETCGRAMADDR        0x40\n#define I2C_LCD_SETDDRAMADDR        0x80\n\n#define I2C_LCD_ENTRYLEFT           0x02\n#define I2C_LCD_ENTRYSHIFTINCREMENT 0x01\n\n#define I2C_LCD_DISPLAYON           0x04\n#define I2C_LCD_CURSORON            0x02\n#define I2C_LCD_BLINKON             0x01\n\n#define I2C_LCD_DISPLAYMOVE         0x08\n#define I2C_LCD_MOVERIGHT           0x04\n\n#define I2C_LCD_8BITMODE            0x10\n#define I2C_LCD_2LINE               0x08\n#define I2C_LCD_5x10DOTS            0x04\n\n\nI2C_LCD::I2C_LCD(uint8_t address, TwoWire * wire)\n{\n  _address = address;\n  _wire = wire;\n  _displayControl = I2C_LCD_DISPLAYCONTROL;\n}\n\n\nvoid I2C_LCD::config (uint8_t address, uint8_t enable, uint8_t readWrite, uint8_t registerSelect,\n                      uint8_t data4, uint8_t data5, uint8_t data6, uint8_t data7,\n                      uint8_t backLight, uint8_t polarity)\n{\n  if (_address != address) return;  //  compatible?\n  _enable         = ( 1 << enable);\n  _readWrite      = ( 1 << readWrite);\n  _registerSelect = ( 1 << registerSelect);\n  _dataPin[0]     = ( 1 << data4);\n  _dataPin[1]     = ( 1 << data5);\n  _dataPin[2]     = ( 1 << data6);\n  _dataPin[3]     = ( 1 << data7);\n  _backLightPin   = ( 1 << backLight);\n  _backLightPol   = polarity;\n\n  _pin4567 = ((data4 == 4) && (data5 == 5) && (data6 == 6) && (data7 == 7));\n  //  if pins are 0,1,2,3 they are also in order \n  //  but the shift/mask in send() should be different\n  //  4,5,6,7 is most used afaik.\n}\n\n\nbool I2C_LCD::begin(uint8_t cols, uint8_t rows)\n{\n  //  no check for range, user responsibility, defaults are 20x4\n  _cols = cols;\n  _rows = rows;\n\n  if (isConnected() == false) return false;\n\n  //  ALL LINES LOW.\n  _wire->beginTransmission(_address);\n  _wire->write(0x00);\n  _wire->endTransmission();\n\n  //  Figure 24 for procedure on 4-bit initialization\n  //  wait for more than 15 ms\n  //  if other objects initialize earlier there will be less blocking time.\n  //  => assumes display is started at same time as MCU\n  while (millis() < 100) delay(1);\n\n  //  Force 4 bit mode, see datasheet.\n  //  times are taken longer for robustness.\n  //  note this is typically only called once.\n  write4bits(0x03);\n  delayMicroseconds(5000);  //  datasheet > 4.1 millis\n  write4bits(0x03);\n  delayMicroseconds(200);   //  datasheet > 100 usec\n  write4bits(0x03);\n  delayMicroseconds(200);   //  datasheet > 100 usec\n\n  //  command to set 4 bit interface\n  write4bits(0x02);\n  delayMicroseconds(200);\n\n  //  set \"two\" lines LCD - fixed for now.\n  sendCommand(I2C_LCD_FUNCTIONSET | I2C_LCD_2LINE);\n  //  default enable display\n  display();\n  clear();\n  return true;\n}\n\n\nbool I2C_LCD::isConnected()\n{\n  _wire->beginTransmission(_address);\n  return (_wire->endTransmission() == 0);\n}\n\n\n/////////////////////////////////////////////////\n//\n//  BACKLIGHT\n//\nvoid I2C_LCD::setBacklightPin(uint8_t pin, uint8_t polarity)\n{\n  _backLightPin = (1 << pin);\n  _backLightPol = polarity;\n}\n\n\nvoid I2C_LCD::setBacklight(bool on)\n{\n  _backLight = (on == _backLightPol);\n  if (_backLight) display();\n  else noDisplay();\n}\n\n\n/////////////////////////////////////////////////\n//\n//  DISPLAY\n//\nvoid I2C_LCD::display()\n{\n  _displayControl |= I2C_LCD_DISPLAYON;\n  sendCommand(_displayControl);\n}\n\n\nvoid I2C_LCD::noDisplay()\n{\n  _displayControl &= ~I2C_LCD_DISPLAYON;\n  sendCommand(_displayControl);\n}\n\n\n/////////////////////////////////////////////////\n//\n//  POSITIONING & CURSOR\n//\nvoid I2C_LCD::clear()\n{\n  sendCommand(I2C_LCD_CLEARDISPLAY);\n  _pos = 0;\n  delay(2);\n}\n\n\nvoid I2C_LCD::clearEOL()\n{\n  while(_pos  < _cols)\n  {\n    print(' ');\n  }\n}\n\n\nvoid I2C_LCD::home()\n{\n  sendCommand(I2C_LCD_RETURNHOME);\n  _pos = 0;\n  delayMicroseconds(1600);  //  datasheet states 1520.\n}\n\n\nbool I2C_LCD::setCursor(uint8_t col, uint8_t row)\n{\n  if ((col >= _cols) || (row >= _rows)) return false;\n\n  //  more efficient address / offset calculation (no lookup so far).\n  uint8_t offset = 0x00;\n  if (row & 0x01) offset += 0x40;\n  if (row & 0x02) offset += _cols;\n  offset += col;\n  _pos = col;\n\n  sendCommand(I2C_LCD_SETDDRAMADDR | offset );\n  return true;\n\n  //  ORIGINAL SETCURSOR CODE \n  //  all start position arrays start with 0x00 0x40\n  //  they have an offset of 0x14, 0x10 or 0x0A\n  //  so only 3 bytes are needed?\n  //  note that e.g. 16x2 only uses the first 2 offsets.\n  // uint8_t startPos[4]  = { 0x00, 0x40, 0x14, 0x54 };  //  most displays\n  // uint8_t start16x4[4] = { 0x00, 0x40, 0x10, 0x50 };  //  16x4 display\n  // uint8_t start10x4[4] = { 0x00, 0x40, 0x0A, 0x4A };  //  10x4 LOGO display\n\n  // //  if out of range exit!\n  // if ((col >= _cols) || (row >= _rows)) return false;\n\n  // _pos = col;\n  // if ((_rows == 4) && (_cols == 16))\n  // {\n    // sendCommand(I2C_LCD_SETDDRAMADDR | (start16x4[row] + col) );\n    // return true;\n  // }\n  // if ((_rows == 4) && (_cols == 10))\n  // {\n    // sendCommand(I2C_LCD_SETDDRAMADDR | (start10x4[row] + col) );\n    // return true;\n  // }\n  // sendCommand(I2C_LCD_SETDDRAMADDR | (startPos[row] + col) );\n  // return true;\n}\n\n\nvoid I2C_LCD::blink()\n{\n  _displayControl |= I2C_LCD_BLINKON;\n  sendCommand(_displayControl);\n}\n\n\nvoid I2C_LCD::noBlink()\n{\n  _displayControl &= ~I2C_LCD_BLINKON;\n  sendCommand(_displayControl);\n}\n\n\nvoid I2C_LCD::cursor()\n{\n  _displayControl |= I2C_LCD_CURSORON;\n  sendCommand(_displayControl);\n}\n\n\nvoid I2C_LCD::noCursor()\n{\n  _displayControl &= ~I2C_LCD_CURSORON;\n  sendCommand(_displayControl);\n}\n\n\nvoid I2C_LCD::scrollDisplayLeft(void)\n{\n  sendCommand(I2C_LCD_CURSORSHIFT | I2C_LCD_DISPLAYMOVE);\n}\n\n\nvoid I2C_LCD::scrollDisplayRight(void)\n{\n  sendCommand(I2C_LCD_CURSORSHIFT | I2C_LCD_DISPLAYMOVE | I2C_LCD_MOVERIGHT);\n}\n\n\nvoid I2C_LCD::moveCursorLeft(uint8_t n)\n{\n  while ((_pos > 0) && (n--))\n  {\n    sendCommand(I2C_LCD_CURSORSHIFT);\n    _pos--;\n  }\n}\n\n\nvoid I2C_LCD::moveCursorRight(uint8_t n)\n{\n  while ((_pos < _cols) && (n--))\n  {\n    sendCommand(I2C_LCD_CURSORSHIFT | I2C_LCD_MOVERIGHT);\n    _pos++;\n  }\n}\n\n\nvoid I2C_LCD::autoscroll(void)\n{\n  sendCommand(I2C_LCD_ENTRYMODESET | I2C_LCD_ENTRYSHIFTINCREMENT);\n}\n\n\nvoid I2C_LCD::noAutoscroll(void)\n{\n  sendCommand(I2C_LCD_ENTRYMODESET);\n}\n\n\nvoid I2C_LCD::leftToRight(void)\n{\n  sendCommand(I2C_LCD_ENTRYMODESET | I2C_LCD_ENTRYLEFT);\n}\n\n\nvoid I2C_LCD::rightToLeft(void)\n{\n  sendCommand(I2C_LCD_ENTRYMODESET);\n}\n\n\n/////////////////////////////////////////////////\n//\n//  CHARMAP\n//\nvoid I2C_LCD::createChar(uint8_t index, uint8_t * charmap)\n{\n  sendCommand(I2C_LCD_SETCGRAMADDR | ((index & 0x07) << 3));\n  uint8_t tmp = _pos;\n  for (uint8_t i = 0; i < 8; i++)\n  {\n    _pos = 0;\n    sendData(charmap[i]);\n  }\n  _pos = tmp;\n}\n\n\nsize_t I2C_LCD::write(uint8_t c)\n{\n  size_t n = 0;\n  if (c == (uint8_t)'\\t')  //  handle TAB char\n  {\n    while (((_pos % 4) != 0) && (_pos < _cols))\n    {\n      moveCursorRight();   //  increases _pos.\n      n++;\n    }\n    return n;\n  }\n  if (_pos < _cols)   //  overflow protect.\n  {\n    sendData(c);\n    _pos++;\n    return 1;\n  }\n  //  not allowed to print beyond display, so return 0.\n  return 0;\n};\n\n\nsize_t I2C_LCD::center(uint8_t row, const char * message)\n{\n  uint8_t len = strlen(message) + 1;\n  setCursor((_cols - len) / 2, row);\n  return print(message);\n}\n\n\nsize_t I2C_LCD::right(uint8_t col, uint8_t row, const char * message)\n{\n  uint8_t len = strlen(message);\n  setCursor(col - len, row);\n  return print(message);\n}\n\n\nsize_t I2C_LCD::repeat(uint8_t c, uint8_t times)\n{\n  size_t n = 0;\n  while((times--) && (_pos < _cols)) \n  {\n    n += write(c);\n  }\n  return n;\n}\n\n\n//////////////////////////////////////////////////////////\n//\n//  PRIVATE\n//\nvoid I2C_LCD::sendCommand(uint8_t value)\n{\n  send(value, false);\n}\n\n\nvoid I2C_LCD::sendData(uint8_t value)\n{\n  send(value, true);\n}\n\n\nvoid I2C_LCD::send(uint8_t value, bool dataFlag)\n{\n  //  calculate both \n  //  MSN == most significant nibble and \n  //  LSN == least significant nibble\n  uint8_t MSN = 0;\n  if (dataFlag)   MSN = _registerSelect;\n  if (_backLight) MSN |= _backLightPin;\n  uint8_t LSN = MSN;\n\n  if (_pin4567)  //  4,5,6,7 only == most used.\n  {\n    MSN |= value & 0xF0;\n    LSN |= value << 4;\n  }\n  else  //  ~ 1.7% slower UNO.  (adds 4 us / char)\n  {\n    for ( uint8_t i = 0; i < 4; i++ )\n    {\n      if ( value & 0x01 ) LSN |= _dataPin[i];\n      if ( value & 0x10 ) MSN |= _dataPin[i];\n      value >>= 1;\n    }\n  }\n\n  _wire->beginTransmission(_address);\n  _wire->write(MSN | _enable);\n  _wire->write(MSN);\n  _wire->write(LSN | _enable);\n  _wire->write(LSN);\n  _wire->endTransmission();\n  if (I2C_LCD_CHAR_DELAY) delayMicroseconds(I2C_LCD_CHAR_DELAY);\n}\n\n\n//  needed for setup\nvoid I2C_LCD::write4bits(uint8_t value)\n{\n  uint8_t cmd = 0;\n\n  for ( uint8_t i = 0; i < 4; i++ )\n  {\n    if ( value & 0x01 ) cmd |= _dataPin[i];\n    value >>= 1;\n  }\n\n  _wire->beginTransmission(_address);\n  _wire->write(cmd | _enable);\n  _wire->endTransmission();\n  _wire->beginTransmission(_address);\n  _wire->write(cmd);\n  _wire->endTransmission();\n}\n\n\n//  -- END OF FILE --\n\n"
                },
                {
                    "name": "I2C_LCD/I2C_LCD_custom_chars.h",
                    "url": "I2C_LCD/I2C_LCD_custom_chars.h",
                    "fileData": "#pragma once\n//\n//    FILE: I2C_LCD_custom_chars.h\n//  AUTHOR: Rob.Tillaart\n// VERSION: see library.properties\n// PURPOSE: Arduino library for I2C_LCD\n//     URL: https://github.com/RobTillaart/I2C_LCD\n//          https://maxpromer.github.io/LCD-Character-Creator/\n//\n//  See examples for some more\n\n\n////////////////////////////////////\n//\n//  Special\n//\n\n//  one-liners easier to search?\n//  uint8_t paragraph[] = { 0x06, 0x09, 0x04, 0x10, 0x04, 0x12, 0x0E, 0x00 };\n\nuint8_t paragraph[] = {\n  B00110,\n  B01001,\n  B00100,\n  B01010,\n  B00100,\n  B10010,\n  B01110,\n  B00000\n};\n\nuint8_t copyRight[] = {\n  B00000,\n  B11111,\n  B10001,\n  B10111,\n  B10111,\n  B10001,\n  B11111,\n  B00000\n};\n\n\n////////////////////////////////////\n//\n//  Math\n//\nuint8_t lessThan[] = {\n  B00000,\n  B00010,\n  B00100,\n  B01000,\n  B00100,\n  B00010,\n  B00000,\n  B11111\n};\n\nuint8_t moreThan[] = {\n  B00000,\n  B01000,\n  B00100,\n  B00010,\n  B00100,\n  B01000,\n  B00000,\n  B11111\n};\n\nuint8_t notEqual[] = {\n  B00000,\n  B00010,\n  B00010,\n  B11111,\n  B00100,\n  B11111,\n  B01000,\n  B01000\n};\n\n////////////////////////////////////\n//\n//  ARROWS\n//\nuint8_t doubleUP[] = {\n  B00100,\n  B01110,\n  B11111,\n  B00000,\n  B00100,\n  B01110,\n  B11111,\n  B00000\n};\n\nuint8_t doubleDOWN[] = {\n  B11111,\n  B01110,\n  B00100,\n  B00000,\n  B11111,\n  B01110,\n  B00100,\n  B00000\n};\n\nuint8_t openUP[] = {\n  B00000,\n  B00100,\n  B01010,\n  B01010,\n  B10001,\n  B10001,\n  B11111,\n  B00000\n};\n\nuint8_t openDown[] = {\n  B00000,\n  B11111,\n  B10001,\n  B10001,\n  B01010,\n  B01010,\n  B00100,\n  B00000\n};\n\n////////////////////////////////////\n//\n//  BRACKETS   --[]--\n//\nuint8_t bracketRight[] = {\n  B11100,\n  B00100,\n  B00100,\n  B00111,\n  B00100,\n  B00100,\n  B11100,\n  B00000\n};\n\nuint8_t bracketLeft[] = {\n  B00111,\n  B00100,\n  B00100,\n  B11100,\n  B00100,\n  B00100,\n  B00111,\n  B00000\n};\n\nuint8_t singleLine[] = {\n  B00000,\n  B00000,\n  B00000,\n  B11111,\n  B00000,\n  B00000,\n  B00000,\n  B00000\n};\n\nuint8_t doubleLine[] = {\n  B11111,\n  B00000,\n  B00000,\n  B00000,\n  B00000,\n  B00000,\n  B11111,\n  B00000\n};\n\n\n////////////////////////////////////\n//\n//  Other\n//\nuint8_t OnOff[] = {\n  B00100,\n  B00100,\n  B01110,\n  B10101,\n  B10101,\n  B10001,\n  B01110,\n  B00000\n};\n\nuint8_t smiley[] = {\n  B00000,\n  B00000,\n  B01010,\n  B00000,\n  B10001,\n  B01110,\n  B00000,\n  B00000\n};\n\nuint8_t heart[] = {\n  B00000,\n  B01010,\n  B10101,\n  B10001,\n  B01010,\n  B00100,\n  B00000,\n  B00000\n};\n\n\n//  -- END OF FILE --\n\n"
                }
            ]
        }
    },
    "main": "https://storage-eu.mblock.cc/ext-eu/extlist/prod/previewJs/lepton_lcd_i2c__49_2276715.js",
    "originVersion": "0.0.1",
    "id": "31082"
}